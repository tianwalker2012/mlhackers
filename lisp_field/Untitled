This is SBCL 1.0.55.0-abb03f9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
* 
(load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition


; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MKSTR
;     (PRINTC A S)
; 
; caught STYLE-WARNING:
;   undefined function: PRINTC
; 
; compilation unit finished
;   Undefined function:
;     PRINTC
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 262, Column: 1, File-Position: 7621

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {12EDBEC1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {12EDBEC1}>
 7620)
0] .



debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  dot context error

    File-Position: 399

    Stream: #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>
 "dot context error")
0[2] abort

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-SPLITIF
;     (CDR CURLST)
; ==>
;   CURLST
; 
; caught STYLE-WARNING:
;   reading an ignored variable: CURLST
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 263, Column: 1, File-Position: 7648

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {11D0D789}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {11D0D789}>
 7647)
0] abort

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-SPLITIF
;     (LET ((RET (FUNCALL FN ELM)))
;       (PROGN
;        (PUSH ELM FIRST)
;        (IF RET
;            (SETF SECOND #))
;        (VALUES (NOT RET) RET)))
; 
; caught WARNING:
;   unrecognized declaration (LET ((RET (FUNCALL FN ELM)))
;                              (PROGN
;                               (PUSH ELM FIRST)
;                               (IF RET
;                                   (SETF SECOND (CDR CURLST)))
;                               (VALUES (NOT RET) RET)))

;     (DEFUN MY-SPLITIF (FN LSTS)
;       (LET ((FIRST NIL) (SECOND NIL))
;         (IF (MY-ITERATE #'(LAMBDA # #) LSTS)
;             (VALUES (REVERSE FIRST) SECOND)
;             (VALUES NIL NIL))))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MY-SPLITIF
;         (FN LSTS)
;       (BLOCK MY-SPLITIF
;         (LET ((FIRST NIL) (SECOND NIL))
;           (IF (MY-ITERATE #'# LSTS)
;               (VALUES # SECOND)
;               (VALUES NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable FN is defined but never used.

;     #'(LAMBDA (ELM CURLST)
;         (DECLARE (IGNORE CURLST)
;                  (LET ((RET #))
;                    (PROGN
;                     (PUSH ELM FIRST)
;                     (IF RET
;                         #)
;                     (VALUES # RET)))))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.
; 
; compilation unit finished
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 263, Column: 1, File-Position: 7651

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {1253E029}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {1253E029}>
 7650)
0] abort

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 262, Column: 1, File-Position: 7619

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {12D52061}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {12D52061}>
 7618)
0] abort

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 262, Column: 1, File-Position: 7619

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {11B4C061}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {11B4C061}>
 7618)
0]abort 0]abort

; in: LAMBDA (#:G1012)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13F48019}>
;                         #:G1012))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13F48039}>
;                         #:G1012)))
;       0]ABORT)
; 
; caught WARNING:
;   undefined variable: 0]ABORT
; 
; compilation unit finished
;   Undefined variable:
;     0]ABORT
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable 0]ABORT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G1012) :IN "/Users/apple/work_foot/lisp_field/second.lisp")
 #<unavailable argument>)
0[2] abort

0] abort

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
* (tr-if '(1 2 (3 4) 6 7 8) #'(lambda (elm) (eql 10 elm)))

NIL
* (tr-if '(1 2 (3 4) 6 7 8) #'(lambda (elm) (format t "~a ~%" elm) (eql 6 elm)))
1 
2 
3 
4 
NIL 
6 
7 
8 
NIL 
NIL
* (tr-if '(1 2 (3 4) 6 7 8) #'(lambda (elm) (format t "~a ~%" elm) (eql 10 elm)))
1 
2 
3 
4 
NIL 
6 
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition


; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN TREV
;     (IF (CDR TR)
;         SELF
;         (CDR TR))
; 
; caught WARNING:
;   undefined variable: SELF
; 
; compilation unit finished
;   Undefined variable:
;     SELF
;   caught 1 WARNING condition

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
* (tr-if '(1 2 (3 4) 6 7 8) #'(lambda (elm) (format t "~a ~%" elm) (eql 10 elm)))
1 
2 
3 
4 
6 
7 
8 
NIL
*(load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
* (fun-test 15)

35
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
* (fun-test 30)

10
* (macroexpand '(fun-test 10)
)

(- 10 20)
T
* (macroexpand '(fun-test 30))

(- 30 20)
T
* (microexpand '(or x y z))

; in: MICROEXPAND '(OR X Y Z)
;     (MICROEXPAND '(OR X Y Z))
; 
; caught STYLE-WARNING:
;   undefined function: MICROEXPAND
; 
; compilation unit finished
;   Undefined function:
;     MICROEXPAND
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::MICROEXPAND is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (macroexpand 
'(or x y z))

(LET ((#:G1296 X))
  (IF #:G1296
      #:G1296
      (OR Y Z)))
T
* (macroexpand 
'(and x y z))

(IF X
    (AND Y Z)
    NIL)
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
* (mp (and x y x))

(IF X
    (AND Y X)
    NIL)
T
* (mp (and x y z) (or a b c))

debugger invoked on a SIMPLE-ERROR:
  wrong number of args to QUOTE:
 (QUOTE (AND X Y Z) (OR A B C))

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV (QUOTE (AND X Y Z) (OR A B C)) #<NULL-LEXENV>)
0] abort

* (setq x 12)

; in: SETQ X
;     (SETQ X 12)
; 
; caught WARNING:
;   undefined variable: X
; 
; compilation unit finished
;   Undefined variable:
;     X
;   caught 1 WARNING condition

12
* x

12
* (map-car #'(lambda (x) (format t "~a ~%" x)) '(1 2 3 . 4))

; in: MAP-CAR #'(LAMBDA (X) (FORMAT T "~a ~%" X))
;     (MAP-CAR #'(LAMBDA (X) (FORMAT T "~a ~%" X)) '(1 2 3 . 4))
; 
; caught STYLE-WARNING:
;   undefined function: MAP-CAR
; 
; compilation unit finished
;   Undefined function:
;     MAP-CAR
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::MAP-CAR is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (mapcar #'(lambda (x) (format t "~a ~%" x)) '(1 2 3 . 5))
1 
2 
3 

debugger invoked on a TYPE-ERROR: The value 5 is not of type LIST.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-IMPL::MAP1 #<FUNCTION (LAMBDA #) {129916B5}> ((1 2 3 . 5)) :LIST T)
0] abort
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFMACRO MY-DESTRUCTING-BIND
;     (DEFMACRO MY-DESTRUCTING-BIND (BINDS PARAMETERS &BODY BODY))
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((BINDS (CAR (CDR #:WHOLE1421)))
;          (PARAMETERS (CAR (CDR #)))
;          (BODY (CDR (CDR #))))
;     (BLOCK MY-DESTRUCTING-BIND))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BODY is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions

T
*(trev-all '(1 2 3 . 4) #'(lambda (x) (format t "~a ~%" x))) (trev-all '(1 2 3 . 4) #'(lambda (x) (format t "~a ~%" x)))
1 
2 
3 
4 
NIL
* (defun make-pair ()
)

MAKE-PAIR

(load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

T
*(mp (my-destructing-bind w z (+x y)))  (mp (my-destructing-bind w z (+x y)))

(LET ((X 1) (Y 2))
  (+X Y))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions


; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN WALK-BOTH
;     (WORK-BOTH ELM (CAR SECOND) FN)
; 
; caught STYLE-WARNING:
;   undefined function: WORK-BOTH
; 
; compilation unit finished
;   Undefined function:
;     WORK-BOTH
;   caught 1 STYLE-WARNING condition

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

T
* (walk-both '(1 2 (3 4)) '(a b (c d)) #'(lambda (x y) (format t "~a:~a ~%" x y)`(,x ,y) ))
1:A 
2:B 
3:C 
4:D 
NIL
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

T
* (walk-both '(1 2 (3 4)) '(a b (c d)) #'(lambda (x y) (format t "~a:~a ~%" x y)`(,x ,y) ))
1:A 
((1 A))
* 4:D 


debugger invoked on a SB-KERNEL:SIMPLE-PACKAGE-ERROR:
  The name "4" does not designate any package.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:%FIND-PACKAGE-OR-LOSE "4")
0] 
abort

* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

T
* (walk-both '(1 2 (3 4)) '(a b (c d)) #'(lambda (x y) (format t "~a:~a ~%" x y)`(,x ,y) ))
1:A 
2:B 
3:C 
4:D 
((4 D) (3 C) (2 B) (1 A))
* (mp (my-destructing-bind (a b c) '(1 2 3) (format t "~a ~a ~a ~%" a b c)))

(LET ((X 1) (Y 2))
  (FORMAT T "~a ~a ~a ~%" A B C))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFMACRO MY-DESTRUCTING-BIND
;     #'(LAMBDA (X Y) '(X Y))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

T
*(load "second.lisp") (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

T
* (mp (my-destructing-bind (a b c) (1 2 3) (format t "~a ~a ~a ~%" a b c)))

(LET ((C NIL) (B (1 2 3)) (A QUOTE))
  (FORMAT T "~a ~a ~a ~%" A B C))
T
* (mp (my-destructing-bind (a b c) '(1 2 3) (format t "~a ~a ~a ~%" a b c)))

(LET ((C 3) (B 2) (A 1))
  (FORMAT T "~a ~a ~a ~%" A B C))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MATCH-PAIR
;     (DEFUN MATCH-PAIR (BINDS PARAMETERS) '((X 1) (Y 2)))
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH-PAIR
;         (BINDS PARAMETERS)
;       (BLOCK MATCH-PAIR '((X 1) (Y 2))))
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable PARAMETERS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

T
* (mp (my-destructing-bind (a b c) '(1 2 3) (format t "~a ~a ~a ~%" a b c)))

debugger invoked on a TYPE-ERROR: The value QUOTE is not of type LIST.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LABELS WALK-IN :IN WALK-BOTH) (A B C) QUOTE #<unavailable argument>)
0] abort

* (mapcan #'(lambda (x) x) '(1 2 3 4 5))

5
* (mapcar #'(lambda (x) x) '(1 2 3 4 5))

(1 2 3 4 5)
* (mapcan #'(lambda (x) (list x)) '(1 2 3 4 5))

(1 2 3 4 5)
* (mapcan #'(lambda (x) (list x 2)) '(1 2 3 4 5))

(1 2 2 2 3 2 4 2 5 2)
* (mp (setf (car t) 'cool))

(SB-KERNEL:%RPLACA T 'COOL)
T
* (mp (setf (cdr t) 'cool))

(SB-KERNEL:%RPLACD T 'COOL)
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 345, Column: 37, File-Position: 9988

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {131F7EC1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

abortrestarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {131F7EC1}>
 9949)
0] abort

T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
*
; in: MY-DEFUN COOLGUY
;     (FORMAT "coolest guy x:~a y:~a ~%" X Y)
; 
; caught WARNING:
;   Literal string as destination in FORMAT:
;     (FORMAT "coolest guy x:~a y:~a ~%" X Y)
; 
; compilation unit finished
;   caught 1 WARNING condition

COOLGUY
* (mp (my-defun coolguy(x y) "very cool" (format t "coolest guy x:~a y:~a ~%" x y)))

COOLGUY
* (mp (my-defun coolguy(x y) "very cool" (format t "coolest guy x:~a y:~a ~%" x y)))

(PROGN
 (SETF (SYMBOL-FUNCTION 'COOLGUY)
         #'(LAMBDA (X Y)
             (BLOCK COOLGUY
               "very cool"
               (FORMAT T "coolest guy x:~a y:~a ~%" X Y))))
 'COOLGUY)
T
* (coolguy 10 "hot now")
coolest guy x:10 y:hot now 
NIL
* (my-when (< *tiange* 10) (format t "tiange:~a ~%" *tiange*))

; in: MY-WHEN (< *TIANGE* 10)
;     (FORMAT T "tiange:~a ~%" *TIANGE*)
; 
; caught WARNING:
;   undefined variable: *TIANGE*
; 
; compilation unit finished
;   Undefined variable:
;     *TIANGE*
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable *TIANGE* is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort

* (defvar *tiange*)

*TIANGE*
* (setq *tiange* 0)

0
* (my-when (< *tiange* 10) (format t "tiange:~a ~%" *tiange*))
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tian  ^C ^Cge:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0 
tiange:0tiange:0 

debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT:
  Interactive interrupt at #x9C520066.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] Return from SB-UNIX:SIGINT.
  1: [ABORT   ] Exit debugger, returning to top level.

("bogus stack frame")
0]   ^C ^C

debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT:
  Interactive interrupt at #x9C51FB5E.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] Return from SB-UNIX:SIGINT.
  1:            Return from SB-UNIX:SIGINT.
  2: [ABORT   ] Exit debugger, returning to top level.

("bogus stack frame")
0[2] abort
* (my-when (< *tiange* 10) (incf *tiange*) (format t "tiange:~a ~%" *tiange*)) 
tiange:1 
tiange:2 
tiange:3 
tiange:4 
tiange:5 
tiange:6 
tiange:7 
tiange:8 
tiange:9 
tiange:10 
NIL
* (mp (let ((x 10)) (+ x x)))

(LET ((X 10))
  (+ X X))
NIL
* (do ((x 0 (+ x 1)) (y 10)) (> x 10) (format t "x:~a y:~a ~%" x y))

; in: DO ((X 0 (+ X 1)) (Y 10))
;     (UNLESS >= (GO #:G2111))
; ==>
;   (IF >=
;       NIL
;       (PROGN (GO #:G2111)))
; 
; caught WARNING:
;   undefined variable: >=
; 
; compilation unit finished
;   Undefined variable:
;     >=
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable >= is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] break

; in: LAMBDA (#:G2113)
;     (SYMBOL-MACROLET ()
;       BREAK)
; 
; caught WARNING:
;   undefined variable: BREAK
; 
; compilation unit finished
;   Undefined variable:
;     BREAK
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable BREAK is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G2113)) #<unavailable argument>)
0[2] abort

0] abort

* (do ((x 0 (+ x 1)) (y 10)) (equal x 10) (format t "x:~a y:~a ~%" x y))

; in: DO ((X 0 (+ X 1)) (Y 10))
;     (UNLESS > (GO #:G2114))
; ==>
;   (IF >
;       NIL
;       (PROGN (GO #:G2114)))
; 
; caught WARNING:
;   undefined variable: >
; 
; compilation unit finished
;   Undefined variable:
;     >
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable > is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort

* (do ((x 0 (+ x 1)) (y 10)) ((equal x 10)) (format t "x:~a y:~a ~%" x y))

;     (UNLESS EQUAL (GO #:G2116))
; ==>
;   (IF EQUAL
;       NIL
;       (PROGN (GO #:G2116)))
; 
; caught WARNING:
;   undefined variable: EQUAL
; 
; compilation unit finished
;   Undefined variable:
;     EQUAL
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable EQUAL is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] (do ((x 0 (+ x 1)) (y 10 (+ y 1))) ((equal x 10)) (format t "x:~a y:~a ~%" x y))
x:0 y:10 
x:1 y:10 
x:2 y:10 
x:3 y:10 
x:4 y:10 
x:5 y:10 
x:6 y:10 
x:7 y:10 
x:8 y:10 
x:9 y:10 

NIL
0] (do ((x 0 (+ x 1)) (y 10 (+ y 1))) ((equal x 10) (equal y 15)) (format t "x:~a y:~a ~%" x y))
x:0 y:10 
x:1 y:11 
x:2 y:12 
x:3 y:13 
x:4 y:14 
x:5 y:15 
x:6 y:16 
x:7 y:17 
x:8 y:18 
x:9 y:19 

NIL
0] (do ((x 0 (+ x 1)) (y 10 (+ y 1))) ((equal x 3) (equal y 15)) (format t "x:~a y:~a ~%" x y))
x:0 y:10 
x:1 y:11 
x:2 y:12 
x:3 y:13 
x:4 y:14 
x:5 y:15 
x:6 y:16 
x:7 y:17 
x:8 y:18 
x:9 y:19 

NIL
0] (do ((x 0 (+ x 1)) (y 10 (+ y 1))) ((equal x 3) (equal y 15)) (format t "x:~a y:~a ~%" x y))
x:0 y:10 
x:1 y:11 
x:2 y:12 

NIL
0] abort
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
* (my-when ((x 1) (y 2)) (< y 10) (format t "x:~a y:~a ~%" x y))

debugger invoked on a SIMPLE-ERROR: DO step variable is not a symbol: (X 1)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-SYS:FROB-DO-BODY
 (((X 1) (Y 2)))
 ((NOT (< Y 10)))
 ((FORMAT T "x:~a y:~a ~%" X Y))
 LET
 PSETQ
 DO
 NIL)
0] abort

* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

T
* (my-when ((x 1 (+ 1 x)) (y 2)) (< x 20) (format t "x:~a y:~a ~%" x y))
x:1 y:2 
x:2 y:2 
x:3 y:2 
x:4 y:2 
x:5 y:2 
x:6 y:2 
x:7 y:2 
x:8 y:2 
x:9 y:2 
x:10 y:2 
x:11 y:2 
x:12 y:2 
x:13 y:2 
x:14 y:2 
x:15 y:2 
x:16 y:2 
x:17 y:2 
x:18 y:2 
x:19 y:2 
NIL
* (setq *tiange* '(1 2))

(1 2)
* (nconc *tiange* 
'(3 4))

(1 2 3 4)
* *tiange*

(1 2 3 4)
* (gensym)

#:G2290
* (gensym
)

#:G2291
* (defvar *symbols*)

*SYMBOLS*
* (setf *symbols* (gensym))

#:G2292
* *symbols*

#:G2292
* (defun my-fun(x) (+ x 10))

MY-FUN
* (function-symbol my-fun)

; in: FUNCTION-SYMBOL MY-FUN
;     (FUNCTION-SYMBOL MY-FUN)
; 
; caught STYLE-WARNING:
;   undefined function: FUNCTION-SYMBOL
; 
; caught WARNING:
;   undefined variable: MY-FUN
; 
; compilation unit finished
;   Undefined function:
;     FUNCTION-SYMBOL
;   Undefined variable:
;     MY-FUN
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY-FUN is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort

* (symbol-function my-fun)

debugger invoked on a UNBOUND-VARIABLE: The variable MY-FUN is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY-FUN #<NULL-LEXENV>)
0] abort

* (symbol-function 'my-fun)

#<FUNCTION MY-FUN>
* (defvar my-fun-pointer)

MY-FUN-POINTER
* (setf my-fun-pointer (symbol-function 'my-fun))

#<FUNCTION MY-FUN>
* (funcall my-fun-pointer 30)

40
* (defun your-fun(x) (format t "your fun called ~a ~%" x) (funcall my-fun-pointer x))

YOUR-FUN
* (setf (symbol-function 'my-fun) (symbol-function 'your-fun))

#<FUNCTION YOUR-FUN>
* (my-fun 40)
your fun called 40 
50
* (symbol-function '+)

#<FUNCTION +>
* (defvar *plus-fun*)

*PLUS-FUN*
* (setf *plus-fun* (symbol-function '+))

#<FUNCTION +>
* (defun my-plus(&rest rest) (format t "my plus called ~%") (apply *plus-fun* rest))

MY-PLUS
* (my-plus 1 2 4)
my plus called 
7
*

debugger invoked on a SYMBOL-PACKAGE-LOCKED-ERROR:
  Lock on package COMMON-LISP violated when setting the symbol-function of +
  while in package COMMON-LISP-USER.
See also:
  The SBCL Manual, Node "Package Locks"
  The ANSI Standard, Section 11.1.2.1.2

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE      ] Ignore the package lock.
  1: [IGNORE-ALL    ] Ignore all package locks in the context of this operation.
  2: [UNLOCK-PACKAGE] Unlock the package.
  3: [ABORT         ] Exit debugger, returning to top level.

(PACKAGE-LOCK-VIOLATION
 #<PACKAGE "COMMON-LISP">
 :SYMBOL
 +
 :FORMAT-CONTROL
 "setting the symbol-function of ~A"
 :FORMAT-ARGUMENTS
 (+))
0] CONTINUE

#<FUNCTION MY-PLUS>
*(+ 1 2 3) (+ 1 2 3)
my plus called 
6
* (do (x 10 (+ x 1)) ((nil)) (if (> x 10) (return-from nil x) (format t "x:~a ~%" x)))

debugger invoked on a SIMPLE-ERROR:
  ill-formed DO -- possibly illegal old style DO?

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-SYS:FROB-DO-BODY
 (X 10 (+ X 1))
 NIL
 ((IF (> X 10)
      (RETURN-FROM NIL X)
      (FORMAT T "x:~a ~%" X)))
 LET
 PSETQ
 DO
 NIL)
0] (do ((x 10 (+ x 1))) nil (if (> x 10) (return-from nil x) (format t "x:~a ~%" x)))
my plus called 
; in: LAMBDA (#:G2297)
;     (DO (X
;          10
;          (+ X 1))
;         ((NIL))
;       (IF (> X 10)
;           (RETURN-FROM NIL X)
;           (FORMAT T "x:~a ~%" X)))
; 
; caught ERROR:
;   during macroexpansion of
;   (DO (X
;        10
;        #)
;       (#) ...).
;   Use *BREAK-ON-SIGNALS* to intercept:
;   
;    10 is an illegal form for a DO varlist.
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (DO (X
     10
     (+ X 1))
    ((NIL))
  (IF (> X 10)
      (RETURN-FROM NIL X)
      (FORMAT T x:~a ~% X)))
Compile-time error:
  during macroexpansion of
(DO (X
     10
     #)
    (#) ...).
Use *BREAK-ON-SIGNALS* to intercept:

 10 is an illegal form for a DO varlist.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G2297)) #<unavailable argument>)
0[2] abort

0] abort
* (do ((x 10 (+ x 1))) (nil) (if (> x 10) (return-from nil x) (format t "x:~a ~%" x)))

debugger invoked on a SIMPLE-ERROR:
  ill-formed DO -- possibly illegal old style DO?

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-SYS:FROB-DO-BODY
 ((X 10 (+ X 1)))
 NIL
 ((IF (> X 10)
      (RETURN-FROM NIL X)
      (FORMAT T "x:~a ~%" X)))
 LET
 PSETQ
 DO
 NIL)
0] abort

* (do ((x 10 (+ x 1))) (nil) (if (> x 10) (return-from nil x) (format t "x:~a ~%" x)))
my plus called 
x:10 
11
* (mp (eval-nth 2 '(a b c d)))

(IF (EQUAL 2 0)
    '(A B C D)
    (EVAL-NTH (- 2 1) (CDR ('(A B C D)))))
T
* (eval-nth 2 1 2 3 4 5)
my plus called 
; in: EVAL-NTH 2
;     ((CDR ('(1 2 3 4 5))))
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((CDR ('(1 2 3 4 5))))
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] (eval-nth 2 1 2 3 4 5)
my plus called 
; in: LAMBDA (#:G2302)
;     1
; 
; caught ERROR:
;   illegal function call

;     (EVAL-NTH 2 1 2 3 4 5)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR (1 2 3 4 5)))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (1 2 3 4 5)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus   ^C ^Ccalled 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH 
; --> my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
IF EVAL-NTH IF EVAL-NTH IF EVAL-NTH IF CDR 
; ==>
;   ((CDR ((CDR (#)))))
; 
; caught ERROR:
;   illegal function call

my plus called 
my ; --> IF my plus called 


debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT:
  Interactive interrupt at #x9C520066.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE    ] Return from SB-UNIX:SIGINT.
  1: [SIGNAL-ERROR] SB-C::SIGNAL-ERROR
  2: [ABORT       ] Reduce debugger level (to debug level 1).
  3:                Exit debugger, returning to top level.

("bogus stack frame")
0[2] break
; No debug variables for current frame: using EVAL instead of EVAL-IN-FRAME.

debugger invoked on a UNBOUND-VARIABLE: The variable BREAK is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT       ] Reduce debugger level (to debug level 2).
  1: [CONTINUE    ] Return from SB-UNIX:SIGINT.
  2: [SIGNAL-ERROR] SB-C::SIGNAL-ERROR
  3:                Reduce debugger level (to debug level 1).
  4:                Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV BREAK #<NULL-LEXENV>)
0[3] abort

0[2] abort
; 
     ; compilation unit aborted
     ;   caught 1 fatal ERROR condition
     ;   caught 46 ERROR conditions

0] abort
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO EVAL-NTH-ITE
;     (DEFMACRO EVAL-NTH-ITE (N &REST ARGS)
;       (LET ((IDX (GENSYM)) (LIMIT (GENSYM)) (RET (GENSYM)))
;         `(PROGN
;           (DO (#
;                #
;                #)
;               (#)
;            T)
;           (CAR ,RET))))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((N (CAR (CDR #:WHOLE2389))) (ARGS (CDR (CDR #:WHOLE2389))))
;     (BLOCK EVAL-NTH-ITE
;       (LET ((IDX #) (LIMIT #) (RET #))
;         `(PROGN (DO # # T) (CAR ,RET)))))
; 
; caught STYLE-WARNING:
;   The variable ARGS is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (defun my-fun(x y) (format t "my-fun x:~a, y:~a ~%" x y))
STYLE-WARNING: redefining COMMON-LISP-USER::MY-FUN in DEFUN

MY-FUN
*(mp (override-fun my-fun super (format t "overrider called") (funcall super)))
my plus called 
; in: OVERRIDE-FUN MY-FUN
;     ((FORMAT T "overrider called") (FUNCALL SUPER))
; 
; caught ERROR:
;   illegal function call

;     (LET ((SUPER #'(LAMBDA () (APPLY #:G2577 ARGS))))
;       (PROGN @ ((FORMAT T "overrider called") (FUNCALL SUPER))))
; 
; caught STYLE-WARNING:
;   The variable SUPER is defined but never used.

my plus called 
; in: OVERRIDE-FUN MY-FUN
;     (PROGN @ ((FORMAT T "overrider called") (FUNCALL SUPER)))
; 
; caught WARNING:
;   undefined variable: @
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     @
;   caught 1 ERROR condition
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
#<FUNCTION (LAMBDA (&REST ARGS)) {136CD9A5}>
* (mp (override-fun my-fun super (format t "overrider called") (funcall super)))

(LET ((#:G2578 (SYMBOL-FUNCTION 'MY-FUN)))
  (SETF (SYMBOL-FUNCTION 'MY-FUN)
          #'(LAMBDA (&REST ARGS)
              (LET ((SUPER #'(LAMBDA () (APPLY #:G2578 ARGS))))
                (PROGN @ ((FORMAT T "overrider called") (FUNCALL SUPER)))))))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (override-fun my-fun super (format t "overrider called") (funcall super))

(LET ((#:G2673 (SYMBOL-FUNCTION 'MY-FUN)))
  (SETF (SYMBOL-FUNCTION 'MY-FUN)
          #'(LAMBDA (&REST ARGS)
              (LET ((SUPER #'(LAMBDA () (APPLY #:G2673 ARGS))))
                (PROGN (FORMAT T "overrider called") (FUNCALL SUPER))))))
T
* (override-fun my-fun super (format t "overrider called") (funcall super))

#<CLOSURE (LAMBDA (&REST ARGS)) {127A094D}>
* (my-fun 10 20)
overrider called
debugger invoked on a UNBOUND-VARIABLE: The variable @ is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (&REST ARGS)))
0] abort

* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO CALL-FUN
;     (DEFMACRO CALL-FUN (FN &REST ARGS) `(FUNCALL FN ,@ARGS))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((FN (CAR (CDR #:WHOLE2761))) (ARGS (CDR (CDR #:WHOLE2761))))
;     (BLOCK CALL-FUN `(FUNCALL FN ,@ARGS)))
; 
; caught STYLE-WARNING:
;   The variable FN is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
*(load "second.lisp") (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
*(mp (override-fun my-fun super (format t "overrider called") (funcall super)))

#<CLOSURE (LAMBDA (&REST ARGS)) {12374B1D}>
* (my-fun 20 30)
overrider calledoverrider called
debugger invoked on a UNBOUND-VARIABLE: The variable @ is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (&REST ARGS)))
0] help

The debug prompt is square brackets, with number(s) indicating the current
  control stack level and, if you've entered the debugger recursively, how
  deeply recursed you are.
Any command -- including the name of a restart -- may be uniquely abbreviated.
The debugger rebinds various special variables for controlling i/o, sometimes
  to defaults (much like WITH-STANDARD-IO-SYNTAX does) and sometimes to
  its own special values, based on SB-EXT:*DEBUG-PRINT-VARIABLE-ALIST*.
Debug commands do not affect *, //, and similar variables, but evaluation in
  the debug loop does affect these variables.
SB-DEBUG:*FLUSH-DEBUG-ERRORS* controls whether errors at the debug prompt
  drop you deeper into the debugger. The default NIL allows recursive entry
  to debugger.

Getting in and out of the debugger:
  TOPLEVEL, TOP  exits debugger and returns to top level REPL
  RESTART        invokes restart numbered as shown (prompt if not given).
  ERROR          prints the error condition and restart cases.

  The number of any restart, or its name, or a unique abbreviation for its
   name, is a valid command, and is the same as using RESTART to invoke
   that restart.

Changing frames:
  UP     up frame         DOWN     down frame
  BOTTOM bottom frame     FRAME n  frame n (n=0 for top frame)

Inspecting frames:
  BACKTRACE [n]  shows n frames going down the stack.
  LIST-LOCALS, L lists locals in current frame.
  PRINT, P       displays function call for current frame.
  SOURCE [n]     displays frame's source form with n levels of enclosing forms.

Stepping:
  START Selects the CONTINUE restart if one exists and starts
        single-stepping. Single stepping affects only code compiled with
        under high DEBUG optimization quality. See User Manual for details.
  STEP  Steps into the current form.
  NEXT  Steps over the current form.
  OUT   Stops stepping temporarily, but resumes it when the topmost frame that
        was stepped into returns.
  STOP  Stops single-stepping.

Function and macro commands:
 (SB-DEBUG:ARG n)
    Return the n'th argument in the current frame.
 (SB-DEBUG:VAR string-or-symbol [id])
    Returns the value of the specified variable in the current frame.

Other commands:
  RETURN expr
    Return the values resulting from evaluation of expr from the
    current frame, if this frame was compiled with a sufficiently high
    DEBUG optimization quality.

  RESTART-FRAME
    Restart execution of the current frame, if this frame is for a
    global function which was compiled with a sufficiently high
    DEBUG optimization quality.

  SLURP
    Discard all pending input on *STANDARD-INPUT*. (This can be
    useful when the debugger was invoked to handle an error in
    deeply nested input syntax, and now the reader is confused.)

(The HELP string is stored in *DEBUG-HELP-STRING*.)

0] abort

* (mp (override-fun my-fun super (format t "overrider called") (funcall super)))

(LET ((#:G2872 (SYMBOL-FUNCTION 'MY-FUN)))
  (SETF (SYMBOL-FUNCTION 'MY-FUN)
          #'(LAMBDA (&REST ARGS)
              (LET ((SUPER #'(LAMBDA () (CALL-FUN #:G2872 ARGS))))
                (PROGN (FORMAT T "overrider called") (FUNCALL SUPER))))))
T
* (call-fun #'+ 1 2 3)
my plus called 
6
* (call-fun (symbol-function '+) 1 2 3)
my plus called 
6
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition


; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO WRAP-FUN
;     `(FUNCALL ,FUN ,@ARGS)
; 
; caught WARNING:
;   undefined variable: ARGS
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     ARGS
;   caught 1 WARNING condition
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* ((wrap-fun #'+) 1 2)
my plus called 
; in: (WRAP-FUN #'+) 1
;     ((WRAP-FUN #'+) 1 2)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((WRAP-FUN #'+) 1 2)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (funcall (wrap-fun #'+) 1 2)
my plus called 
3
* (funcall (wrap-fun #'+) 1 2 3 4)
my plus called 
10
*(load "second.lisp") (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (funcall (wrap-fun #'+) 1 2 3 4)
my plus called 
10
* (defun test-fun(x y z) (format t "~a ~a ~a ~%" x y z))

TEST-FUN
* (mp (override-fun test-fun super (funcall super)))

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  invalid number of arguments: 1

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(TEST-FUN (1 2 3))[:EXTERNAL]
0] (mp (override-fun test-fun super (funcall super)))

(LET ((#:G3181 (SYMBOL-FUNCTION 'TEST-FUN)))
  (SETF (SYMBOL-FUNCTION 'TEST-FUN)
          #'(LAMBDA (&REST ARGS)
              (LET (#)
                (PROGN #)))))
T
0] abort

* (mp (override-fun test-fun super (funcall super)))

(LET ((#:G3182 (SYMBOL-FUNCTION 'TEST-FUN)))
  (SETF (SYMBOL-FUNCTION 'TEST-FUN)
          #'(LAMBDA (&REST ARGS)
              (LET ((SUPER #'(LAMBDA () (CALL-FUN #:G3182 ARGS))))
                (PROGN (FUNCALL SUPER))))))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (funcall (override-fun test-fun super (funcall super)) 1 2 3)

(LET ((#:G3285 (SYMBOL-FUNCTION 'TEST-FUN)))
  (SETF (SYMBOL-FUNCTION 'TEST-FUN)
          #'(LAMBDA (&REST ARGS)
              (LET ((SUPER #'(LAMBDA () (APPLY #:G3285 ARGS))))
                (PROGN (FUNCALL SUPER))))))
T
* 3

3
* (defun test-fun(x y z) (format t "testfun x:~a, y:~a, z:~a" x y z))
STYLE-WARNING: redefining COMMON-LISP-USER::TEST-FUN in DEFUN

TEST-FUN
* (funcall (override-fun test-fun super (funcall super)) 1 2 3)
testfun x:1, y:2, z:3
NIL
* (eval-nth-ite 2 1 2 3 4)
my plus called 
; in: EVAL-NTH-ITE 2
;     (1 2 3 4)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (1 2 3 4)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (my-for x 0 10 (format t "x:~a ~%" x))
x:0 
x:1 
x:2 
x:3 
x:4 
x:5 
x:6 
x:7 
x:8 
x:9 
NIL
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO EVAL-NTH-ITE
;     #'(LAMBDA (ELM) (INCF IDX) `(,(- IDX 1) ELM))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (funcall #'(lambda (x) (format t "x:~a" x)) 1)
my plus called 
; in: #'(LAMBDA (X) (FORMAT T "x:~a" X)) 1
;     (#'(LAMBDA (X) (FORMAT T "x:~a" X)) 1)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (#'(LAMBDA (X) (FORMAT T x:~a X)) 1)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] break

my plus called 
; in: LAMBDA (#:G3396)
;     (SYMBOL-MACROLET ()
;       BREAK)
; 
; caught WARNING:
;   undefined variable: BREAK
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     BREAK
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable BREAK is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G3396)) #<unavailable argument>)
0[2] abort

0] abort
* funcall 

debugger invoked on a UNBOUND-VARIABLE: The variable FUNCALL is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV FUNCALL #<NULL-LEXENV>)
0] abort

* (funcall #'(lambda (x) (format t "x:~a" x)) 1)
x:1
NIL
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (mp (eval-nth-ite 4 1 2 3 4))

(CASE 4 (0 1) (1 2) (2 3) (3 4))
T
* (eval-nth-ite 2 0 1 2 3 4)

2
* (eval-nth-ite 2 (format t "e 1") (format t "e 2") (format t "e 3") (format t "e 4"))
e 3
NIL
* (mp (with-open-file s "dump" :output t))

debugger invoked on a SB-KERNEL::DEFMACRO-BOGUS-SUBLIST-ERROR:
  error while parsing arguments to DEFMACRO WITH-OPEN-FILE:
    bogus sublist
      S
    to satisfy lambda-list
      (STREAM SB-IMPL::FILESPEC &REST SB-IMPL::OPTIONS)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (#:WHOLE269712 #:ENVIRONMENT269713)
   :IN
   "/Users/jwise/proj/sbcl/clean/1.0.55/sbcl-1.0.55-x86-darwin/src/cold/compile-cold-sbcl.lisp")
 (WITH-OPEN-FILE S "dump" :OUTPUT T)
 #<unavailable argument>)
0] abort

* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (mp (nthe 10 '(1 2 3 4)))

(LABELS ((NTH-IN (POS LSTS)
           (IF (= POS 0)
               (CAR LSTS)
               (NTH-IN (- POS 1) (CDR LSTS)))))
  (NTH-IN 10 '(1 2 3 4)))
T
* (nthe 3 '(1 2 3 4 5 6))

4
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (mp (orexp (- 10 10) (- 20 20) (+ 1 4) (+ 1 5)))

(LET ((#:G3716 (CAR ARGS)))
  (IF #:G3716
      #:G3716
      (OREXP (- 20 20) (+ 1 4) (+ 1 5))))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (orexp (- 10 10) (- 20 20) (+ 1 4) (+ 1 5))

(LET ((#:G3826 (- 10 10)))
  (IF #:G3826
      #:G3826
      (OREXP (- 20 20) (+ 1 4) (+ 1 5))))
T
* (orexp (- 10 10) (- 20 20) (+ 1 4) (+ 1 5))

0
* (orexp (format t "1") (format t "2") t (format t "3"))
12
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (mp (our-let ((x 1) (y 2) (c)) (format t "x:~a, y:~a, c:~a" x y c)))

(FUNCALL #'(LAMBDA X Y C (FORMAT T "x:~a, y:~a, c:~a" X Y C)) (1) (2) NIL)
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (mp (our-let ((x 1) (y 2) (c)) (format t "x:~a, y:~a, c:~a" x y c)))

(FUNCALL #'(LAMBDA (X Y C) (FORMAT T "x:~a, y:~a, c:~a" X Y C)) (1) (2) NIL)
T
* (load "second.lisp"
)

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (our-let ((x 1) (y 2) (c)) (format t "x:~a, y:~a, c:~a" x y c))

(FUNCALL #'(LAMBDA (X Y C) (FORMAT T "x:~a, y:~a, c:~a" X Y C)) 1 2 NIL)
T
* (our-let ((x 1) (y 2) (c)) (format t "x:~a, y:~a, c:~a" x y c))
x:1, y:2, c:NIL
NIL
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (real-let (((x 1) (y 2) (z 3)) (format t "x:~a, y:~a, z:~a" x y z)))

(FUNCALL #'(LAMBDA (X Y Z) FORMAT T "x:~a, y:~a, z:~a" X Y Z) 1 2 3)
T
* (real-let (((x 1) (y 2) (z 3)) (format t "x:~a, y:~a, z:~a" x y z)))

my plus called 
; in: REAL-LET (((X 1) (Y 2) (Z 3)) (FORMAT T "x:~a, y:~a, z:~a" X Y Z))
;     #'(LAMBDA (X Y Z) FORMAT T "x:~a, y:~a, z:~a" X Y Z)
; 
; caught WARNING:
;   undefined variable: FORMAT
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FORMAT
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable FORMAT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (X Y Z)) #<unavailable argument> #<unavailable argument> 3)
0] abort
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (real-let (((x 1) (y 2) (z 3)) (format t "x:~a, y:~a, z:~a" x y z)))
x:1, y:2, z:3
NIL
* (mp (with-open-file (s "dump" :direction :output) (princ 99 s)))

99
* (mp (with-open-file (s "dump" :direction :output) (princ 99 s)))

(WITH-OPEN-STREAM (S (OPEN "dump" :DIRECTION :OUTPUT)) (PRINC 99 S))
T
* (mp (WITH-OPEN-STREAM (S (OPEN "dump" :DIRECTION :OUTPUT)) (PRINC 99 S)))

(LET ((S (OPEN "dump" :DIRECTION :OUTPUT)) (#:G4403 T))
  (UNWIND-PROTECT
      (MULTIPLE-VALUE-PROG1 (PROGN (PRINC 99 S)) (SETQ #:G4403 NIL))
    (WHEN S (CLOSE S :ABORT #:G4403))))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition


; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO CONDLET
;     (CONDLET-CLAUSE VARS CL BODFN)
; 
; caught STYLE-WARNING:
;   undefined function: CONDLET-CLAUSE

;     (MAPPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPPEND
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     CONDLET-CLAUSE MAPPEND
;   caught 2 STYLE-WARNING conditions

my plus called 
; in: DEFUN CONDLET-CLAUSE
;     (CONDLET-BINDS VARS CL)
; 
; caught STYLE-WARNING:
;   undefined function: CONDLET-BINDS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     CONDLET-BINDS
;   caught 1 STYLE-WARNING condition

debugger invoked on a SIMPLE-ERROR: &REST after &KEY in DEFMACRO

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [RETRY   ] Retry EVAL of current toplevel form.
  1: [CONTINUE] Ignore error and continue loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  2: [ABORT   ] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  3:            Exit debugger, returning to top level.

(SB-KERNEL::PARSE-DEFMACRO-LAMBDA-LIST
 (EXPR &KEY (TEST EQUAL) &REST ARGS)
 #:WHOLE4525
 ORQUEL
 DEFMACRO
 :ERROR-FUN
 ERROR
 :ANONYMOUSP
 NIL
 :ENV-ILLEGAL
 NIL
 :SUBLIST
 NIL)
0] abort
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPPEND
;   caught 1 STYLE-WARNING condition
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition
T
* (mp (orquel (+ 1 2) (+ 4 5) (+ 5 6) (+ 8 7)))

(ORQUAL (+ 1 2) (+ 4 5) (+ 5 6) (+ 8 7))
NIL
* orque

debugger invoked on a UNBOUND-VARIABLE: The variable ORQUE is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV ORQUE #<NULL-LEXENV>)
0] abort

* (mp (orquel (+ 1 2) (+ 4 5) (+ 5 6) (+ 8 7)))

(LET ((#:G4780 (+ 1 2)))
  (OR (EQUAL #:G4780 (+ 4 5)) (EQUAL #:G4780 (+ 5 6)) (EQUAL #:G4780 (+ 8 7))))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught STYLE-WARNING:
;   undefined function: >CASEX
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     >CASEX
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 502, Column: 31, File-Position: 14311

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {1354D6A1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {1354D6A1}>
 14170)
0] abort
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught STYLE-WARNING:
;   undefined function: >CASEX
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     >CASEX
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N

;     `(LAMBDA ,PRAMS ,@BODY)
; 
; caught WARNING:
;   undefined variable: PRAMS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   Undefined variable:
my plus called 
;     PRAMS
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
T
* (mp (do-tuples/o (x y z) '(1 2 3 4 5 6 7) (princ (list x y z)))) 

debugger invoked on a UNBOUND-VARIABLE: The variable PRAMS is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((DEFMACRO DO-TUPLES/O)
 (DO-TUPLES/O (X Y Z)
     '(1 2 3 4 5 6 7)
   (PRINC (LIST X Y Z)))
 #<unavailable argument>)
0] abort

* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   caught 1 STYLE-WARNING condition
T
* (mp (do-tuples/o (x y z) '(1 2 3 4 5 6 7) (princ (list x y z)))) 

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::MAP0-N is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] (mp (do-tuples/o (x y z) '(1 2 3 4 5 6 7) (princ (list x y z))))
; No debug variables for current frame: using EVAL instead of EVAL-IN-FRAME.

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::MAP0-N is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

("undefined function")
0[2] abort

0] abort

* (prog ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) 1)
x:1, y:2 
NIL
* (prog ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) (format t "end"))
x:1, y:2 
NIL
* (prog ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) (format t "end") x)
x:1, y:2 
end
NIL
* t

T
* x

12
* (prog ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) (format t "end") t)
x:1, y:2 
end
NIL
* (prog ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) (format t "end") (return-from nil 1))
x:1, y:2 
end
NIL
* (let ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) (format t "end ~%") t)
x:1, y:2 
T
* (let ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) (format t "end ~%") t)
x:1, y:2 
end 
T
* (prog ((x 1) (y 2)) (format t "x:~a, y:~a ~%" x y) (format t "end") (return-from nil 1))
x:1, y:2 
end
1
* (mapc #'(lambda (x) (format t "x:~a ~%" x)) '(1 2 3 4))
x:1 
x:2 
x:3 
x:4 
(1 2 3 4)
* (mp (define-modify-macro toggle2() not))

(DEFMACRO TOGGLE2 (#:PLACE &ENVIRONMENT #:ENV)
  NIL
  (MULTIPLE-VALUE-BIND
      (SB-IMPL::DUMMIES SB-IMPL::VALS SB-IMPL::NEWVAL SB-IMPL::SETTER
       SB-IMPL::GETTER)
      (GET-SETF-EXPANSION #:PLACE #:ENV)
    (LET ()
      `(LET* ((SB-IMPL::BACKQ-COMMA-AT
               (MAPCAR #'LIST SB-IMPL::DUMMIES SB-IMPL::VALS))
              (,(CAR SB-IMPL::NEWVAL) ,(LIST 'NOT SB-IMPL::GETTER))
              (SB-IMPL::BACKQ-COMMA-AT (CDR SB-IMPL::NEWVAL)))
         ,SB-IMPL::SETTER))))
T
* (mp (toggle2 ((cadr '(1 2 3 4)))))

(TOGGLE2 ((CADR '(1 2 3 4))))
NIL
* (define-modify-macro toggle2() not)

TOGGLE2
* (mp (toggle2 (cadr '(1 2 3 4))))

(LET* ((#:NEW5207 (NOT ((CADR '(1 2 3 4))))))
  (FUNCALL #'(SETF (CADR '(1 2 3 4))) #:NEW5207))
T
* (toggle2 ((cadr '(1 2 3 4))))
my plus called 
; in: TOGGLE2 ((CADR '(1 2 3 4)))
;     (FUNCALL #'(SETF (CADR '(1 2 3 4))) #:NEW5208)
; ==>
;   (SB-C::%FUNCALL #'(SETF (CADR '(1 2 3 4))) #:NEW5208)
; 
; caught ERROR:
;   (SETF (CADR '(1 2 3 4))) is not a legal function name.

;     ((CADR '(1 2 3 4)))
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 2 ERROR conditions

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((CADR '(1 2 3 4)))
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (setf *tiange* '(1 2 3))

(1 2 3)
* (setf (cadr *tiange*) 5)

my plus called 
; in: SETF (CADR *TIANGE)
;     (LET* ((#:G5209 *TIANGE))
;       (MULTIPLE-VALUE-BIND (#:G5210) 5 (SB-KERNEL:%RPLACA (CDR #:G5209) #:G5210)))
; 
; caught WARNING:
;   undefined variable: *TIANGE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *TIANGE
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable *TIANGE is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (setf (cadr *tiange*) 5)

5
* *tiange*

(1 5 3)
* (mp (toggle2 (cadr '(1 2 3 4))))

(LET* ((#:G5213 (NOT (CADR '(1 2 3 4)))))
  (SB-KERNEL:%RPLACA (CDR '(1 2 3 4)) #:G5213))
T
* (toggle2 (cadr '(1 2 3)))
my plus called 
; in: TOGGLE2 (CADR '(1 2 3))
;     (SB-KERNEL:%RPLACA (CDR '(1 2 3)) #:G5214)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%RPLACA called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
; 
; compilation unit finished
;   caught 1 WARNING condition
NIL
* (toggle2 (cadr *tiange*))

NIL
* *tiange*

(1 NIL 3)
* (mapcar #'list '(1 2 3) '(a b c) '(e f g) '(u v w z) '(k))

((1 A E) (2 B F) (3 C G))
* (mapcar #'list '(1 2 3) '(a b c) '(e f g) '(u v w z) '(k))

((1 A E U K))
* (let ((count (gensym))) (setq count 0) (incf count) (incf count) (format t "count:~a" count))
my plus called 
; in: LET ((COUNT (GENSYM)))
;     (INCF COUNT)
my plus called 
; --> LET* 
; ==>
;   (+ COUNT #:G1)
; 
; caught WARNING:
;   Derived type of COUNT is
;     (VALUES SYMBOL &OPTIONAL),
;   conflicting with its asserted type
;     NUMBER.
;   See also:
;     The SBCL Manual, Node "Handling of Types"
; 
; compilation unit finished
;   caught 1 WARNING condition

debugger invoked on a SIMPLE-TYPE-ERROR:
  Value of COUNT in (+ COUNT #:G1) is #:G5217, not a NUMBER.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-C::%COMPILE-TIME-TYPE-ERROR
 (#:G5217)
 NUMBER
 #<unavailable argument>
 ((+ COUNT #:G1) . COUNT))
0] (let ((count (gensym))) (setq count 0) (incf count) (incf count) (format t "count:~a" count))
my plus called 
my plus called 

NILcount:2
0] abort

* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition


; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   caught 1 STYLE-WARNING condition
T
* (mp (most-of 1 2 3 4 5))

(LET ((#:G5364 0))
  (OR (AND 1 (> (INCF #:G5364) 5/2)) (AND 2 (> (INCF #:G5364) 5/2))
      (AND 3 (> (INCF #:G5364) 5/2)) (AND 4 (> (INCF #:G5364) 5/2))
      (AND 5 (> (INCF #:G5364) 5/2))))
T
* (most-of (progn (format t "1") 1) (progn (format t "2") 2) (progn (format t "3") 3) (progn (format t "4") 4)) 

my plus called 
; in: MOST-F (PROGN (FORMAT T "1") 1)
;     (MOST-F (PROGN (FORMAT T "1") 1) (PROGN (FORMAT T "2") 2)
;      (PROGN (FORMAT T "3") 3) (PROGN (FORMAT T "4") 4))
; 
; caught STYLE-WARNING:
;   undefined function: MOST-F
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MOST-F
;   caught 1 STYLE-WARNING condition
1234
debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::MOST-F is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (most-of (progn (format t "1") 1) (progn (format t "2") 2) (progn (format t "3") 3) (progn (format t "4") 4))
my plus called 
my plus called 
my plus called 
123
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition


; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO NTH-MOST
;     (DEFMACRO NTH-MOST (N &REST ARGS))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((N (CAR (CDR #:WHOLE5510))) (ARGS (CDR (CDR #:WHOLE5510))))
;     (BLOCK NTH-MOST))
; 
; caught STYLE-WARNING:
;   The variable N is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ARGS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
T
* (setf *tiange* (genlist 3))

(NIL NIL NIL)
* (toplist *tiange* 10)

(10 NIL NIL)
* (toplist *tiange* 20)

(20 NIL NIL)
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO NTH-MOST
;     (DEFMACRO NTH-MOST (N &REST ARGS))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((N (CAR (CDR #:WHOLE5658))) (ARGS (CDR (CDR #:WHOLE5658))))
;     (BLOCK NTH-MOST))
; 
; caught STYLE-WARNING:
;   The variable N is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ARGS is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
T
* (toplist *tiange* 40)

(40 20 NIL)
* (toplist *tiange* 50)

(50 40 20)
* (toplist *tiange* 60)

(60 50 40)
* (toplist *tiange* 45)

(60 50 45)
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   caught 1 STYLE-WARNING condition
T
* (mp (with-gensym (key bar tool) (format "key:~a bar:~a tool:~a" key bar tool)))
my plus called 
; in: WITH-GENSYM (KEY BAR TOOL)
;     (LET (@ ((KEY (GENSYM)) (BAR (GENSYM)) (TOOL (GENSYM))))
;       @
;       ((FORMAT "key:~a bar:~a tool:~a" KEY BAR TOOL)))
; 
; caught ERROR:
;   The LET binding spec ((KEY (GENSYM)) (BAR (GENSYM)) (TOOL (GENSYM))) is malformed.
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (LET (@ ((KEY (GENSYM)) (BAR (GENSYM)) (TOOL (GENSYM))))
  @
  ((FORMAT key:~a bar:~a tool:~a KEY BAR TOOL)))
Compile-time error:
  The LET binding spec ((KEY (GENSYM)) (BAR (GENSYM)) (TOOL (GENSYM))) is malformed.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   caught 1 STYLE-WARNING condition
T
* (mp (with-gensym (key bar tool) (format "key:~a bar:~a tool:~a" key bar tool)))

(LET ((KEY (GENSYM)) (BAR (GENSYM)) (TOOL (GENSYM)))
  (FORMAT "key:~a bar:~a tool:~a" KEY BAR TOOL))
T
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DO-TUPLES/O
;     (MAP0-N #'(LAMBDA (N) `(NTHCDR ,N ,SRC)) (1- (LENGTH PARMS)))
; 
; caught STYLE-WARNING:
;   undefined function: MAP0-N
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAP0-N
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MAP0-N
;     (DO (IDX
;          0
;          (+ 1 IDX))
;         ((>= IDX N))
;       (CONS (FUNCALL FN IDX) LST))
; 
; caught ERROR:
;   during macroexpansion of
;   (DO (IDX
;        0
;        #)
;       (#) ...).
;   Use *BREAK-ON-SIGNALS* to intercept:
;   
;    0 is an illegal form for a DO varlist.

;     (DEFUN MAP0-N (FN N)
;       (LET ((LST NIL))
;         (PROGN
;          (DO (IDX
;               0
;               #)
;              (#)
;            (CONS # LST))
;          (NREVERSE LST))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MAP0-N
;         (FN N)
;       (BLOCK MAP0-N
;         (LET ((LST NIL))
;           (PROGN (DO # # #) (NREVERSE LST)))))
; 
; caught STYLE-WARNING:
;   The variable FN is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable N is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 2 STYLE-WARNING conditions
T
*(load "second.lisp") (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
T
* (map0-n #'(lambda (x) (format t "~a ~%" x)) 10)
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
NIL
* (dolist (elm '(1 2 3 4)) (format t "~a ~%" elm))
1 
2 
3 
4 
NIL
* (defconstant *segs* 20)
STYLE-WARNING: defining (*SEGS*) as a constant, even though the name follows
the usual naming convention (names like *FOO*) for special variables

*SEGS*
* *segs*

20
*(setf *segs* 50)
my plus called 
; in: SETF *SEGS*
;     (SETF *SEGS* 50)
; ==>
;   (SETQ *SEGS* 50)
; 
; caught ERROR:
;   *SEGS* is a constant and thus can't be set.
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (SETQ *SEGS* 50)
Compile-time error:
  *SEGS* is a constant and thus can't be set.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (defvar *myarray*)

*MYARRAY*
* (setq *myarray* (make-array (list 20 2)))

#2A((0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0)
    (0 0))
* (mp (awhen (forma t "true") (format t "result ~a" it)))

(AWHEN (FORMA T "true") (FORMAT T "result ~a" IT))
NIL
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO NTH-MOST
;     (TOPLIST)
; 
; caught STYLE-WARNING:
;   The function was called with zero arguments, but wants at least two.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
STYLE-WARNING: defining (*SEGS*) as a constant, even though the name follows
the usual naming convention (names like *FOO*) for special variables
STYLE-WARNING: defining (*DU*) as a constant, even though the name follows
the usual naming convention (names like *FOO*) for special variables
my plus called 
STYLE-WARNING: defining (*PTS*) as a constant, even though the name follows
the usual naming convention (names like *FOO*) for special variables

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 631, Column: 36, File-Position: 17849

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {13211B41}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {13211B41}>
 17849)
0] abort
T
* (load "third.lisp")
STYLE-WARNING: redefining COMMON-LISP-USER::LREC in DEFUN
STYLE-WARNING: redefining COMMON-LISP-USER::TREV in DEFUN
STYLE-WARNING: redefining COMMON-LISP-USER::TR-IF in DEFUN


; file: /Users/apple/work_foot/lisp_field/third.lisp
my plus called 
; in: DEFMACRO FN
;     (RBUILD EXPR)
; 
; caught STYLE-WARNING:
;   undefined function: RBUILD
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     RBUILD
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RBUILD
;     (BUILD-CALL (CAR EXPR) (CDR EXPR))
; 
; caught STYLE-WARNING:
;   undefined function: BUILD-CALL

;     (BUILD-COMPOSE (CDR EXPR))
; 
; caught STYLE-WARNING:
;   undefined function: BUILD-COMPOSE
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BUILD-CALL BUILD-COMPOSE
;   caught 2 STYLE-WARNING conditions

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 38, Column: 15, File-Position: 864

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/third.lisp"
                {1285A531}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/third.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/third.lisp"
   {1285A531}>
 799)
0] abort
T
*(load "third.lisp") (load "third.lisp")

;     (BUILD-CALL (CAR EXPR) (CDR EXPR))
; 
; caught STYLE-WARNING:
;   undefined function: BUILD-CALL

;     (BUILD-COMPOSE (CDR EXPR))
; 
; caught STYLE-WARNING:
;   undefined function: BUILD-COMPOSE
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BUILD-CALL BUILD-COMPOSE
;   caught 2 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/third.lisp
my plus called 
; in: DEFUN BUILD-COMPOSE
;     (DEFUN BUILD-COMPOSE (OP FNS)
;       (LET ((G (GENSYM)))
;         `(LAMBDA (,G)
;            ,(LABELS (#)
;               (REC FNS)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA BUILD-COMPOSE
;         (OP FNS)
;       (BLOCK BUILD-COMPOSE
;         (LET ((G #))
;           `(LAMBDA (,G)
;              ,(LABELS #
;                 #)))))
; 
; caught STYLE-WARNING:
;   (The function was previously called with one argument, but wants at least two.)
; 
; caught STYLE-WARNING:
;   The variable OP is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
T
* (load "third.lisp")

; file: /Users/apple/work_foot/lisp_field/third.lisp
my plus called 
; in: DEFUN RBUILD
;     (BUILD-COMPOSE (CDR EXPR))
; 
; caught STYLE-WARNING:
;   The function was called with one argument, but wants exactly two.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (load "third.lisp")

T
* (fn (compose list 1+ happy))

my plus called 
; in: FN (COMPOSE LIST 1+ HAPPY)
;     (FN (COMPOSE LIST 1+ HAPPY))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> FUNCTION LIST CONS 1+ + 
; ==>
;   (HAPPY #:G0)
; 
; caught STYLE-WARNING:
;   undefined function: HAPPY
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     HAPPY
;   caught 1 STYLE-WARNING condition
#<FUNCTION (LAMBDA (#:G0)) {12D098BD}>
* (mp (fn (compose list 1+ car)))

#'(LAMBDA (#:G6446) (LIST (1+ (CAR #:G6446))))
T
* (funcall (fn +) 1 2 3)
my plus called 
6
* (mp (fn +))

#'+
T
* (mp (fn + -))

debugger invoked on a SB-KERNEL::ARG-COUNT-ERROR:
  error while parsing arguments to DEFMACRO FN:
    invalid number of elements in
      (+ -)
    to satisfy lambda list
      (EXPR):
    exactly 1 expected, but 2 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((DEFMACRO FN) (FN + -) #<unavailable argument>)
0] abort.

my plus called 
; in: LAMBDA (#:G6447)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {12D20789}>
;                         #:G6447))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-1 0 {12D207E1}>
;                                             :FRAME #:G6447)))
;       ABORT.)
; 
; caught WARNING:
;   undefined variable: ABORT.
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     ABORT.
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable ABORT. is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G6447)) #<unavailable argument>)
0[2] abort

0] abort
* (mp (fn list -))

debugger invoked on a SB-KERNEL::ARG-COUNT-ERROR:
  error while parsing arguments to DEFMACRO FN:
    invalid number of elements in
      (LIST -)
    to satisfy lambda list
      (EXPR):
    exactly 1 expected, but 2 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((DEFMACRO FN) (FN LIST -) #<unavailable argument>)
0] abort

* (mp (fn (list -)))

#'(LAMBDA (#:G6448) (LIST (1 #:G6448)))
T
* (call (fn (list -)) 20 5)


#'(LAMBDA (#:G6449) (LIST (- #:G6449)))
T
* (funcall (fn (list -)) 20 5)

my plus called 
; in: CALL (FN (LIST -))
;     (CALL (FN (LIST -)) 20 5)
; 
; caught STYLE-WARNING:
;   undefined function: CALL
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     CALL
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::CALL is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] (funcall (fn (list -)) 20 5)
; No debug variables for current frame: using EVAL instead of EVAL-IN-FRAME.

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  invalid number of arguments: 2

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G0)) 20)[:EXTERNAL]
0[2] abort

0] abort
* (funcall (fn (list -)) 20 5)

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  invalid number of arguments: 2

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (#:G0)) 20)[:EXTERNAL]
0] abort

* (mp (fn (compose list list list)))

#'(LAMBDA (#:G6452) (LIST (LIST (LIST #:G6452))))
T
* (mp (fn (list list list +)))

#'(LAMBDA (#:G6453) (LIST (LIST #:G6453) (LIST #:G6453) (+ #:G6453)))
T
* (load "third.lisp")

T
* (mp (abbrev myplus +))

(DEFMACRO MYPLUS (&REST ARGS) `(+ ,@ARGS))
T
* (load "third.lisp")

; file: /Users/apple/work_foot/lisp_field/third.lisp
my plus called 
; in: DEFMACRO ABBREV
;     (DEFMACRO ABBREV (SHORT LONG)
;       `(DEFMACRO ,SHORT (&REST ARGS) ,'`(',LONG ,@ARGS)))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((SHORT (CAR (CDR #:WHOLE6466))) (LONG (CAR (CDR #))))
;     (BLOCK ABBREV `(DEFMACRO ,SHORT (&REST ARGS) ,'`(',LONG ,@ARGS))))
; 
; caught STYLE-WARNING:
;   The variable LONG is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (mp (abbrev myplus +))

(DEFMACRO MYPLUS (&REST ARGS) `(',LONG ,@ARGS))
T
* (group '(1 2 3 4 5 6) 2)

my plus called 
; in: GROUP '(1 2 3 4 5 6)
;     (GROUP '(1 2 3 4 5 6) 2)
; 
; caught STYLE-WARNING:
;   undefined function: GROUP
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     GROUP
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::GROUP is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (load "third.lisp")

T
* (group '(1  2 3 4 5) 2)

((1 2 3) (4 5))
* (load "third.lisp")

T
* (group '(1 2 3 4 5) 2)

((1 2) (3 4) (5))
* (load "third.lisp")

T
* (mp (abbrevs tian cool sky haha))

(PROGN (ABBREV TIAN COOL) (ABBREV SKY HAHA))
T
* (defun stupid-long-name(x y)
    (format t "stupid x:~a y:~a ~%" x y))

STUPID-LONG-NAME
* (defun another-stupid-long-name(x y)
    (format t "another stupid x:~a y:~a ~%" x y))

ANOTHER-STUPID-LONG-NAME
* (abbrevs stupid-long-name short1 another-stupid-long-name short2)
STYLE-WARNING:
   STUPID-LONG-NAME is being redefined as a macro when it was previously defined to be a function.
STYLE-WARNING: redefining COMMON-LISP-USER::STUPID-LONG-NAME in DEFMACRO
STYLE-WARNING:
   ANOTHER-STUPID-LONG-NAME is being redefined as a macro when it was previously defined to be a function.
STYLE-WARNING: redefining COMMON-LISP-USER::ANOTHER-STUPID-LONG-NAME in DEFMACRO

ANOTHER-STUPID-LONG-NAME
* (stupid-long-name 1 2)

my plus called 
; in: STUPID-LONG-NAME 1
;     (SHORT1 1 2)
; 
; caught STYLE-WARNING:
;   undefined function: SHORT1
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SHORT1
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::SHORT1 is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (load "second.lisp")

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFUN MY-FINDIF
;     #'(LAMBDA (ELM &OPTIONAL CURLST)
;         (LET ((RET (FUNCALL FN ELM)))
;           (VALUES (NOT RET) RET)))
; 
; caught STYLE-WARNING:
;   The variable CURLST is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
STYLE-WARNING: redefining COMMON-LISP-USER::LREC in DEFUN
STYLE-WARNING: redefining COMMON-LISP-USER::TREV in DEFUN
STYLE-WARNING: redefining COMMON-LISP-USER::TR-IF in DEFUN


; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO CONDLET
;     (MAPEND #'CDR CLAUSES)
; 
; caught STYLE-WARNING:
;   undefined function: MAPEND
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAPEND
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO >CASE
;     #'(LAMBDA (ELM) (>CASEX G CL))
; 
; caught STYLE-WARNING:
;   The variable ELM is defined but never used.

my plus called 
; in: DEFMACRO >CASE
;     (>CASEX G CL)
; 
; caught WARNING:
;   undefined variable: CL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/second.lisp
my plus called 
; in: DEFMACRO NTH-MOST
;     (TOPLIST)
; 
; caught STYLE-WARNING:
;   The function was called with zero arguments, but wants at least two.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
STYLE-WARNING: defining (*SEGS*) as a constant, even though the name follows
the usual naming convention (names like *FOO*) for special variables
STYLE-WARNING: defining (*DU*) as a constant, even though the name follows
the usual naming convention (names like *FOO*) for special variables
my plus called 
STYLE-WARNING: defining (*PTS*) as a constant, even though the name follows
the usual naming convention (names like *FOO*) for special variables

debugger invoked on a DEFCONSTANT-UNEQL:
  The constant *PTS* is being redefined (from
  #2A((0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      ...)
  to
  #2A((0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      (0 0)
      ...))
See also:
  The ANSI Standard, Macro DEFCONSTANT
  The SBCL Manual, Node "Idiosyncrasies"

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] Go ahead and change the value.
  1: [ABORT   ] Keep the old value.
  2: [RETRY   ] Retry EVAL of current toplevel form.
  3:            Ignore error and continue loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  4:            Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  5:            Exit debugger, returning to top level.

(SB-C::%DEFCONSTANT
 *PTS*
 #2A((0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     (0 0)
     ...)
 NIL
 #S(SB-C:DEFINITION-SOURCE-LOCATION
    :NAMESTRING "/Users/apple/work_foot/lisp_field/second.lisp"
    :TOPLEVEL-FORM-NUMBER NIL
    :PLIST NIL))
0] abort

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 631, Column: 36, File-Position: 17849

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/second.lisp"
                {135FE9D9}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/second.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/second.lisp"
   {135FE9D9}>
 17849)
0] abort
T
* (load "third.lisp")
STYLE-WARNING: redefining COMMON-LISP-USER::LREC in DEFUN
STYLE-WARNING: redefining COMMON-LISP-USER::TREV in DEFUN
STYLE-WARNING: redefining COMMON-LISP-USER::TR-IF in DEFUN

T
* (mp (propmacro coolguy))

(DEFMACRO COOLGUY (OBJ) `(GET ,OBJ 'COOLGUY))
T
* (load "third.lisp")

; file: /Users/apple/work_foot/lisp_field/third.lisp
my plus called 
; in: DEFMACRO A+
;     (DEFMACRO A+ (FN &REST EXPRS)
;       `(LET ((IT NIL))
;          (FN ,@(MAPCAR #'(LAMBDA # `#) EXPRS))))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((FN (CAR (CDR #:WHOLE6692))) (EXPRS (CDR (CDR #:WHOLE6692))))
;     (BLOCK A+
;       `(LET ((IT NIL))
;          (FN ,@(MAPCAR #'# EXPRS)))))
; 
; caught STYLE-WARNING:
;   The variable FN is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (load "third.lisp")

T
* (a+ and 20 (progn (format t "previous ~a ~%" it) 50) (progn (format t "second prev ~a ~%" it) 70))
previous 20 
second prev 50 
70
* (a+ + 10 (* it 0.5) (* it 0.15))
my plus called 
my plus called 
15.75
* (load "third.lisp")

T
* (mp (ap-gen ap+ +))

(DEFMACRO AP+ (&REST EXPRS)
  `(LET ((IT NIL))
     (+ ,@(MAPCAR #'(LAMBDA (EXPR) `(SETF IT ,EXPR)) EXPRS))))
T
* (ap-gen ap+ +)

AP+
* (ap+ 10 (* it 5) (* it 2))
my plus called 
my plus called 
160
* (pop-symbol 'haha)

my plus called 
; in: POP-SYMBOL 'HAHA
;     (POP-SYMBOL 'HAHA)
; 
; caught STYLE-WARNING:
;   undefined function: POP-SYMBOL
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     POP-SYMBOL
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::POP-SYMBOL is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (eql 'a 'a)

T
* (eq 'a 'a)

T
* (eql (car '(a b)) 'a)

T
* (defmacro quotize (s)
    `,s)
my plus called 
; in: DEFMACRO QUOTIZE
;     (LET* ((S (CAR (CDR #:WHOLE6747))))
;       (BLOCK QUOTIZE A))
; 
; caught STYLE-WARNING:
;   The variable S is defined but never used.

my plus called 
; in: DEFMACRO QUOTIZE
;     (BLOCK QUOTIZE A)
; 
; caught WARNING:
;   undefined variable: A
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     A
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
QUOTIZE
* (defmacro quotize (s)
    `',s)
STYLE-WARNING: redefining COMMON-LISP-USER::QUOTIZE in DEFMACRO

QUOTIZE
* (quotize baby)

debugger invoked on a UNBOUND-VARIABLE: The variable BABY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV (QUOTIZE BABY) #<NULL-LEXENV>)
0] abort

* (defmacro quotize (s)
    `',s)
STYLE-WARNING: redefining COMMON-LISP-USER::QUOTIZE in DEFMACRO

QUOTIZE
* (quotize baby)

BABY
* (eql 'baby (quotize baby))

T
* (load "third.lisp")

; file: /Users/apple/work_foot/lisp_field/third.lisp
my plus called 
; in: SET-DISPATCH-MACRO-CHARACTER #\#
;     #'(LAMBDA (STREAM CHAR1 CHAR2)
;         `#'(LAMBDA (&REST ,(GENSYM)) ,(READ STREAM T NIL T)))
; 
; caught STYLE-WARNING:
;   The variable CHAR1 is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable CHAR2 is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
T
* (mapcar #?2 '(a b c))
my plus called 
; in: MAPCAR #'(LAMBDA (&REST #:G6785) 2)
;     #'(LAMBDA (&REST #:G6785) 2)
; 
; caught STYLE-WARNING:
;   The variable #:G6785 is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
(2 2 2)
* (funcall #?3)
my plus called 
; in: FUNCALL #'(LAMBDA (&REST #:G6786) 3)
;     #'(LAMBDA (&REST #:G6786) 3)
; 
; caught STYLE-WARNING:
;   The variable #:G6786 is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
3
* #?4
my plus called 
; in: LAMBDA (&REST #:G6787)
;     #'(LAMBDA (&REST #:G6787) 4)
; 
; caught STYLE-WARNING:
;   The variable #:G6787 is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
#<FUNCTION (LAMBDA (&REST #:G6787)) {139472C5}>
* (defvar *my-visitor*)

*MY-VISITOR*
* (defstruct visitor name title firm)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
VISITOR
* (setq *my-visitor* (make-visitor :name "Tian" :title "Leader" :firm "EnjoyZhi"))

my plus called 
; in: SEQ *MY-VISITOR*
;     (SEQ *MY-VISITOR*
;      (MAKE-VISITOR :NAME "Tian" :TITLE "Leader" :FIRM "EnjoyZhi"))
; 
; caught STYLE-WARNING:
;   undefined function: SEQ
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SEQ
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable *MY-VISITOR* is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (setq *my-visitor* (make-visitor :name "Tian" :title "Leader" :firm "EnjoyZhi"))

#S(VISITOR :NAME "Tian" :TITLE "Leader" :FIRM "EnjoyZhi")
* (load "embeded.lisp")

T
* (let ((lst '(t nil t))
	(i -1))
    (toggle (nth (incf i) lst))
    lst)
my plus called 
; in: LET ((LST '(T NIL T)) (I -1))
;     (TOGGLE (NTH (INCF I) LST))
my plus called 
; --> LET* 
; ==>
;   (SB-KERNEL:%SETNTH #:G4 #:LST1 #:NEW0)
; 
; caught WARNING:
;   Destructive function SB-KERNEL:%SETNTH called on constant data.
;   See also:
;     The ANSI Standard, Special Operator QUOTE
;     The ANSI Standard, Section 3.2.2.3
my plus called 
; 
; compilation unit finished
;   caught 1 WARNING condition
(NIL NIL T)
* (load "embeded.lisp")
STYLE-WARNING: redefining COMMON-LISP-USER::WITH-GENSYMS in DEFMACRO

T
* (mp (with-gensyms (xie tian good) (format t "~a ~a ~a ~%" xie tian good)))

(LET ((XIE (GENSYM)) (TIAN (GENSYM)) (GOOD (GENSYM)))
  (FORMAT T "~a ~a ~a ~%" XIE TIAN GOOD))
T
* (load "embeded.lisp")

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO NILF
;     (DEFMACRO NILF (&REST ARGS) '(ALLF NIL ARGS))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((ARGS (CDR #:WHOLE6816)))
;     (BLOCK NILF '(ALLF NIL ARGS)))
; 
; caught STYLE-WARNING:
;   The variable ARGS is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO TF
;     (DEFMACRO TF (&REST ARGS) '(ALLF T ARGS))
my plus called 
my plus called 
my plus called 
; --> PROGN FUNCTION LET* 
; ==>
;   (LET* ((ARGS (CDR #:WHOLE6819)))
;     (BLOCK TF '(ALLF T ARGS)))
; 
; caught STYLE-WARNING:
;   The variable ARGS is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
STYLE-WARNING: redefining COMMON-LISP-USER::TOGGLE2 in DEFMACRO
T
* (load "embeded.lisp")

T
* (nilf x y z)

my plus called 
; in: NILF X
;     (SETF (X Y Z) #:G6850)
my plus called 
my plus called 
my plus called 
my plus called 
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL 
; ==>
;   (SB-C::%FUNCALL #'(SETF X) #:NEW0 #:Y2 #:Z1)
; 
; caught STYLE-WARNING:
;   undefined function: (SETF X)

; ==>
;   (LET* ((#:Y2 Y) (#:Z1 Z))
;     (MULTIPLE-VALUE-BIND (#:NEW0)
;         #:G6850
;       (FUNCALL #'(SETF X) #:NEW0 #:Y2 #:Z1)))
; 
; caught WARNING:
;   undefined variable: Y
; 
; caught WARNING:
;   undefined variable: Z
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     (SETF X)
;   Undefined variables:
my plus called 
my plus called 
;     Y Z
;   caught 2 WARNING conditions
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable Y is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (let ((x 1) (y 2) (z 3))
    (nilf x y z)
    (format t "x:~a y:~a z:~a ~%" x y z))

my plus called 
; in: LET ((X 1) (Y 2) (Z 3))
;     (NILF X Y Z)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> ALLF LET SETF LET* MULTIPLE-VALUE-BIND LET FUNCALL 
; ==>
;   (SB-C::%FUNCALL #'(SETF X) #:NEW1 #:Y3 #:Z2)
; 
; caught STYLE-WARNING:
;   undefined function: (SETF X)
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     (SETF X)
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function (COMMON-LISP:SETF COMMON-LISP-USER::X) is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (mp (allf 'come x y z))

(LET ((#:G6851 'COME))
  (SETF X #:G6851
        Y #:G6851
        Z #:G6851))
T
*(let ((x 1) (y 2)) ((x 1) (y 2))
my plus called 
; in: (X 1) (Y 2)
;     ((X 1) (Y 2))
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((X 1) (Y 2))
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (let ((x 1) (y 2)) (allf 'come x y) (format t "x:~a, y:~a ~%" x y))

COME
* (let ((x 1) (y 2)) (nilf x y) (format t "x:~a, y:~a ~%" x y))
x:COME, y:COME 
NIL
* (let ((x 1) (y 2)) (nilf x y) (format t "x:~a, y:~a ~%" x y))

my plus called 
; in: LET ((X 1) (Y 2))
;     (NILF X Y)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> ALLF LET SETF LET* MULTIPLE-VALUE-BIND LET FUNCALL 
; ==>
;   (SB-C::%FUNCALL #'(SETF X) #:NEW1 #:Y2)
; 
; caught STYLE-WARNING:
;   undefined function: (SETF X)
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     (SETF X)
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function (COMMON-LISP:SETF COMMON-LISP-USER::X) is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (load "embeded.lisp")

T
* (let ((x 1) (y 2)) (nilf x y) (format t "x:~a, y:~a ~%" x y))
x:NIL, y:NIL 
NIL
* (defvar *x*)

*X*
* (defvar *y*)

*Y*
* (setf *x* '(1 2))

(1 2)
* (setf *y* '(3 4))

(3 4)
* (nconc *x* *y*)

(1 2 3 4)
* *x*

(1 2 3 4)
* (mp (unless (> 1 2) (format t "absolutely right")))

(IF (> 1 2)
    NIL
    (PROGN (FORMAT T "absolutely right")))
T
* (get-setf-expansion (car *x*))

my plus called 
; in: GET-SETF-METHOD (CAR *X*)
;     (GET-SETF-METHOD (CAR *X*))
; 
; caught STYLE-WARNING:
;   undefined function: GET-SETF-METHOD
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     GET-SETF-METHOD
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::GET-SETF-METHOD is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* get-setf-expansion

debugger invoked on a UNBOUND-VARIABLE:
  The variable GET-SETF-EXPANSION is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV GET-SETF-EXPANSION #<NULL-LEXENV>)
0] abort

* (get-setf-expansion '(car *x*))

debugger invoked on a TYPE-ERROR: The value 1 is not of type LIST.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(GET-SETF-EXPANSION 1 NIL)
0] abort

* (get-setf-expansion '(car *x*))

(#:*X*6874)
(*X*)
(#:NEW6873)
(SB-KERNEL:%RPLACA #:*X*6874 #:NEW6873)
(CAR #:*X*6874)
* (load "embeded.lisp")

T
* (mp (_f * (car *x*) 20))

(LET* ((#:*X*6917 *X*) (#:NEW6916 (* (CAR #:*X*6917) 20)))
  (SB-KERNEL:%RPLACA #:*X*6917 #:NEW6916))
T
* (_f * (car *x*) 20)

20
* *x*

(20 2 3 4)
* (_f * (second *x*) 15)

30
* *x*

(20 30 3 4)
* (load "embeded.lisp")

T
* (_f * (second *x*) 15)
vars (G6963), forms (*X*), var (G6964), set (%RPLACA (CDR G6963) G6964), access (SECOND
                                                                                   G6963)
450
* (nthcdr 2 *x*)

(3 4)
* *x*

(20 450 3 4)
* (subseq *x* 0 2)

(20 450)
* (prog1 1 2)

1
* (mp (nthcdr 2 *x*))

(NTHCDR 2 *X*)
NIL
* (defvar *my-hash*) (defvar *my-hash*)

*MY-HASH*
* (setf *my-hash* (make-hash-table :size 100))

#<HASH-TABLE :TEST EQL :COUNT 0 {12ABCA79}>
* (set (gethash ,tian *my-hash*) nil)

debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  Comma not inside a backquote.

    File-Position: 177986

    Stream: #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}>
 "Comma not inside a backquote.")
0] abort

* 
debugger invoked on a UNBOUND-VARIABLE: The variable TIAN is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV TIAN #<NULL-LEXENV>)
0] abort

* 
#<HASH-TABLE :TEST EQL :COUNT 0 {12ABCA79}>
* 
debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  unmatched close parenthesis

    File-Position: 178300

    Stream: #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}>
 "unmatched close parenthesis")
0] abort

* 
NIL
* 
debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  unmatched close parenthesis

    File-Position: 178488

    Stream: #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}>
 "unmatched close parenthesis")
0] abort

* (setf (gethash 'tian *my-hash*) nil)

NIL
* (push 'cool (gethash 'tian *my-hash*))

(COOL)
* *(gethash 'tian *my-hash*)

(COOL)
* 
(COOL)
T
* (dolist (x *x*) (format t "x:~a ~%" x))
x:20 
x:450 
x:3 
x:4 
NIL
* (aif2 (3) (format t "~a ~%" it))
my plus called 
; in: AIF2 (3)
;     (3)
; 
; caught ERROR:
;   illegal function call

my plus called 
; in: AIF2 (3)
;     (AIF2 (3) (FORMAT T "~a ~%" IT))
; 
; caught STYLE-WARNING:
;   undefined function: AIF2

;     (FORMAT T "~a ~%" IT)
; 
; caught WARNING:
;   undefined variable: IT
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     AIF2
;   Undefined variable:
my plus called 
;     IT
;   caught 1 ERROR condition
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (3)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (defmacro exe2 (test first &optional second)
    `(if ,test ,first
	    ,second))

EXE2
* (mp (exe2 (format t "1")))

(PROGN (FORMAT T "1") NIL)
T
* (defmacro exe2 (test first &optional second)
    `(if ,test ,first
	    ,second))
STYLE-WARNING: redefining COMMON-LISP-USER::EXE2 in DEFMACRO

EXE2
* (exe2 t 2 3)

2
* (exe2 nil 2)

NIL
* (mp (destructuring-bind (x y z) '(1 2 3) (format t "x:~a y:~a z:~a ~%" x y z)))
x:1 y:2 z:3 
NIL
* (mp (destructuring-bind (x y z) '(1 2 3) (format t "x:~a y:~a z:~a ~%" x y z)))

(LET ((#:WHOLE6987 '(1 2 3)))
  (DECLARE (TYPE LIST #:WHOLE6987))
  (LET* ()
    (DECLARE (MUFFLE-CONDITIONS CODE-DELETION-NOTE))
    (LET ((#:ARGS6989 #:WHOLE6987))
      (UNLESS (SB-INT:PROPER-LIST-OF-LENGTH-P #:ARGS6989 3 3)
        (SB-KERNEL::ARG-COUNT-ERROR 'DESTRUCTURING-BIND 'NIL #:ARGS6989
                                    '(X Y Z) 3 3)))
    (LET* ((X (CAR #:WHOLE6987))
           (Y (CAR (CDR #:WHOLE6987)))
           (Z (CAR (CDR (CDR #:WHOLE6987)))))
      (FORMAT T "x:~a y:~a z:~a ~%" X Y Z))))
T
* #(1 2 3)

#(1 2 3)
* (aref #(1 2 3) 0)

1
* (mp (aref #(1 2 3) 0))

(AREF #(1 2 3) 0)
NIL
* (elt *x* 2)

3
* *x*

(20 450 3 4)
* (load "embeded.lisp")


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition
STYLE-WARNING:
   AIF2 is being redefined as a macro when it was previously assumed to be a function.

my plus called 
; in: DEFUN INTERPRET-QUERY
;     (INTERPRET-AND (REVERSE (CDR EXPR)) BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: INTERPRET-AND

;     (INTERPRET-NOT (CADR EXPR) BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: INTERPRET-NOT

;     (INTERPRET-OR (CDR EXPR) BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: INTERPRET-OR

;     (LOOKUP (CAR EXPR) (CDR EXPR) BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: LOOKUP
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
my plus called 
;     INTERPRET-AND INTERPRET-NOT INTERPRET-OR LOOKUP
;   caught 4 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DBIND
;     (DBIND-EX (DESTRUC PAT GSEQ #'ATOM) BODY)
; 
; caught STYLE-WARNING:
;   undefined function: DBIND-EX

;     (DESTRUC PAT GSEQ #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: DESTRUC
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     DBIND-EX DESTRUC
;   caught 2 STYLE-WARNING conditions

my plus called 
; in: DEFUN DESTRUC
;     (|1+N|)
; 
; caught STYLE-WARNING:
;   undefined function: |1+N|
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     |1+N|
;   caught 1 STYLE-WARNING condition
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN DESTRUC
;     (|1+N|)
; 
; caught STYLE-WARNING:
;   undefined function: |1+N|
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     |1+N|
;   caught 1 STYLE-WARNING condition
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN DESTRUC
;     (|1+N|)
; 
; caught STYLE-WARNING:
;   undefined function: |1+N|
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     |1+N|
;   caught 1 STYLE-WARNING condition
T
* (1+ 2)

3
* 


(load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition
T
*(mp (dbind (x (y . w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy"))) ((dbind (x (y . w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))

(LET ((#:G7286 '(1 "come on" 2 3 4 5)))
  (LET ((X (ELT #:G7286 0)) (#:G7287 (ELT #:G7286 1)) (G (SUBSEQ #:G7286 2)))
    (LET ((Y (ELT #:G7287 0)) (W (SUBSEQ #:G7287 1)))
      (PROGN (FORMAT T "cool guy")))))
T
* (dbind (x (y w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))
cool guy x:1 y:c w:ome on g:(2 3 4 5)
NIL
* (dbind (x (y &rest w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))
cool guy x:1 y:c w:o g:(2 3 4 5)
NIL
* (dbind (x (y &rest w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))
cool guy x:1 y:c w:ome on g:(2 3 4 5)
NIL
* (setq cool 2)

my plus called 
; in: SETQ COOL
;     (SETQ COOL 2)
; 
; caught WARNING:
;   undefined variable: COOL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COOL
;   caught 1 WARNING condition
2
* cool

2
* (load "embeded.lisp")


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 232, Column: 3, File-Position: 6369

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                {12C3F379}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {12C3F379}>
 5962)
0] abort
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 232, Column: 3, File-Position: 6369

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                {132BFEF9}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {132BFEF9}>
 5962)
0] abort
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
*(mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))
my plus called 
; in: WITH-ARRAY (X Y Z)
;     (LET ((X (AREF #:G7602 0)) (Y (AREF #:G7602 1)) (Z (AREF #:G7602 2)))
;       )
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Z is defined but never used.

my plus called 
; in: WITH-ARRAY (X Y Z)
;     (FORMAT T "x:~a y:~a z:~a" X Y Z)
; 
; caught WARNING:
;   undefined variable: X
; 
; caught WARNING:
;   undefined variable: Y
; 
; caught WARNING:
;   undefined variable: Z
; 
; compilation unit finished
;   Undefined variables:
my plus called 
my plus called 
my plus called 
;     X Y Z
;   caught 3 WARNING conditions
;   caught 3 STYLE-WARNING conditions

debugger invoked on a UNBOUND-VARIABLE: The variable Y is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))

(LET ((#:G7603 #(1 2 3 4 5)))
  (LET ((X (AREF #:G7603 0)) (Y (AREF #:G7603 1)) (Z (AREF #:G7603 2)))
    )
  (FORMAT T "x:~a y:~a z:~a" X Y Z))
T
* (load "embeded.lisp")


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 247, Column: 7, File-Position: 6729

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                {12CEA6B1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {12CEA6B1}>
 6380)
0] abort
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))

(LET ((#:G7764 #(1 2 3 4 5)))
  (LET ((FORMAT T "x:~a y:~a z:~a" X Y Z))
    ))
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))

(LET ((#:G7847 #(1 2 3 4 5)))
  (LET (PROGN (FORMAT T "x:~a y:~a z:~a" X Y Z))
    ))
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z))

(LET ((#:G7930 #(1 2 3 4 5)))
  (LET ((X (AREF #:G7930 0)) (Y (AREF #:G7930 1)) (Z (AREF #:G7930 2)))
    (FORMAT T "x:~a y:~a z:~a" X Y Z)))
T
* (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z))
x:1 y:2 z:3
NIL
* 
(elt *x* 2)

3
* (mp (elt *x* 2))

(ELT *X* 2)
NIL
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (with-array ((x 0) (y 3)) #(1 2 3 4 5) (format t "x:~a y:~a" x y))

debugger invoked on a TYPE-ERROR: The value (20 450 3 4) is not of type ARRAY.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort

* (with-array ((x 0) (y 3)) #(1 2 3 4 5) (format t "x:~a y:~a" x y))
x:1 y:4
NIL
* (mp (defstruct person name age status))

(DEF-STRUCT PERSON NAME AGE STATUS)
NIL
* (mp (def-structure person name age status))

(DEF-STRUCTURE PERSON NAME AGE STATUS)
NIL
* (mp (defstruct person name age status))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
(PROGN
 (SB-KERNEL:WITH-SINGLE-PACKAGE-LOCKED-ERROR (:SYMBOL 'PERSON
                                              "defining ~A as a structure"))
 (SB-KERNEL::%DEFSTRUCT '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION PERSON>
                        '#(#<SB-KERNEL:LAYOUT for T {100627C9}>
                           #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {10062801}>)
                        (SB-C:SOURCE-LOCATION))
 (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
   (SB-KERNEL::%COMPILER-DEFSTRUCT '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION PERSON>
                                   '#(#<SB-KERNEL:LAYOUT for T {100627C9}>
                                      #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT
                                        {10062801}>)))
 (DECLAIM
  (FTYPE (SB-INT:SFUNCTION (&KEY (:NAME T) (:AGE T) (:STATUS T)) PERSON)
   MAKE-PERSON))
 (DEFUN MAKE-PERSON
        (&KEY ((:NAME #:DUM8016) ()) ((:AGE #:DUM8017) ())
         ((:STATUS #:DUM8018) ()))
   (SB-KERNEL::%MAKE-STRUCTURE-INSTANCE-MACRO
    #<SB-KERNEL:DEFSTRUCT-DESCRIPTION PERSON>
    '((:SLOT T . 1) (:SLOT T . 2) (:SLOT T . 3)) #:DUM8016 #:DUM8017
    #:DUM8018))
 (LOCALLY
  (DECLARE (NOTINLINE SB-KERNEL:FIND-CLASSOID))
  (SETF (SB-KERNEL::STRUCTURE-CLASSOID-CONSTRUCTOR
         (SB-KERNEL:FIND-CLASSOID 'PERSON))
          #'MAKE-PERSON))
 'PERSON)
T
*(defvar *tiange*) (defvar *tiange*)

*TIANGE*
* (defstruct person name age status)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
PERSON
* (make-person :name "tian" :age 35  :status "happy")

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR: odd number of &KEY arguments

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAKE-PERSON "tian" 35 "happy")[:OPTIONAL]
0] abort

* (make-person :name "tian" :age 35  :status "happy")

#S(PERSON :NAME "tian" :AGE 35 :STATUS "happy")
* (setf *tiange* (make-person :name "tian" :age 35 :status "happy"))

#S(PERSON :NAME "tian" :AGE 35 :STATUS "happy")
* ((symb person name) *tiange*)
my plus called 
; in: (SYMB PERSON NAME) *TIANGE*
;     ((SYMB PERSON NAME) *TIANGE*)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((SYMB PERSON NAME) *TIANGE*)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* ((symb name name) *tiange*)
my plus called 
; in: (SYMB NAME NAME) *TIANGE*
;     ((SYMB NAME NAME) *TIANGE*)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((SYMB NAME NAME) *TIANGE*)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (mp ((symb name age) *tiange*))

((SYMB NAME AGE) *TIANGE*)
NIL
* (symb name age)

my plus called 
; in: SYMB NAME
;     (SYMB NAME AGE)
; 
; caught WARNING:
;   undefined variable: AGE
; 
; caught WARNING:
;   undefined variable: NAME
; 
; caught STYLE-WARNING:
;   undefined function: SYMB
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SYMB
;   Undefined variables:
my plus called 
my plus called 
;     AGE NAME
;   caught 2 WARNING conditions
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable NAME is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (symb person name)

debugger invoked on a UNBOUND-VARIABLE: The variable PERSON is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV PERSON #<NULL-LEXENV>)
0] abort

* (symb 'person name)

debugger invoked on a UNBOUND-VARIABLE: The variable NAME is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV NAME #<NULL-LEXENV>)
0] abort

* (symb 'person 'name)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::SYMB is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-FUNCTION SYMB)
0] abort

* (load "embeded.lisp")


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFMACRO WITH-STRUCT
;     (SYMB NAME F)
; 
; caught STYLE-WARNING:
;   undefined function: SYMB
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SYMB
;   caught 1 STYLE-WARNING condition
T
* (map '+ #'(lambda (c) (* 2 c)) '(1 2 3 4))

debugger invoked on a TYPE-ERROR:
  The value #<FUNCTION LIST> is not of type (OR CONS SYMBOL SB-KERNEL:INSTANCE).

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAP #<FUNCTION LIST> #<FUNCTION (LAMBDA #) {1245701D}> (1 2 3 4))[:OPTIONAL]
0] abort

* (map nil #'(lambda (c) (* 2 c)) '(1 2 3 4))

(2 4 6 8)
* '+

+
* (map '+ #'(lambda (c) (* 2 c)) '(1 2 3 4))

debugger invoked on a SIMPLE-TYPE-ERROR:
  + is a bad type specifier for sequences.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-KERNEL:%MAP + #<FUNCTION (LAMBDA #) {12495ECD}> (1 2 3 4))
0] abort

* (map nil #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4))

NIL
* (map 2 #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4))
1234
NIL
* (mp (map nil #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4)))

debugger invoked on a TYPE-ERROR:
  The value 2 is not of type (OR CONS SYMBOL SB-KERNEL:INSTANCE).

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAP 2 #<FUNCTION (LAMBDA #) {125263D5}> (1 2 3 4))[:OPTIONAL]
0] aort

my plus called 
; in: LAMBDA (#:G8119)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {124699D9}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {12469A31}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-2
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-2 0
;                            {12469A91}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-3
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-3 0
;                            {12469AB1}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-4
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-4 0
;                            {12469B21}>
;                         #:G8119)))
;       AORT)
; 
; caught WARNING:
;   undefined variable: AORT
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     AORT
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable AORT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G8119)) #<unavailable argument>)
0[2] abort

0] abort
* (mp (map nil #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4)))

(MAP NIL #'(LAMBDA (C) (FORMAT T "~a" C) (* 2 C)) '(1 2 3 4))
NIL
* (intern haha)

debugger invoked on a UNBOUND-VARIABLE: The variable HAHA is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV HAHA #<NULL-LEXENV>)
0] abort

* (intern "haha")

|haha|
NIL
* (values (intern "haha"))

|haha|
* (person-name *tiange*)

my plus called 
; in: PERSONNAME *TIANGE*
;     (PERSONNAME *TIANGE*)
; 
; caught STYLE-WARNING:
;   undefined function: PERSONNAME
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     PERSONNAME
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::PERSONNAME is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (person-name *tiange*)

"tian"
* (load "embeded.lisp")
STYLE-WARNING: redefining COMMON-LISP-USER::MKSTR in DEFUN
my plus called 


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (mp (with-struct (person- name age status) *tiange* (format t "~a age:~a status:~a ~%" name age status)))

(LET ((#:G8210 *TIANGE*))
  (LET ((NAME (PERSON-NAME #:G8210))
        (AGE (PERSON-AGE #:G8210))
        (STATUS (PERSON-STATUS #:G8210)))
    ))
T
* (with-struct (person- name age status) *tiange* (format t "~a age:~a status:~a ~%" name age status))

(LET ((#:G8211 *TIANGE*))
  (LET ((NAME (PERSON-NAME #:G8211))
        (AGE (PERSON-AGE #:G8211))
        (STATUS (PERSON-STATUS #:G8211)))
    (FORMAT T "~a age:~a status:~a ~%" NAME AGE STATUS)))
T
* (with-struct (person- name age status) *tiange* (format t "~a age:~a status:~a ~%" name age status))
tian age:35 status:happy 
NIL
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFMACRO WITH-PLACES
;     (DESTRUCT PAT GSEQ #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: DESTRUCT
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     DESTRUCT
;   caught 1 STYLE-WARNING condition
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* *x*

(20 450 3 4)
* (with-places (a b c d) *x* (setf a 50) (setf c 101) (format t "~a,~a,~a,~a ~%" a b c d))

(LET ((#:G8401 *X*))
  (SYMBOL-MACROLET ((A (ELT #:G8401 0))
                    (B (ELT #:G8401 1))
                    (#:G8402 (ELT #:G8401 2)))
    (SYMBOL-MACROLET ((C (ELT #:G8402 0)) (D (ELT #:G8402 1)))
      (PROGN (SETF A 50) (SETF C 101) (FORMAT T "~a,~a,~a,~a ~%" A B C D)))))
T
* (with-places (a b c d) *x* (setf a 50) (setf c 101) (format t "~a,~a,~a,~a ~%" a b c d))
50,450,101,4 
NIL
* (setf (person-name *tiange*) "hot tian")

"hot tian"
* (person-name *tiange*)

"hot tian"
* *tiange*

#S(PERSON :NAME "hot tian" :AGE 35 :STATUS "happy")
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
*(with-struct-ps (person- name age) *tiange* (setf name "cool guy") (setf age 45) (format t "name:~a, age:~a ~%" name age)) (with-struct-ps (person- name age) *tiange* (setf name "cool guy") (setf age 45) (format t "name:~a, age:~a ~%" name age))
name:cool guy, age:45 
NIL
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

;     ((BINDING X BINDS) (MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

;     ((BINDING Y BINDS) (MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

;     ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

;     ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

;     ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;      (MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;        ((BINDING X BINDS) (MATCH IT Y BINDS))
;        ((BINDING Y BINDS) (MATCH X IT BINDS))
;        ((VARSYM? X) (VALUES (CONS # BINDS) T))
;        ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;        ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS)) (MATCH (CDR X) (CDR Y) IT))
;        (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2 ((OR # # #) (VALUES BINDS T))
;          ((BINDING X BINDS) (MATCH IT Y BINDS))
;          ((BINDING Y BINDS) (MATCH X IT BINDS)) ((VARSYM? X) (VALUES # T))
;          ((VARSYM? Y) (VALUES # T)) ((AND # # #) (MATCH # # IT))
;          (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.

my plus called 
; in: DEFUN MATCH
;     (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;      ((BINDING X BINDS) (MATCH IT Y BINDS))
;      ((BINDING Y BINDS) (MATCH X IT BINDS))
;      ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;      ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;      ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;       (MATCH (CDR X) (CDR Y) IT))
;      (T (VALUE NIL NIL)))
; 
; caught STYLE-WARNING:
;   undefined function: ACOND2

;     (T (VALUE NIL NIL))
; 
; caught WARNING:
;   The function T is undefined, and its name is reserved by ANSI CL so that even
;   if it were defined later, the code doing so would not be portable.

;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     ACOND2 T VALUE
;   caught 6 ERROR conditions
;   caught 1 WARNING condition
;   caught 5 STYLE-WARNING conditions
STYLE-WARNING:
   ACOND2 is being redefined as a macro when it was previously assumed to be a function.
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR THE 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUE NIL NIL))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> my plus called 
FUNCTION IF 
; ==>
;   ((MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BINDING VARSYM?
;   caught 7 ERROR conditions
;   caught 2 STYLE-WARNING conditions
T
* (mp (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it))))

(OR
 (MULTIPLE-VALUE-BIND (IT #:G8719)
     (VALUES 2 T)
   (IF (OR #:G8719 IT)
       ((FORMAT T "value ~a ~%" IT))))
 (MULTIPLE-VALUE-BIND (IT #:G8720)
     (VALUES 3 T)
   (IF (OR #:G8720 IT)
       ((FORMAT T "value ~a ~%" IT)))))
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR THE 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUE NIL NIL))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> my plus called 
FUNCTION IF 
; ==>
;   ((MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BINDING VARSYM?
;   caught 7 ERROR conditions
;   caught 2 STYLE-WARNING conditions

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE at character 9185:
    end of file on #<SB-SYS:FD-STREAM
                     for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                     {128686B1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {128686B1}>
 9185)
0] abort
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR THE 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUE NIL NIL))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> my plus called 
FUNCTION IF 
; ==>
;   ((MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BINDING VARSYM?
;   caught 7 ERROR conditions
;   caught 2 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO ACOND2
;     (MAPCAR
;      #'(LAMBDA (ELM)
;          (LET ((LATER #))
;            `(MULTIPLE-VALUE-BIND (IT ,LATER)
;                 ,(CAR ELM)
;               (IF #
;                   #)))
;          BODY))
; 
; caught WARNING:
;   The function was called with one argument, but wants at least two.
; 
; compilation unit finished
;   caught 1 WARNING condition
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
; 
; caught ERROR:
;   during macroexpansion of
;   (ACOND2
;     (# #)
;     (# #)
;     ...).
;   Use *BREAK-ON-SIGNALS* to intercept:
;   
;    invalid number of arguments: 1

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2
;         ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;         ((BINDING X BINDS) (MATCH IT Y BINDS))
;         ((BINDING Y BINDS) (MATCH X IT BINDS))
;         ((VARSYM? X) (VALUES (CONS # BINDS) T))
;         ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;         ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS)) (MATCH (CDR X) (CDR Y) IT))
;         (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2
;           ((OR # # #) (VALUES BINDS T))
;           ((BINDING X BINDS) (MATCH IT Y BINDS))
;           ((BINDING Y BINDS) (MATCH X IT BINDS))
;           ((VARSYM? X) (VALUES # T))
;           ((VARSYM? Y) (VALUES # T))
;           ((AND # # #) (MATCH # # IT))
;           (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO ACOND2
;     (MAPCAR
;      #'(LAMBDA (ELM)
;          (LET ((LATER #))
;            `(MULTIPLE-VALUE-BIND (IT ,LATER)
;                 ,(CAR ELM)
;               (IF #
;                   #)))
;          BODY))
; 
; caught WARNING:
;   The function was called with one argument, but wants at least two.
; 
; compilation unit finished
;   caught 1 WARNING condition
T
* (mp (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it))))

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  invalid number of arguments: 1

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAPCAR #<CLOSURE (LAMBDA # :IN ACOND2) {12B50C15}>)[:EXTERNAL]
0] abort

* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
; 
; caught ERROR:
;   during macroexpansion of
;   (ACOND2
;     (# #)
;     (# #)
;     ...).
;   Use *BREAK-ON-SIGNALS* to intercept:
;   
;    invalid number of arguments: 1

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2
;         ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;         ((BINDING X BINDS) (MATCH IT Y BINDS))
;         ((BINDING Y BINDS) (MATCH X IT BINDS))
;         ((VARSYM? X) (VALUES (CONS # BINDS) T))
;         ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;         ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS)) (MATCH (CDR X) (CDR Y) IT))
;         (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2
;           ((OR # # #) (VALUES BINDS T))
;           ((BINDING X BINDS) (MATCH IT Y BINDS))
;           ((BINDING Y BINDS) (MATCH X IT BINDS))
;           ((VARSYM? X) (VALUES # T))
;           ((VARSYM? Y) (VALUES # T))
;           ((AND # # #) (MATCH # # IT))
;           (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO ACOND2
;     (MAPCAR
;      #'(LAMBDA (ELM)
;          (LET ((LATER #))
;            `(MULTIPLE-VALUE-BIND (IT ,LATER)
;                 ,(CAR ELM)
;               (IF #
;                   #)))
;          BODY))
; 
; caught WARNING:
;   The function was called with one argument, but wants at least two.
; 
; compilation unit finished
;   caught 1 WARNING condition
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;             ((BINDING X BINDS) (MATCH IT Y BINDS))
;             ((BINDING Y BINDS) (MATCH X IT BINDS))
;             ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;             ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;             ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;              (MATCH (CDR X) (CDR Y) IT))
;             (T (VALUE NIL NIL)))
; 
; caught ERROR:
;   during macroexpansion of (ACOND2 (# #) (# #) ...). Use *BREAK-ON-SIGNALS* to
;   intercept:
;   
;    invalid number of arguments: 1

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;               ((BINDING X BINDS) (MATCH IT Y BINDS))
;               ((BINDING Y BINDS) (MATCH X IT BINDS))
;               ((VARSYM? X) (VALUES (CONS # BINDS) T))
;               ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;               ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS))
;                (MATCH (CDR X) (CDR Y) IT))
;               (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2 ((OR # # #) (VALUES BINDS T))
;                 ((BINDING X BINDS) (MATCH IT Y BINDS))
;                 ((BINDING Y BINDS) (MATCH X IT BINDS))
;                 ((VARSYM? X) (VALUES # T)) ((VARSYM? Y) (VALUES # T))
;                 ((AND # # #) (MATCH # # IT)) (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions
T
* (mp (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it))))

(OR
 (MULTIPLE-VALUE-BIND (IT #:G9243)
     (VALUES 2 T)
   (IF (OR #:G9243 IT)
       (PROGN (FORMAT T "value ~a ~%" IT))))
 (MULTIPLE-VALUE-BIND (IT #:G9244)
     (VALUES 3 T)
   (IF (OR #:G9244 IT)
       (PROGN (FORMAT T "value ~a ~%" IT)))))
T
* (progn (format t "1") (return nil) (format t "2"))
1my plus called 
; in: PROGN (FORMAT T "1")
;     (RETURN-FROM NIL NIL)
; 
; caught ERROR:
;   return for unknown block: NIL
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (RETURN-FROM NIL NIL)
Compile-time error:
  return for unknown block: NIL

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (block :self (format t "first block"))
my plus called 
; in: BLOCK 'SELF
;     (BLOCK 'SELF (FORMAT T "first block"))
; 
; caught ERROR:
;   The block name 'SELF is not a symbol.
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (BLOCK 'SELF (FORMAT T first block))
Compile-time error:
  The block name 'SELF is not a symbol.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (block :self (format t "first block") (return 1) (format t "second"))
first block
NIL
* (block :self (format t "first block") (return-from :self 1) (format t "second"))
my plus called 
; in: BLOCK :SELF
;     (RETURN 1)
; ==>
;   (RETURN-FROM NIL 1)
; 
; caught ERROR:
;   return for unknown block: NIL
; 
; compilation unit finished
;   caught 1 ERROR condition
first block
debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (RETURN-FROM NIL 1)
Compile-time error:
  return for unknown block: NIL

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort

* (block :self (format t "first block") (return-from :self 1) (format t "second"))
first block
1
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     BINDING VALUE VARSYM?
;   caught 3 STYLE-WARNING conditions
T
* (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it)))

(BLOCK #:G9350
  (PROGN
   (MULTIPLE-VALUE-BIND (IT #:G9351)
       (VALUES 2 T)
     (IF (OR #:G9351 IT)
         (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT))))))
  (PROGN
   (MULTIPLE-VALUE-BIND (IT #:G9352)
       (VALUES 3 T)
     (IF (OR #:G9352 IT)
         (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))))
T
* (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it)))
value 2 
NIL
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (BINDING X BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE

;     (VARSYM? X)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     BINDING VALUE VARSYM?
;   caught 3 STYLE-WARNING conditions

my plus called 
; in: DEFUN BINDING
;     (AIF (ASSOC X BINDS) (OR (RECBIND (CDR IT) BINDS) IT))
; 
; caught STYLE-WARNING:
;   undefined function: AIF

;     (OR (RECBIND (CDR IT) BINDS) IT)
my plus called 
my plus called 
my plus called 
; --> LET IF OR 
; ==>
;   (THE T IT)
; 
; caught WARNING:
;   undefined variable: IT
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     AIF
;   Undefined variable:
my plus called 
;     IT
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
STYLE-WARNING:
   AIF is being redefined as a macro when it was previously assumed to be a function.
T
*(aif "coolguy" (format t "result:~a ~%" it))

(LET ((IT "coolguy"))
  (IF IT
      (FORMAT T "result:~a ~%" IT)
      NIL))
T
* (aif "coolguy" (format t "result:~a ~%" it))
result:coolguy 
NIL
* (binding 'x '((x y) (y z) (z w)))
my plus called 
; in: BINDING X
;     ((X Y) (Y Z) (Z W))
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((X Y) (Y Z) (Z W))
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (binding 'x '((x y) (y z) (z w)))

debugger invoked on a UNBOUND-VARIABLE: The variable IT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LABELS RECBIND :IN BINDING) X ((X Y) (Y Z) (Z W)))
0] abort

* (assoc 'x '((x y) (z w)))

(X Y)
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VALUE
;   caught 1 STYLE-WARNING condition
T
* (binding 'a '((b c) (a c) (c d) (d e)))

(C)
(A C)
* (binding 'a '((b c) (a c) ((c) d) ((d) e)))

(C)
(A C)
* (binding 'a '((b c) (a c) (c d) (d e)))

(C)
(A C)
* (binding 'a '((b c) (a c) ((c) d) ((d) e)))

(C)
(A C)
* (match '(p ?x b ?y a) '(p ?y b c a))

((?Y . C) (?X . ?Y))
T
* (match '(a b c) '(a b c))

NIL
T
*(load "embeded.lisp") (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VALUE
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO IF-MATCH
;     (VARS-IN THEN #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition
T
* (aif2 (values 2 nil) (format t "value ~a ~%" it))
value 2 
NIL
* (aif2 (values nil t) (format t "value ~a ~%" it))
value NIL 
NIL
* (aif2 (values 2 nil) (format t "value ~a ~%" it))
value 2 
NIL
* (union '(1 2) '(3 4))

(2 1 3 4)
* (union '(1 2 3) '(3 4 5))

(2 1 3 4 5)
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VALUE
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO IF-MATCH
;     (VARS-IN THEN #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN VARS-IN
;     (VAR? EXPR)
; 
; caught STYLE-WARNING:
;   undefined function: VAR?
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VAR?
;   caught 1 STYLE-WARNING condition
T
* (vars-in '(?x ?x ?y ?w 1 2))

(?Y ?W ?X)
* (match '(a ?x b) '(_ 1 _))

((?X . 1))
T
* (match '(?x ?y 1) '(?a ?b ?c))

((?W . ?C) (?Y . ?B) (?X . ?A))
T
* (match '(?x ?y 1) '(?a ?b ?c))

((?C . 1) (?Y . ?B) (?X . ?A))
T
* (if-match (?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

(AIF2 (MATCH '(?X ?Y) '(1 2 3 4))
      (LET ((?Y (BINDING '?Y IT)) (?X (BINDING '?X IT)))
        (FORMAT T "x:~a, y:~a ~%" ?X ?Y))
      NIL)
T
* (if-match (?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::VALUE is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (load "embeded.lisp")
my plus called 

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (if-match (?x ?y _ _) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

NIL
* (if-match (?x ?y ?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))
x:1, y:2 
NIL
* (if-match (?x ?y ?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

NIL
* (load "embeded.lisp")
my plus called 

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFMACRO IF-MATCH
;     #'SIMPLE?
; 
; caught STYLE-WARNING:
;   undefined function: SIMPLE?
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SIMPLE?
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO PAT-MATCH
;     (GEN-MATCH (CONS (LIST GSEQ SEQ) (DESTRUC PAT GSEQ #'SIMPLE?)) THEN `(,GELSE))
; 
; caught STYLE-WARNING:
;   undefined function: GEN-MATCH

;     (MATCH1 `((,PAT ,SEQ)) THEN ELSE)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH1

;     (SIMPLE? PAT)
; 
; caught STYLE-WARNING:
;   undefined function: SIMPLE?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     GEN-MATCH MATCH1 SIMPLE?
;   caught 3 STYLE-WARNING conditions

my plus called 
; in: DEFUN GEN-MATCH
;     (MATCH1 REFS THEN ELSE)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH1
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH1
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN MATCH1
;     (GENSYM? PAT)
; 
; caught STYLE-WARNING:
;   undefined function: GENSYM?

;     (LENGTH-TEST PAT REST)
; 
; caught STYLE-WARNING:
;   undefined function: LENGTH-TEST

;     `(,PATH ,GE)
; 
; caught WARNING:
;   undefined variable: PATH
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     GENSYM? LENGTH-TEST
;   Undefined variable:
my plus called 
;     PATH
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions
T
* (mp (if-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a, y:~a, w:~a ~%" ?x ?y ?w)))

(LET ((?W '#:G10064) (?Y '#:G10065) (?X '#:G10066))
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a, y:~a, w:~a ~%" ?X ?Y ?W) NIL))
T
* (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w)) nil)

debugger invoked on a SB-KERNEL::ARG-COUNT-ERROR:
  error while parsing arguments to DEFMACRO PAT-MATCH:
    invalid number of elements in
      ((?X ?Y (?W _)) (1 2 (3 4)) (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
    to satisfy lambda list
      (PAT SEQ THEN ELSE):
    exactly 4 expected, but 3 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((DEFMACRO PAT-MATCH)
 (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4)) (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
 #<unavailable argument>)
0] abort

* (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w)) nil)

debugger invoked on a SIMPLE-ERROR:
  wrong number of args to QUOTE:
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)
 #<NULL-LEXENV>)
0] abort

* (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w) nil))

debugger invoked on a SIMPLE-ERROR:
  wrong number of args to QUOTE:
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)
 #<NULL-LEXENV>)
0] (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w) nil))


debugger invoked on a UNBOUND-VARIABLE: The variable PATH is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

(MATCH1
 ((?Y (ELT #:G10068 1))
  ((#:G10070 (ELT #:G10068 2)) (?W (ELT #:G10070 0)) (_ (ELT #:G10070 1))))
 (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W)
 (#:G10069))
0[2] abort

0] abort

* (if-match (?x ?y ?z) (1 2 3) (format t "x:~a, y:~a, z:~a ~%" ?x ?y ?z))
my plus called 
; in: IF-MATCH (?X ?Y ?Z)
;     (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z) NIL)
; 
; caught ERROR:
;   during macroexpansion of (PAT-MATCH (?X ?Y ?Z) (1 2 3) ...). Use
;   *BREAK-ON-SIGNALS* to intercept:
;   
;    The variable PATH is unbound.

;     (LET ((?Z '#:G10072) (?Y '#:G10073) (?X '#:G10074))
;       (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z)
;                  NIL))
; 
; caught STYLE-WARNING:
;   The variable ?Z is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ?Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ?X is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T x:~a, y:~a, z:~a ~% ?X ?Y ?Z) NIL)
Compile-time error:
  during macroexpansion of (PAT-MATCH (?X ?Y ?Z) (1 2 3) ...). Use
*BREAK-ON-SIGNALS* to intercept:

 The variable PATH is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* ;; (LET ((?Z '#:G10072) (?Y '#:G10073) (?X '#:G10074))
	(mp (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z)
                  NIL)))
my plus called 
; in: LET ((?Z '#:G10072) (?Y '#:G10073) (?X '#:G10074))
;     (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z) NIL)
; 
; caught ERROR:
;   during macroexpansion of (PAT-MATCH (?X ?Y ?Z) (1 2 3) ...). Use
;   *BREAK-ON-SIGNALS* to intercept:
;   
;    The variable PATH is unbound.

;     (LET ((?Z '#:G10072) (?Y '#:G10073) (?X '#:G10074))
;       (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z)
;                  NIL))
; 
; caught STYLE-WARNING:
;   The variable ?Z is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ?Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ?X is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T x:~a, y:~a, z:~a ~% ?X ?Y ?Z) NIL)
Compile-time error:
  during macroexpansion of (PAT-MATCH (?X ?Y ?Z) (1 2 3) ...). Use
*BREAK-ON-SIGNALS* to intercept:

 The variable PATH is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* ((dbind (x (y . w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))

(LET ((#:G7286 '(1 "come on" 2 3 4 5)))
  (LET ((X (ELT #:G7286 0)) (#:G7287 (ELT #:G7286 1)) (G (SUBSEQ #:G7286 2)))
    (LET ((Y (ELT #:G7287 0)) (W (SUBSEQ #:G7287 1)))
      (PROGN (FORMAT T "cool guy")))))
T
* (dbind (x (y w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))
cool guy x:1 y:c w:ome on g:(2 3 4 5)
NIL
* (dbind (x (y &rest w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))
cool guy x:1 y:c w:o g:(2 3 4 5)
NIL
* (dbind (x (y &rest w) &rest g) '(1 "come on" 2 3 4 5) (format t "cool guy x:~a y:~a w:~a g:~a" x y w g))
cool guy x:1 y:c w:ome on g:(2 3 4 5)
NIL
* (setq cool 2)

my plus called 
; in: SETQ COOL
;     (SETQ COOL 2)
; 
; caught WARNING:
;   undefined variable: COOL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COOL
;   caught 1 WARNING condition
2
* cool

2
* (load "embeded.lisp")


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 232, Column: 3, File-Position: 6369

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                {12C3F379}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {12C3F379}>
 5962)
0] abort
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 232, Column: 3, File-Position: 6369

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                {132BFEF9}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {132BFEF9}>
 5962)
0] abort
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
*(mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))
my plus called 
; in: WITH-ARRAY (X Y Z)
;     (LET ((X (AREF #:G7602 0)) (Y (AREF #:G7602 1)) (Z (AREF #:G7602 2)))
;       )
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Z is defined but never used.

my plus called 
; in: WITH-ARRAY (X Y Z)
;     (FORMAT T "x:~a y:~a z:~a" X Y Z)
; 
; caught WARNING:
;   undefined variable: X
; 
; caught WARNING:
;   undefined variable: Y
; 
; caught WARNING:
;   undefined variable: Z
; 
; compilation unit finished
;   Undefined variables:
my plus called 
my plus called 
my plus called 
;     X Y Z
;   caught 3 WARNING conditions
;   caught 3 STYLE-WARNING conditions

debugger invoked on a UNBOUND-VARIABLE: The variable Y is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))

(LET ((#:G7603 #(1 2 3 4 5)))
  (LET ((X (AREF #:G7603 0)) (Y (AREF #:G7603 1)) (Z (AREF #:G7603 2)))
    )
  (FORMAT T "x:~a y:~a z:~a" X Y Z))
T
* (load "embeded.lisp")


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 247, Column: 7, File-Position: 6729

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                {12CEA6B1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {12CEA6B1}>
 6380)
0] abort
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))

(LET ((#:G7764 #(1 2 3 4 5)))
  (LET ((FORMAT T "x:~a y:~a z:~a" X Y Z))
    ))
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (mp (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z)))

(LET ((#:G7847 #(1 2 3 4 5)))
  (LET (PROGN (FORMAT T "x:~a y:~a z:~a" X Y Z))
    ))
T
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z))

(LET ((#:G7930 #(1 2 3 4 5)))
  (LET ((X (AREF #:G7930 0)) (Y (AREF #:G7930 1)) (Z (AREF #:G7930 2)))
    (FORMAT T "x:~a y:~a z:~a" X Y Z)))
T
* (with-array (x y z) #(1 2 3 4 5) (format t "x:~a y:~a z:~a" x y z))
x:1 y:2 z:3
NIL
* 
(elt *x* 2)

3
* (mp (elt *x* 2))

(ELT *X* 2)
NIL
* (load "embeded.lisp")

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (with-array ((x 0) (y 3)) #(1 2 3 4 5) (format t "x:~a y:~a" x y))

debugger invoked on a TYPE-ERROR: The value (20 450 3 4) is not of type ARRAY.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort

* (with-array ((x 0) (y 3)) #(1 2 3 4 5) (format t "x:~a y:~a" x y))
x:1 y:4
NIL
* (mp (defstruct person name age status))

(DEF-STRUCT PERSON NAME AGE STATUS)
NIL
* (mp (def-structure person name age status))

(DEF-STRUCTURE PERSON NAME AGE STATUS)
NIL
* (mp (defstruct person name age status))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
(PROGN
 (SB-KERNEL:WITH-SINGLE-PACKAGE-LOCKED-ERROR (:SYMBOL 'PERSON
                                              "defining ~A as a structure"))
 (SB-KERNEL::%DEFSTRUCT '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION PERSON>
                        '#(#<SB-KERNEL:LAYOUT for T {100627C9}>
                           #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {10062801}>)
                        (SB-C:SOURCE-LOCATION))
 (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
   (SB-KERNEL::%COMPILER-DEFSTRUCT '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION PERSON>
                                   '#(#<SB-KERNEL:LAYOUT for T {100627C9}>
                                      #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT
                                        {10062801}>)))
 (DECLAIM
  (FTYPE (SB-INT:SFUNCTION (&KEY (:NAME T) (:AGE T) (:STATUS T)) PERSON)
   MAKE-PERSON))
 (DEFUN MAKE-PERSON
        (&KEY ((:NAME #:DUM8016) ()) ((:AGE #:DUM8017) ())
         ((:STATUS #:DUM8018) ()))
   (SB-KERNEL::%MAKE-STRUCTURE-INSTANCE-MACRO
    #<SB-KERNEL:DEFSTRUCT-DESCRIPTION PERSON>
    '((:SLOT T . 1) (:SLOT T . 2) (:SLOT T . 3)) #:DUM8016 #:DUM8017
    #:DUM8018))
 (LOCALLY
  (DECLARE (NOTINLINE SB-KERNEL:FIND-CLASSOID))
  (SETF (SB-KERNEL::STRUCTURE-CLASSOID-CONSTRUCTOR
         (SB-KERNEL:FIND-CLASSOID 'PERSON))
          #'MAKE-PERSON))
 'PERSON)
T
*(defvar *tiange*) (defvar *tiange*)

*TIANGE*
* (defstruct person name age status)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
PERSON
* (make-person :name "tian" :age 35  :status "happy")

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR: odd number of &KEY arguments

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAKE-PERSON "tian" 35 "happy")[:OPTIONAL]
0] abort

* (make-person :name "tian" :age 35  :status "happy")

#S(PERSON :NAME "tian" :AGE 35 :STATUS "happy")
* (setf *tiange* (make-person :name "tian" :age 35 :status "happy"))

#S(PERSON :NAME "tian" :AGE 35 :STATUS "happy")
* ((symb person name) *tiange*)
my plus called 
; in: (SYMB PERSON NAME) *TIANGE*
;     ((SYMB PERSON NAME) *TIANGE*)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((SYMB PERSON NAME) *TIANGE*)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* ((symb name name) *tiange*)
my plus called 
; in: (SYMB NAME NAME) *TIANGE*
;     ((SYMB NAME NAME) *TIANGE*)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((SYMB NAME NAME) *TIANGE*)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (mp ((symb name age) *tiange*))

((SYMB NAME AGE) *TIANGE*)
NIL
* (symb name age)

my plus called 
; in: SYMB NAME
;     (SYMB NAME AGE)
; 
; caught WARNING:
;   undefined variable: AGE
; 
; caught WARNING:
;   undefined variable: NAME
; 
; caught STYLE-WARNING:
;   undefined function: SYMB
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SYMB
;   Undefined variables:
my plus called 
my plus called 
;     AGE NAME
;   caught 2 WARNING conditions
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable NAME is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (symb person name)

debugger invoked on a UNBOUND-VARIABLE: The variable PERSON is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV PERSON #<NULL-LEXENV>)
0] abort

* (symb 'person name)

debugger invoked on a UNBOUND-VARIABLE: The variable NAME is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV NAME #<NULL-LEXENV>)
0] abort

* (symb 'person 'name)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::SYMB is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-FUNCTION SYMB)
0] abort

* (load "embeded.lisp")


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFMACRO WITH-STRUCT
;     (SYMB NAME F)
; 
; caught STYLE-WARNING:
;   undefined function: SYMB
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SYMB
;   caught 1 STYLE-WARNING condition
T
* (map '+ #'(lambda (c) (* 2 c)) '(1 2 3 4))

debugger invoked on a TYPE-ERROR:
  The value #<FUNCTION LIST> is not of type (OR CONS SYMBOL SB-KERNEL:INSTANCE).

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAP #<FUNCTION LIST> #<FUNCTION (LAMBDA #) {1245701D}> (1 2 3 4))[:OPTIONAL]
0] abort

* (map nil #'(lambda (c) (* 2 c)) '(1 2 3 4))

(2 4 6 8)
* '+

+
* (map '+ #'(lambda (c) (* 2 c)) '(1 2 3 4))

debugger invoked on a SIMPLE-TYPE-ERROR:
  + is a bad type specifier for sequences.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-KERNEL:%MAP + #<FUNCTION (LAMBDA #) {12495ECD}> (1 2 3 4))
0] abort

* (map nil #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4))

NIL
* (map 2 #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4))
1234
NIL
* (mp (map nil #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4)))

debugger invoked on a TYPE-ERROR:
  The value 2 is not of type (OR CONS SYMBOL SB-KERNEL:INSTANCE).

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAP 2 #<FUNCTION (LAMBDA #) {125263D5}> (1 2 3 4))[:OPTIONAL]
0] aort

my plus called 
; in: LAMBDA (#:G8119)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {124699D9}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {12469A31}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-2
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-2 0
;                            {12469A91}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-3
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-3 0
;                            {12469AB1}>
;                         #:G8119))
;                       (SB-DEBUG::ARG-4
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-4 0
;                            {12469B21}>
;                         #:G8119)))
;       AORT)
; 
; caught WARNING:
;   undefined variable: AORT
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     AORT
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable AORT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G8119)) #<unavailable argument>)
0[2] abort

0] abort
* (mp (map nil #'(lambda (c) (format t "~a" c)(* 2 c)) '(1 2 3 4)))

(MAP NIL #'(LAMBDA (C) (FORMAT T "~a" C) (* 2 C)) '(1 2 3 4))
NIL
* (intern haha)

debugger invoked on a UNBOUND-VARIABLE: The variable HAHA is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV HAHA #<NULL-LEXENV>)
0] abort

* (intern "haha")

|haha|
NIL
* (values (intern "haha"))

|haha|
* (person-name *tiange*)

my plus called 
; in: PERSONNAME *TIANGE*
;     (PERSONNAME *TIANGE*)
; 
; caught STYLE-WARNING:
;   undefined function: PERSONNAME
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     PERSONNAME
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::PERSONNAME is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (person-name *tiange*)

"tian"
* (load "embeded.lisp")
STYLE-WARNING: redefining COMMON-LISP-USER::MKSTR in DEFUN
my plus called 


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (mp (with-struct (person- name age status) *tiange* (format t "~a age:~a status:~a ~%" name age status)))

(LET ((#:G8210 *TIANGE*))
  (LET ((NAME (PERSON-NAME #:G8210))
        (AGE (PERSON-AGE #:G8210))
        (STATUS (PERSON-STATUS #:G8210)))
    ))
T
* (with-struct (person- name age status) *tiange* (format t "~a age:~a status:~a ~%" name age status))

(LET ((#:G8211 *TIANGE*))
  (LET ((NAME (PERSON-NAME #:G8211))
        (AGE (PERSON-AGE #:G8211))
        (STATUS (PERSON-STATUS #:G8211)))
    (FORMAT T "~a age:~a status:~a ~%" NAME AGE STATUS)))
T
* (with-struct (person- name age status) *tiange* (format t "~a age:~a status:~a ~%" name age status))
tian age:35 status:happy 
NIL
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFMACRO WITH-PLACES
;     (DESTRUCT PAT GSEQ #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: DESTRUCT
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     DESTRUCT
;   caught 1 STYLE-WARNING condition
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* *x*

(20 450 3 4)
* (with-places (a b c d) *x* (setf a 50) (setf c 101) (format t "~a,~a,~a,~a ~%" a b c d))

(LET ((#:G8401 *X*))
  (SYMBOL-MACROLET ((A (ELT #:G8401 0))
                    (B (ELT #:G8401 1))
                    (#:G8402 (ELT #:G8401 2)))
    (SYMBOL-MACROLET ((C (ELT #:G8402 0)) (D (ELT #:G8402 1)))
      (PROGN (SETF A 50) (SETF C 101) (FORMAT T "~a,~a,~a,~a ~%" A B C D)))))
T
* (with-places (a b c d) *x* (setf a 50) (setf c 101) (format t "~a,~a,~a,~a ~%" a b c d))
50,450,101,4 
NIL
* (setf (person-name *tiange*) "hot tian")

"hot tian"
* (person-name *tiange*)

"hot tian"
* *tiange*

#S(PERSON :NAME "hot tian" :AGE 35 :STATUS "happy")
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
*(with-struct-ps (person- name age) *tiange* (setf name "cool guy") (setf age 45) (format t "name:~a, age:~a ~%" name age)) (with-struct-ps (person- name age) *tiange* (setf name "cool guy") (setf age 45) (format t "name:~a, age:~a ~%" name age))
name:cool guy, age:45 
NIL
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN LOOKUP
;     (MATCH X ARGS BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

;     ((BINDING X BINDS) (MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

;     ((BINDING Y BINDS) (MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

;     ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

;     ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

;     ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;      (MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;        ((BINDING X BINDS) (MATCH IT Y BINDS))
;        ((BINDING Y BINDS) (MATCH X IT BINDS))
;        ((VARSYM? X) (VALUES (CONS # BINDS) T))
;        ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;        ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS)) (MATCH (CDR X) (CDR Y) IT))
;        (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2 ((OR # # #) (VALUES BINDS T))
;          ((BINDING X BINDS) (MATCH IT Y BINDS))
;          ((BINDING Y BINDS) (MATCH X IT BINDS)) ((VARSYM? X) (VALUES # T))
;          ((VARSYM? Y) (VALUES # T)) ((AND # # #) (MATCH # # IT))
;          (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.

my plus called 
; in: DEFUN MATCH
;     (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;      ((BINDING X BINDS) (MATCH IT Y BINDS))
;      ((BINDING Y BINDS) (MATCH X IT BINDS))
;      ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;      ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;      ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;       (MATCH (CDR X) (CDR Y) IT))
;      (T (VALUE NIL NIL)))
; 
; caught STYLE-WARNING:
;   undefined function: ACOND2

;     (T (VALUE NIL NIL))
; 
; caught WARNING:
;   The function T is undefined, and its name is reserved by ANSI CL so that even
;   if it were defined later, the code doing so would not be portable.

;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     ACOND2 T VALUE
;   caught 6 ERROR conditions
;   caught 1 WARNING condition
;   caught 5 STYLE-WARNING conditions
STYLE-WARNING:
   ACOND2 is being redefined as a macro when it was previously assumed to be a function.
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR THE 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUE NIL NIL))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> my plus called 
FUNCTION IF 
; ==>
;   ((MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BINDING VARSYM?
;   caught 7 ERROR conditions
;   caught 2 STYLE-WARNING conditions
T
* (mp (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it))))

(OR
 (MULTIPLE-VALUE-BIND (IT #:G8719)
     (VALUES 2 T)
   (IF (OR #:G8719 IT)
       ((FORMAT T "value ~a ~%" IT))))
 (MULTIPLE-VALUE-BIND (IT #:G8720)
     (VALUES 3 T)
   (IF (OR #:G8720 IT)
       ((FORMAT T "value ~a ~%" IT)))))
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR THE 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUE NIL NIL))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> my plus called 
FUNCTION IF 
; ==>
;   ((MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BINDING VARSYM?
;   caught 7 ERROR conditions
;   caught 2 STYLE-WARNING conditions

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE at character 9185:
    end of file on #<SB-SYS:FD-STREAM
                     for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
                     {128686B1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/embeded.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/embeded.lisp"
   {128686B1}>
 9185)
0] abort
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR THE 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUE NIL NIL))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET IF OR LET 
; --> my plus called 
my plus called 
my plus called 
MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH (CDR X) (CDR Y) IT))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS Y X) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND 
; --> my plus called 
my plus called 
MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES (CONS (CONS X Y) BINDS) T))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> my plus called 
FUNCTION IF 
; ==>
;   ((MATCH X IT BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET IF OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((MATCH IT Y BINDS))
; 
; caught ERROR:
;   illegal function call

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> OR LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF 
; ==>
;   ((VALUES BINDS T))
; 
; caught ERROR:
;   illegal function call

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     BINDING VARSYM?
;   caught 7 ERROR conditions
;   caught 2 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO ACOND2
;     (MAPCAR
;      #'(LAMBDA (ELM)
;          (LET ((LATER #))
;            `(MULTIPLE-VALUE-BIND (IT ,LATER)
;                 ,(CAR ELM)
;               (IF #
;                   #)))
;          BODY))
; 
; caught WARNING:
;   The function was called with one argument, but wants at least two.
; 
; compilation unit finished
;   caught 1 WARNING condition
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
; 
; caught ERROR:
;   during macroexpansion of
;   (ACOND2
;     (# #)
;     (# #)
;     ...).
;   Use *BREAK-ON-SIGNALS* to intercept:
;   
;    invalid number of arguments: 1

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2
;         ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;         ((BINDING X BINDS) (MATCH IT Y BINDS))
;         ((BINDING Y BINDS) (MATCH X IT BINDS))
;         ((VARSYM? X) (VALUES (CONS # BINDS) T))
;         ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;         ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS)) (MATCH (CDR X) (CDR Y) IT))
;         (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2
;           ((OR # # #) (VALUES BINDS T))
;           ((BINDING X BINDS) (MATCH IT Y BINDS))
;           ((BINDING Y BINDS) (MATCH X IT BINDS))
;           ((VARSYM? X) (VALUES # T))
;           ((VARSYM? Y) (VALUES # T))
;           ((AND # # #) (MATCH # # IT))
;           (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO ACOND2
;     (MAPCAR
;      #'(LAMBDA (ELM)
;          (LET ((LATER #))
;            `(MULTIPLE-VALUE-BIND (IT ,LATER)
;                 ,(CAR ELM)
;               (IF #
;                   #)))
;          BODY))
; 
; caught WARNING:
;   The function was called with one argument, but wants at least two.
; 
; compilation unit finished
;   caught 1 WARNING condition
T
* (mp (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it))))

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  invalid number of arguments: 1

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MAPCAR #<CLOSURE (LAMBDA # :IN ACOND2) {12B50C15}>)[:EXTERNAL]
0] abort

* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2
;       ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;       ((BINDING X BINDS) (MATCH IT Y BINDS))
;       ((BINDING Y BINDS) (MATCH X IT BINDS))
;       ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;       ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;       ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;        (MATCH (CDR X) (CDR Y) IT))
;       (T (VALUE NIL NIL)))
; 
; caught ERROR:
;   during macroexpansion of
;   (ACOND2
;     (# #)
;     (# #)
;     ...).
;   Use *BREAK-ON-SIGNALS* to intercept:
;   
;    invalid number of arguments: 1

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2
;         ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;         ((BINDING X BINDS) (MATCH IT Y BINDS))
;         ((BINDING Y BINDS) (MATCH X IT BINDS))
;         ((VARSYM? X) (VALUES (CONS # BINDS) T))
;         ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;         ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS)) (MATCH (CDR X) (CDR Y) IT))
;         (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2
;           ((OR # # #) (VALUES BINDS T))
;           ((BINDING X BINDS) (MATCH IT Y BINDS))
;           ((BINDING Y BINDS) (MATCH X IT BINDS))
;           ((VARSYM? X) (VALUES # T))
;           ((VARSYM? Y) (VALUES # T))
;           ((AND # # #) (MATCH # # IT))
;           (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFMACRO ACOND2
;     (MAPCAR
;      #'(LAMBDA (ELM)
;          (LET ((LATER #))
;            `(MULTIPLE-VALUE-BIND (IT ,LATER)
;                 ,(CAR ELM)
;               (IF #
;                   #)))
;          BODY))
; 
; caught WARNING:
;   The function was called with one argument, but wants at least two.
; 
; compilation unit finished
;   caught 1 WARNING condition
T
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN MATCH
;     (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;             ((BINDING X BINDS) (MATCH IT Y BINDS))
;             ((BINDING Y BINDS) (MATCH X IT BINDS))
;             ((VARSYM? X) (VALUES (CONS (CONS X Y) BINDS) T))
;             ((VARSYM? Y) (VALUES (CONS (CONS Y X) BINDS) T))
;             ((AND (CONSP X) (CONSP Y) (MATCH (CAR X) (CAR Y) BINDS))
;              (MATCH (CDR X) (CDR Y) IT))
;             (T (VALUE NIL NIL)))
; 
; caught ERROR:
;   during macroexpansion of (ACOND2 (# #) (# #) ...). Use *BREAK-ON-SIGNALS* to
;   intercept:
;   
;    invalid number of arguments: 1

;     (DEFUN MATCH (X Y &OPTIONAL BINDS)
;       (ACOND2 ((OR (EQL X Y) (EQL X '_) (EQL Y '_)) (VALUES BINDS T))
;               ((BINDING X BINDS) (MATCH IT Y BINDS))
;               ((BINDING Y BINDS) (MATCH X IT BINDS))
;               ((VARSYM? X) (VALUES (CONS # BINDS) T))
;               ((VARSYM? Y) (VALUES (CONS # BINDS) T))
;               ((AND (CONSP X) (CONSP Y) (MATCH # # BINDS))
;                (MATCH (CDR X) (CDR Y) IT))
;               (T (VALUE NIL NIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA MATCH
;         (X Y &OPTIONAL BINDS)
;       (BLOCK MATCH
;         (ACOND2 ((OR # # #) (VALUES BINDS T))
;                 ((BINDING X BINDS) (MATCH IT Y BINDS))
;                 ((BINDING Y BINDS) (MATCH X IT BINDS))
;                 ((VARSYM? X) (VALUES # T)) ((VARSYM? Y) (VALUES # T))
;                 ((AND # # #) (MATCH # # IT)) (T (VALUE NIL NIL)))))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable BINDS is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions
T
* (mp (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it))))

(OR
 (MULTIPLE-VALUE-BIND (IT #:G9243)
     (VALUES 2 T)
   (IF (OR #:G9243 IT)
       (PROGN (FORMAT T "value ~a ~%" IT))))
 (MULTIPLE-VALUE-BIND (IT #:G9244)
     (VALUES 3 T)
   (IF (OR #:G9244 IT)
       (PROGN (FORMAT T "value ~a ~%" IT)))))
T
* (progn (format t "1") (return nil) (format t "2"))
1my plus called 
; in: PROGN (FORMAT T "1")
;     (RETURN-FROM NIL NIL)
; 
; caught ERROR:
;   return for unknown block: NIL
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (RETURN-FROM NIL NIL)
Compile-time error:
  return for unknown block: NIL

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (block :self (format t "first block"))
my plus called 
; in: BLOCK 'SELF
;     (BLOCK 'SELF (FORMAT T "first block"))
; 
; caught ERROR:
;   The block name 'SELF is not a symbol.
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (BLOCK 'SELF (FORMAT T first block))
Compile-time error:
  The block name 'SELF is not a symbol.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (block :self (format t "first block") (return 1) (format t "second"))
first block
NIL
* (block :self (format t "first block") (return-from :self 1) (format t "second"))
my plus called 
; in: BLOCK :SELF
;     (RETURN 1)
; ==>
;   (RETURN-FROM NIL 1)
; 
; caught ERROR:
;   return for unknown block: NIL
; 
; compilation unit finished
;   caught 1 ERROR condition
first block
debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (RETURN-FROM NIL 1)
Compile-time error:
  return for unknown block: NIL

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort

* (block :self (format t "first block") (return-from :self 1) (format t "second"))
first block
1
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (BINDING Y BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE

;     (VARSYM? Y)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     BINDING VALUE VARSYM?
;   caught 3 STYLE-WARNING conditions
T
* (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it)))

(BLOCK #:G9350
  (PROGN
   (MULTIPLE-VALUE-BIND (IT #:G9351)
       (VALUES 2 T)
     (IF (OR #:G9351 IT)
         (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT))))))
  (PROGN
   (MULTIPLE-VALUE-BIND (IT #:G9352)
       (VALUES 3 T)
     (IF (OR #:G9352 IT)
         (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))))
T
* (acond2 ((values 2 t) (format t "value ~a ~%" it)) ((values 3 t) (format t "value ~a ~%" it)))
value 2 
NIL
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (BINDING X BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: BINDING

;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE

;     (VARSYM? X)
; 
; caught STYLE-WARNING:
;   undefined function: VARSYM?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     BINDING VALUE VARSYM?
;   caught 3 STYLE-WARNING conditions

my plus called 
; in: DEFUN BINDING
;     (AIF (ASSOC X BINDS) (OR (RECBIND (CDR IT) BINDS) IT))
; 
; caught STYLE-WARNING:
;   undefined function: AIF

;     (OR (RECBIND (CDR IT) BINDS) IT)
my plus called 
my plus called 
my plus called 
; --> LET IF OR 
; ==>
;   (THE T IT)
; 
; caught WARNING:
;   undefined variable: IT
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     AIF
;   Undefined variable:
my plus called 
;     IT
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
STYLE-WARNING:
   AIF is being redefined as a macro when it was previously assumed to be a function.
T
*(aif "coolguy" (format t "result:~a ~%" it))

(LET ((IT "coolguy"))
  (IF IT
      (FORMAT T "result:~a ~%" IT)
      NIL))
T
* (aif "coolguy" (format t "result:~a ~%" it))
result:coolguy 
NIL
* (binding 'x '((x y) (y z) (z w)))
my plus called 
; in: BINDING X
;     ((X Y) (Y Z) (Z W))
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((X Y) (Y Z) (Z W))
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (binding 'x '((x y) (y z) (z w)))

debugger invoked on a UNBOUND-VARIABLE: The variable IT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LABELS RECBIND :IN BINDING) X ((X Y) (Y Z) (Z W)))
0] abort

* (assoc 'x '((x y) (z w)))

(X Y)
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VALUE
;   caught 1 STYLE-WARNING condition
T
* (binding 'a '((b c) (a c) (c d) (d e)))

(C)
(A C)
* (binding 'a '((b c) (a c) ((c) d) ((d) e)))

(C)
(A C)
* (binding 'a '((b c) (a c) (c d) (d e)))

(C)
(A C)
* (binding 'a '((b c) (a c) ((c) d) ((d) e)))

(C)
(A C)
* (match '(p ?x b ?y a) '(p ?y b c a))

((?Y . C) (?X . ?Y))
T
* (match '(a b c) '(a b c))

NIL
T
*(load "embeded.lisp") (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VALUE
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO IF-MATCH
;     (VARS-IN THEN #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition
T
* (aif2 (values 2 nil) (format t "value ~a ~%" it))
value 2 
NIL
* (aif2 (values nil t) (format t "value ~a ~%" it))
value NIL 
NIL
* (aif2 (values 2 nil) (format t "value ~a ~%" it))
value 2 
NIL
* (union '(1 2) '(3 4))

(2 1 3 4)
* (union '(1 2 3) '(3 4 5))

(2 1 3 4 5)
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER
;     (VARS-IN QUERY #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH
;     (VALUE NIL NIL)
; 
; caught STYLE-WARNING:
;   undefined function: VALUE
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VALUE
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO IF-MATCH
;     (VARS-IN THEN #'ATOM)
; 
; caught STYLE-WARNING:
;   undefined function: VARS-IN
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VARS-IN
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN VARS-IN
;     (VAR? EXPR)
; 
; caught STYLE-WARNING:
;   undefined function: VAR?
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     VAR?
;   caught 1 STYLE-WARNING condition
T
* (vars-in '(?x ?x ?y ?w 1 2))

(?Y ?W ?X)
* (match '(a ?x b) '(_ 1 _))

((?X . 1))
T
* (match '(?x ?y 1) '(?a ?b ?c))

((?W . ?C) (?Y . ?B) (?X . ?A))
T
* (match '(?x ?y 1) '(?a ?b ?c))

((?C . 1) (?Y . ?B) (?X . ?A))
T
* (if-match (?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

(AIF2 (MATCH '(?X ?Y) '(1 2 3 4))
      (LET ((?Y (BINDING '?Y IT)) (?X (BINDING '?X IT)))
        (FORMAT T "x:~a, y:~a ~%" ?X ?Y))
      NIL)
T
* (if-match (?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::VALUE is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (load "embeded.lisp")
my plus called 

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (if-match (?x ?y _ _) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

NIL
* (if-match (?x ?y ?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))
x:1, y:2 
NIL
* (if-match (?x ?y ?x ?y) '(1 2 3 4) (format t "x:~a, y:~a ~%" ?x ?y))

NIL
* (load "embeded.lisp")
my plus called 

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.

my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFMACRO IF-MATCH
;     #'SIMPLE?
; 
; caught STYLE-WARNING:
;   undefined function: SIMPLE?
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     SIMPLE?
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO PAT-MATCH
;     (GEN-MATCH (CONS (LIST GSEQ SEQ) (DESTRUC PAT GSEQ #'SIMPLE?)) THEN `(,GELSE))
; 
; caught STYLE-WARNING:
;   undefined function: GEN-MATCH

;     (MATCH1 `((,PAT ,SEQ)) THEN ELSE)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH1

;     (SIMPLE? PAT)
; 
; caught STYLE-WARNING:
;   undefined function: SIMPLE?
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     GEN-MATCH MATCH1 SIMPLE?
;   caught 3 STYLE-WARNING conditions

my plus called 
; in: DEFUN GEN-MATCH
;     (MATCH1 REFS THEN ELSE)
; 
; caught STYLE-WARNING:
;   undefined function: MATCH1
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MATCH1
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN MATCH1
;     (GENSYM? PAT)
; 
; caught STYLE-WARNING:
;   undefined function: GENSYM?

;     (LENGTH-TEST PAT REST)
; 
; caught STYLE-WARNING:
;   undefined function: LENGTH-TEST

;     `(,PATH ,GE)
; 
; caught WARNING:
;   undefined variable: PATH
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     GENSYM? LENGTH-TEST
;   Undefined variable:
my plus called 
;     PATH
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions
T
* (mp (if-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a, y:~a, w:~a ~%" ?x ?y ?w)))

(LET ((?W '#:G10064) (?Y '#:G10065) (?X '#:G10066))
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a, y:~a, w:~a ~%" ?X ?Y ?W) NIL))
T
* (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w)) nil)

debugger invoked on a SB-KERNEL::ARG-COUNT-ERROR:
  error while parsing arguments to DEFMACRO PAT-MATCH:
    invalid number of elements in
      ((?X ?Y (?W _)) (1 2 (3 4)) (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
    to satisfy lambda list
      (PAT SEQ THEN ELSE):
    exactly 4 expected, but 3 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((DEFMACRO PAT-MATCH)
 (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4)) (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
 #<unavailable argument>)
0] abort

* (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w)) nil)

debugger invoked on a SIMPLE-ERROR:
  wrong number of args to QUOTE:
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)
 #<NULL-LEXENV>)
0] abort

* (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w) nil))

debugger invoked on a SIMPLE-ERROR:
  wrong number of args to QUOTE:
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV
 (QUOTE
  (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4))
             (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W))
  NIL)
 #<NULL-LEXENV>)
0] (mp (pat-match (?x ?y (?w _)) (1 2 (3 4)) (format t "x:~a,y:~a:w:~a ~%" ?x ?y ?w) nil))


debugger invoked on a UNBOUND-VARIABLE: The variable PATH is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

(MATCH1
 ((?Y (ELT #:G10068 1))
  ((#:G10070 (ELT #:G10068 2)) (?W (ELT #:G10070 0)) (_ (ELT #:G10070 1))))
 (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W)
 (#:G10069))
0[2] abort

0] abort

* (if-match (?x ?y ?z) (1 2 3) (format t "x:~a, y:~a, z:~a ~%" ?x ?y ?z))
my plus called 
; in: IF-MATCH (?X ?Y ?Z)
;     (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z) NIL)
; 
; caught ERROR:
;   during macroexpansion of (PAT-MATCH (?X ?Y ?Z) (1 2 3) ...). Use
;   *BREAK-ON-SIGNALS* to intercept:
;   
;    The variable PATH is unbound.

;     (LET ((?Z '#:G10072) (?Y '#:G10073) (?X '#:G10074))
;       (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z)
;                  NIL))
; 
; caught STYLE-WARNING:
;   The variable ?Z is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ?Y is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable ?X is defined but never used.
; 
; compilation unit finished
;   caught 1 ERROR condition
;   caught 3 STYLE-WARNING conditions

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T x:~a, y:~a, z:~a ~% ?X ?Y ?Z) NIL)
Compile-time error:
  during macroexpansion of (PAT-MATCH (?X ?Y ?Z) (1 2 3) ...). Use
*BREAK-ON-SIGNALS* to intercept:

 The variable PATH is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* ;; (LET ((?Z '#:G10072) (?Y '#:G10073) (?X '#:G10074))
	(mp (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z)
                  NIL)))

debugger invoked on a SB-KERNEL:SIMPLE-PACKAGE-ERROR:
  The name "X" does not designate any package.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:%FIND-PACKAGE-OR-LOSE "X")
0] 
my plus called 
; in: LAMBDA (#:G10075)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13B85859}>
;                         #:G10075)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10075)) #<unavailable argument>)
0[2] 

debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  illegal terminating character after a colon: #\

    File-Position: 61715

    Stream: #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>
 "illegal terminating character after a colon: ~S"
 #\ )
0[3] 
my plus called 
; in: LAMBDA (#:G10076)
;     (SYMBOL-MACROLET ((SB-IMPL::ARGS
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>
;                         #:G10076))
;                       (SB-IMPL::CONTROL
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0
;                            {11DA43C1}>
;                         #:G10076))
;                       (STREAM
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>
;                         #:G10076)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10076)) #<unavailable argument>)
0[4] 

debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  illegal terminating character after a colon: #\

    File-Position: 65575

    Stream: #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>
 "illegal terminating character after a colon: ~S"
 #\ )
0[5] 
my plus called 
; in: LAMBDA (#:G10077)
;     (SYMBOL-MACROLET ((SB-IMPL::ARGS
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>
;                         #:G10077))
;                       (SB-IMPL::CONTROL
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0
;                            {11DA43C1}>
;                         #:G10077))
;                       (STREAM
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>
;                         #:G10077)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10077)) #<unavailable argument>)
0[6] 
my plus called 
; in: LAMBDA (#:G10078)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12469681}>
;                                             :FRAME #:G10078)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10078)) #<unavailable argument>)
0[7] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10078)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {124607C9}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12460A75}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12460A55}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {124607C9}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FDF50) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X000FC000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X000FC000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10077)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12435571}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12435A1D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {124359FD}>)
30: (INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12435571}>)
31: (ERROR SB-INT:SIMPLE-READER-ERROR :STREAM #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> :FORMAT-CONTROL "illegal terminating character after a colon: ~S" :FORMAT-ARGUMENTS (#\ ))
32: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> "illegal terminating character after a colon: ~S" #\ )
33: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> #\S)
34: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) T)
35: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
36: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
37: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>)
38: (SB-DEBUG::DEBUG-LOOP-FUN)
39: (INTERNAL-DEBUG)
40: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1242B7B1}>)
41: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
42: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1242BA3D}>)
43: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1242BA1D}>)
44: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1242B7B1}>)
45: (ERROR UNBOUND-VARIABLE :NAME MY)
46: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FEB20) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X000FA000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
47: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X000FA000) #<unavailable argument>)
48: ("foreign function: call_into_lisp")
49: ("foreign function: funcall2")
50: ("foreign function: interrupt_internal_error")
51: ("foreign function: handle_trap")
52: ("foreign function: sigtrap_handler")
53: ("foreign function: signal_emulation_wrapper")
54: ("foreign function: stack_allocation_recover")
55: ("foreign function: stack_allocation_recover")
56: ((LAMBDA (#:G10076)) #<unavailable argument>)
57: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
58: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
59: (SB-DEBUG::DEBUG-LOOP-FUN)
60: (INTERNAL-DEBUG)
61: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12407741}>)
62: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
63: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12407B85}>)
64: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12407B65}>)
65: (INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12407741}>)
66: (ERROR SB-INT:SIMPLE-READER-ERROR :STREAM #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> :FORMAT-CONTROL "illegal terminating character after a colon: ~S" :FORMAT-ARGUMENTS (#\ ))
67: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> "illegal terminating character after a colon: ~S" #\ )
68: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> #\S)
69: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) T)
70: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
71: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
72: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>)
73: (SB-DEBUG::DEBUG-LOOP-FUN)
74: (INTERNAL-DEBUG)
75: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123FF079}>)
76: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
77: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123FF2E5}>)
78: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123FF2C5}>)
79: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123FF079}>)
80: (ERROR UNBOUND-VARIABLE :NAME MY)
81: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF6F0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X000F8000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
82: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X000F8000) #<unavailable argument>)
83: ("foreign function: call_into_lisp")
84: ("foreign function: funcall2")
85: ("foreign function: interrupt_internal_error")
86: ("foreign function: handle_trap")
87: ("foreign function: sigtrap_handler")
88: ("foreign function: signal_emulation_wrapper")
89: ("foreign function: stack_allocation_recover")
90: ("foreign function: stack_allocation_recover")
91: ((LAMBDA (#:G10075)) #<unavailable argument>)
92: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
93: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
94: (SB-DEBUG::DEBUG-LOOP-FUN)
95: (INTERNAL-DEBUG)
96: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-KERNEL:SIMPLE-PACKAGE-ERROR "The name ~S does not designate any package." {123DD349}>)
97: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
98: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123DD715}>)
99: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123DD6F5}>)
100: (INVOKE-DEBUGGER #<SB-KERNEL:SIMPLE-PACKAGE-ERROR "The name ~S does not designate any package." {123DD349}>)
101: (ERROR SB-KERNEL:SIMPLE-PACKAGE-ERROR :PACKAGE "X" :FORMAT-CONTROL "The name ~S does not designate any package." :FORMAT-ARGUMENTS ("X"))
102: (SB-INT:%FIND-PACKAGE-OR-LOSE "X")
103: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #\x)
104: (SB-IMPL::READ-MAYBE-NOTHING #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #\x)
105: (SB-IMPL::READ-LIST #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #<unavailable argument>)
106: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> NIL (NIL) T)
107: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> NIL (NIL) NIL)
108: (READ #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> NIL (NIL) NIL)
109: (SB-IMPL::REPL-READ-FORM-FUN #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #<unavailable argument>)
110: (SB-IMPL::REPL-FUN NIL)
111: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
112: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
113: (SB-IMPL::TOPLEVEL-REPL NIL)
114: (SB-IMPL::TOPLEVEL-INIT)
115: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
116: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 7).
  1:         Reduce debugger level (to debug level 6).
  2:         Reduce debugger level (to debug level 5).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[8] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: (SB-DEBUG::DEBUG-LOOP-FUN)
1: (INTERNAL-DEBUG)
2: (SB-DEBUG::%INVOKE-DEBUGGER #<SIMPLE-ERROR "Maximum error nesting depth exceeded" {125283E9}>)
3: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
4: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125285B5}>)
5: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12528595}>)
6: (INVOKE-DEBUGGER #<SIMPLE-ERROR "Maximum error nesting depth exceeded" {125283E9}>)
7: ((LAMBDA NIL :IN SB-IMPL::ERROR-ERROR))
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::ERROR-ERROR) {124A4AA5}>)
9: (SB-IMPL::ERROR-ERROR "Help! " 11 " nested errors. " "SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.")
10: (SB-IMPL::INFINITE-ERROR-PROTECTOR)
11: (WARN "undefined ~(~A~): ~S" :VARIABLE MY)
12: (SB-C:COMPILER-WARN "undefined ~(~A~): ~S" :VARIABLE MY)
13: (SB-C::SUMMARIZE-COMPILATION-UNIT NIL)
14: ((FLET #:CLEANUP-FUN-101529 :IN SB-C::%WITH-COMPILATION-UNIT))[:CLEANUP]
15: ((FLET SB-THREAD::WITH-RECURSIVE-LOCK-THUNK :IN SB-C::%WITH-COMPILATION-UNIT))
16: ((FLET SB-C::WITH-IT :IN SB-C::%WITH-COMPILATION-UNIT))
17: (SB-C::ACTUALLY-COMPILE NIL (SB-INT:NAMED-LAMBDA (EVAL (LAMBDA #1=(#2=#:G10079))) NIL (DECLARE (MUFFLE-CONDITIONS COMPILER-NOTE)) (PROGN (FUNCTION (LAMBDA #1# (DECLARE (IGNORABLE #2#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {12490191}>) :FRAME #2#))) MY))))) #<NULL-LEXENV> NIL NIL)
18: (SB-C:COMPILE-IN-LEXENV NIL (SB-INT:NAMED-LAMBDA (EVAL (LAMBDA #1=(#2=#:G10079))) NIL (DECLARE (MUFFLE-CONDITIONS COMPILER-NOTE)) (PROGN (FUNCTION (LAMBDA #1# (DECLARE (IGNORABLE #2#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {12490191}>) :FRAME #2#))) MY))))) #<NULL-LEXENV> NIL NIL)
19: (SB-IMPL::%SIMPLE-EVAL (FUNCTION (LAMBDA (#1=#:G10079) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {12490191}>) :FRAME #1#))) MY))) #<NULL-LEXENV>)
20: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FUNCTION (LAMBDA (#1=#:G10079) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {12490191}>) :FRAME #1#))) MY))) #<NULL-LEXENV>)
21: (EVAL (FUNCTION (LAMBDA (#1=#:G10079) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {12490191}>) :FRAME #1#))) MY))))
22: (COERCE (LAMBDA (#1=#:G10079) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {12490191}>) :FRAME #1#))) MY)) FUNCTION)
23: (SB-DI:PREPROCESS-FOR-EVAL MY #<SB-DI::COMPILED-CODE-LOCATION (LAMBDA (#:G10078))>)
24: (SB-DI:EVAL-IN-FRAME #<SB-DI::COMPILED-FRAME (LAMBDA (#:G10078)), interrupted> MY)
25: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
26: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
27: (SB-DEBUG::DEBUG-LOOP-FUN)
28: (INTERNAL-DEBUG)
29: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12486371}>)
30: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
31: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1248662D}>)
32: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1248660D}>)
33: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12486371}>)
34: (ERROR UNBOUND-VARIABLE :NAME MY)
35: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD710) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X000FE000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
36: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X000FE000) #<unavailable argument>)
37: ("foreign function: call_into_lisp")
38: ("foreign function: funcall2")
39: ("foreign function: interrupt_internal_error")
40: ("foreign function: handle_trap")
41: ("foreign function: sigtrap_handler")
42: ("foreign function: signal_emulation_wrapper")
43: ("foreign function: stack_allocation_recover")
44: ("foreign function: stack_allocation_recover")
45: ((LAMBDA (#:G10078)) #<unavailable argument>)
46: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
47: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
48: (SB-DEBUG::DEBUG-LOOP-FUN)
49: (INTERNAL-DEBUG)
50: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {124607C9}>)
51: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
52: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12460A75}>)
53: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12460A55}>)
54: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {124607C9}>)
55: (ERROR UNBOUND-VARIABLE :NAME MY)
56: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FDF50) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X000FC000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
57: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X000FC000) #<unavailable argument>)
58: ("foreign function: call_into_lisp")
59: ("foreign function: funcall2")
60: ("foreign function: interrupt_internal_error")
61: ("foreign function: handle_trap")
62: ("foreign function: sigtrap_handler")
63: ("foreign function: signal_emulation_wrapper")
64: ("foreign function: stack_allocation_recover")
65: ("foreign function: stack_allocation_recover")
66: ((LAMBDA (#:G10077)) #<unavailable argument>)
67: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
68: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
69: (SB-DEBUG::DEBUG-LOOP-FUN)
70: (INTERNAL-DEBUG)
71: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12435571}>)
72: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
73: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12435A1D}>)
74: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {124359FD}>)
75: (INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12435571}>)
76: (ERROR SB-INT:SIMPLE-READER-ERROR :STREAM #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> :FORMAT-CONTROL "illegal terminating character after a colon: ~S" :FORMAT-ARGUMENTS (#\ ))
77: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> "illegal terminating character after a colon: ~S" #\ )
78: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> #\S)
79: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) T)
80: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
81: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
82: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>)
83: (SB-DEBUG::DEBUG-LOOP-FUN)
84: (INTERNAL-DEBUG)
85: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1242B7B1}>)
86: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
87: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1242BA3D}>)
88: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1242BA1D}>)
89: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1242B7B1}>)
90: (ERROR UNBOUND-VARIABLE :NAME MY)
91: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FEB20) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X000FA000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
92: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X000FA000) #<unavailable argument>)
93: ("foreign function: call_into_lisp")
94: ("foreign function: funcall2")
95: ("foreign function: interrupt_internal_error")
96: ("foreign function: handle_trap")
97: ("foreign function: sigtrap_handler")
98: ("foreign function: signal_emulation_wrapper")
99: ("foreign function: stack_allocation_recover")
100: ("foreign function: stack_allocation_recover")
101: ((LAMBDA (#:G10076)) #<unavailable argument>)
102: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
103: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
104: (SB-DEBUG::DEBUG-LOOP-FUN)
105: (INTERNAL-DEBUG)
106: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12407741}>)
107: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
108: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12407B85}>)
109: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12407B65}>)
110: (INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {12407741}>)
111: (ERROR SB-INT:SIMPLE-READER-ERROR :STREAM #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> :FORMAT-CONTROL "illegal terminating character after a colon: ~S" :FORMAT-ARGUMENTS (#\ ))
112: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> "illegal terminating character after a colon: ~S" #\ )
113: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> #\S)
114: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) T)
115: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
116: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}> NIL (NIL) NIL)
117: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {10112A71}>)
118: (SB-DEBUG::DEBUG-LOOP-FUN)
119: (INTERNAL-DEBUG)
120: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123FF079}>)
121: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
122: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123FF2E5}>)
123: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123FF2C5}>)
124: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123FF079}>)
125: (ERROR UNBOUND-VARIABLE :NAME MY)
126: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF6F0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X000F8000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
127: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X000F8000) #<unavailable argument>)
128: ("foreign function: call_into_lisp")
129: ("foreign function: funcall2")
130: ("foreign function: interrupt_internal_error")
131: ("foreign function: handle_trap")
132: ("foreign function: sigtrap_handler")
133: ("foreign function: signal_emulation_wrapper")
134: ("foreign function: stack_allocation_recover")
135: ("foreign function: stack_allocation_recover")
136: ((LAMBDA (#:G10075)) #<unavailable argument>)
137: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
138: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
139: (SB-DEBUG::DEBUG-LOOP-FUN)
140: (INTERNAL-DEBUG)
141: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-KERNEL:SIMPLE-PACKAGE-ERROR "The name ~S does not designate any package." {123DD349}>)
142: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
143: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123DD715}>)
144: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123DD6F5}>)
145: (INVOKE-DEBUGGER #<SB-KERNEL:SIMPLE-PACKAGE-ERROR "The name ~S does not designate any package." {123DD349}>)
146: (ERROR SB-KERNEL:SIMPLE-PACKAGE-ERROR :PACKAGE "X" :FORMAT-CONTROL "The name ~S does not designate any package." :FORMAT-ARGUMENTS ("X"))
147: (SB-INT:%FIND-PACKAGE-OR-LOSE "X")
148: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #\x)
149: (SB-IMPL::READ-MAYBE-NOTHING #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #\x)
150: (SB-IMPL::READ-LIST #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #<unavailable argument>)
151: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> NIL (NIL) T)
152: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> NIL (NIL) NIL)
153: (READ #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> NIL (NIL) NIL)
154: (SB-IMPL::REPL-READ-FORM-FUN #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {100E9649}> #<unavailable argument>)
155: (SB-IMPL::REPL-FUN NIL)
156: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
157: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
158: (SB-IMPL::TOPLEVEL-REPL NIL)
159: (SB-IMPL::TOPLEVEL-INIT)
160: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
161: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 8).
  1:         Reduce debugger level (to debug level 7).
  2:         Reduce debugger level (to debug level 6).
  3:         Reduce debugger level (to debug level 5).
  4:         Reduce debugger level (to debug level 3).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[9] * 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10082)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10082))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10082)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10082)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10083)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {1263AD81}>
;                                             :FRAME #:G10083)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10083)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10084)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {1265E9C9}>
;                                             :FRAME #:G10084)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10084)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10085)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {126843E1}>
;                                             :FRAME #:G10085)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10085)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10086)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {126AAD21}>
;                                             :FRAME #:G10086)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10085)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1267B6C1}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1267B98D}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1267B96D}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1267B6C1}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0060A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0060A000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10084)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126577C9}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12657A85}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12657A65}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126577C9}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00608000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00608000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10083)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12634909}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12634BB5}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12634B95}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12634909}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00606000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00606000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10082)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126127D1}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12612A5D}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12612A3D}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126127D1}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00604000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00604000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
85: (EVAL MY)
86: (INTERACTIVE-EVAL MY :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10086)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10086)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126A1579}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {126A1855}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {126A1835}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126A1579}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0060C000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0060C000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10085)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1267B6C1}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1267B98D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1267B96D}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1267B6C1}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0060A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0060A000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10084)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126577C9}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12657A85}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12657A65}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126577C9}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00608000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00608000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10083)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12634909}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12634BB5}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12634B95}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12634909}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00606000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00606000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10082)) #<unavailable argument>)
85: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126127D1}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12612A5D}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12612A3D}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {126127D1}>)
94: (ERROR UNBOUND-VARIABLE :NAME MY)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00604000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00604000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
106: (EVAL MY)
107: (INTERACTIVE-EVAL MY :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
NIL
* 
NIL
* 
101
* 
3
* 
3
* 
(ELT *X* 2)
NIL
* 
101
* 
NIL
* 
NIL
* my plus called 

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition

my plus called 
; in: DEFUN MATCH1
;     `(,PATH ,GE)
; 
; caught WARNING:
;   undefined variable: PATH
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     PATH
;   caught 1 WARNING condition
T
* 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10213)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10213))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10213)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10213)) #<unavailable argument>)
0[2] 
T
0[2] 
my plus called 
; in: DEF-STRUCT PERSON
;     (DEF-STRUCT PERSON NAME AGE STATUS)
; 
; caught WARNING:
;   undefined variable: AGE
; 
; caught STYLE-WARNING:
;   undefined function: DEF-STRUCT
; 
; caught WARNING:
;   undefined variable: NAME
; 
; caught WARNING:
;   undefined variable: PERSON
; 
; caught WARNING:
;   undefined variable: STATUS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     DEF-STRUCT
;   Undefined variables:
my plus called 
my plus called 
my plus called 
my plus called 
;     AGE NAME PERSON STATUS
;   caught 4 WARNING conditions
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable PERSON is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10215)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10216)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {13493D89}>
;                                             :FRAME #:G10216)))
;       {10062801}>)
; 
; caught WARNING:
;   undefined variable: {10062801}>
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     {10062801}>
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable {10062801}> is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10216)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10217)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {134B8BE1}>
;                                             :FRAME #:G10217)))
;       TYPE)
; 
; caught WARNING:
;   undefined variable: TYPE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     TYPE
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable TYPE is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10217)) #<unavailable argument>)
0[5] 
T
0[5] 
my plus called 
; in: LAMBDA (#:G10219)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {134E5EB1}>
;                                             :FRAME #:G10219)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10217)) #<unavailable argument>)
1: (INTERACTIVE-EVAL TYPE :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT TYPE)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE {10062801}> {134B0C51}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {134B0F1D}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {134B0EFD}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE {10062801}> {134B0C51}>)
10: (ERROR UNBOUND-VARIABLE :NAME {10062801}>)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0061C000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0061C000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10216)) #<unavailable argument>)
22: (INTERACTIVE-EVAL {10062801}> :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT {10062801}>)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE PERSON {1348D3B9}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1348D675}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1348D655}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE PERSON {1348D3B9}>)
31: (ERROR UNBOUND-VARIABLE :NAME PERSON)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0061A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0061A000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10215)) #<unavailable argument>)
43: (INTERACTIVE-EVAL (DEF-STRUCT PERSON NAME AGE STATUS) :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT (DEF-STRUCT PERSON NAME AGE STATUS))
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13444909}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13444BB5}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13444B95}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13444909}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00618000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00618000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10213)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {134219D9}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13421C65}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13421C45}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {134219D9}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00616000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00616000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
85: (EVAL MY)
86: (INTERACTIVE-EVAL MY :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10219)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10219)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE TYPE {134DCA01}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {134DCCDD}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {134DCCBD}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE TYPE {134DCA01}>)
10: (ERROR UNBOUND-VARIABLE :NAME TYPE)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0061E000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0061E000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10217)) #<unavailable argument>)
22: (INTERACTIVE-EVAL TYPE :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT TYPE)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE {10062801}> {134B0C51}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {134B0F1D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {134B0EFD}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE {10062801}> {134B0C51}>)
31: (ERROR UNBOUND-VARIABLE :NAME {10062801}>)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0061C000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0061C000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10216)) #<unavailable argument>)
43: (INTERACTIVE-EVAL {10062801}> :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT {10062801}>)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE PERSON {1348D3B9}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1348D675}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1348D655}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE PERSON {1348D3B9}>)
52: (ERROR UNBOUND-VARIABLE :NAME PERSON)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0061A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0061A000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10215)) #<unavailable argument>)
64: (INTERACTIVE-EVAL (DEF-STRUCT PERSON NAME AGE STATUS) :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT (DEF-STRUCT PERSON NAME AGE STATUS))
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13444909}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13444BB5}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13444B95}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13444909}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00618000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00618000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10213)) #<unavailable argument>)
85: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {134219D9}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13421C65}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13421C45}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {134219D9}>)
94: (ERROR UNBOUND-VARIABLE :NAME MY)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00616000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00616000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
106: (EVAL MY)
107: (INTERACTIVE-EVAL MY :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
debugger invoked on a UNBOUND-VARIABLE: The variable RESTARTS is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV RESTARTS #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10222)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10222))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10222)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10222)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10223)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {1364D5B9}>
;                                             :FRAME #:G10223)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10223)) #<unavailable argument>)
0[3] 
T
0[3] 
NIL
0[3] 
NIL
0[3] 
1234
0[3] 
NIL
0[3] 
NIL
0[3] 
my plus called 
; in: LAMBDA (#:G10230)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {13670D99}>
;                                             :FRAME #:G10230)))
;       DEBUGGER)
; 
; caught WARNING:
;   undefined variable: DEBUGGER
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     DEBUGGER
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable DEBUGGER is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10230)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10231)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {137039F9}>
;                                             :FRAME #:G10231)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10231)) #<unavailable argument>)
0[5] 

debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  illegal terminating character after a colon: #\

    File-Position: 17922

    Stream: #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}>
 "illegal terminating character after a colon: ~S"
 #\ )
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> "illegal terminating character after a colon: ~S" #\ )
1: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> #\1)
2: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> NIL (NIL) T)
3: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> NIL (NIL) NIL)
4: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> NIL (NIL) NIL)
5: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}>)
6: (SB-DEBUG::DEBUG-LOOP-FUN)
7: (INTERNAL-DEBUG)
8: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13725E01}>)
9: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
10: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {137260DD}>)
11: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {137260BD}>)
12: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13725E01}>)
13: (ERROR UNBOUND-VARIABLE :NAME MY)
14: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00630000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
15: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00630000) #<unavailable argument>)
16: ("foreign function: call_into_lisp")
17: ("foreign function: funcall2")
18: ("foreign function: interrupt_internal_error")
19: ("foreign function: handle_trap")
20: ("foreign function: sigtrap_handler")
21: ("foreign function: signal_emulation_wrapper")
22: ("foreign function: stack_allocation_recover")
23: ("foreign function: stack_allocation_recover")
24: ((LAMBDA (#:G10231)) #<unavailable argument>)
25: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
26: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
27: (SB-DEBUG::DEBUG-LOOP-FUN)
28: (INTERNAL-DEBUG)
29: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {136FBD71}>)
30: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
31: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136FC03D}>)
32: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136FC01D}>)
33: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {136FBD71}>)
34: (ERROR UNBOUND-VARIABLE :NAME DEBUGGER)
35: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0062E000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
36: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0062E000) #<unavailable argument>)
37: ("foreign function: call_into_lisp")
38: ("foreign function: funcall2")
39: ("foreign function: interrupt_internal_error")
40: ("foreign function: handle_trap")
41: ("foreign function: sigtrap_handler")
42: ("foreign function: signal_emulation_wrapper")
43: ("foreign function: stack_allocation_recover")
44: ("foreign function: stack_allocation_recover")
45: ((LAMBDA (#:G10230)) #<unavailable argument>)
46: (INTERACTIVE-EVAL DEBUGGER :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
47: (SB-DEBUG::DEBUG-EVAL-PRINT DEBUGGER)
48: (SB-DEBUG::DEBUG-LOOP-FUN)
49: (INTERNAL-DEBUG)
50: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13669C29}>)
51: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
52: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13669EE5}>)
53: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13669EC5}>)
54: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13669C29}>)
55: (ERROR UNBOUND-VARIABLE :NAME MY)
56: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0062C000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
57: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0062C000) #<unavailable argument>)
58: ("foreign function: call_into_lisp")
59: ("foreign function: funcall2")
60: ("foreign function: interrupt_internal_error")
61: ("foreign function: handle_trap")
62: ("foreign function: sigtrap_handler")
63: ("foreign function: signal_emulation_wrapper")
64: ("foreign function: stack_allocation_recover")
65: ("foreign function: stack_allocation_recover")
66: ((LAMBDA (#:G10223)) #<unavailable argument>)
67: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
68: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
69: (SB-DEBUG::DEBUG-LOOP-FUN)
70: (INTERNAL-DEBUG)
71: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13646909}>)
72: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
73: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13646BB5}>)
74: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13646B95}>)
75: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13646909}>)
76: (ERROR UNBOUND-VARIABLE :NAME MY)
77: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0062A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
78: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0062A000) #<unavailable argument>)
79: ("foreign function: call_into_lisp")
80: ("foreign function: funcall2")
81: ("foreign function: interrupt_internal_error")
82: ("foreign function: handle_trap")
83: ("foreign function: sigtrap_handler")
84: ("foreign function: signal_emulation_wrapper")
85: ("foreign function: stack_allocation_recover")
86: ("foreign function: stack_allocation_recover")
87: ((LAMBDA (#:G10222)) #<unavailable argument>)
88: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
89: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
90: (SB-DEBUG::DEBUG-LOOP-FUN)
91: (INTERNAL-DEBUG)
92: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {13623661}>)
93: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
94: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136238ED}>)
95: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136238CD}>)
96: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {13623661}>)
97: (ERROR UNBOUND-VARIABLE :NAME RESTARTS)
98: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00628000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
99: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00628000) #<unavailable argument>)
100: ("foreign function: call_into_lisp")
101: ("foreign function: funcall2")
102: ("foreign function: interrupt_internal_error")
103: ("foreign function: handle_trap")
104: ("foreign function: sigtrap_handler")
105: ("foreign function: signal_emulation_wrapper")
106: ("foreign function: stack_allocation_recover")
107: ("foreign function: stack_allocation_recover")
108: (SB-INT:SIMPLE-EVAL-IN-LEXENV RESTARTS #<NULL-LEXENV>)
109: (EVAL RESTARTS)
110: (INTERACTIVE-EVAL RESTARTS :EVAL NIL)
111: (SB-IMPL::REPL-FUN NIL)
112: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
113: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
114: (SB-IMPL::TOPLEVEL-REPL NIL)
115: (SB-IMPL::TOPLEVEL-INIT)
116: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
117: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: (SB-DEBUG::DEBUG-LOOP-FUN)
1: (INTERNAL-DEBUG)
2: (SB-DEBUG::%INVOKE-DEBUGGER #<SIMPLE-ERROR "Maximum error nesting depth exceeded" {137C8789}>)
3: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
4: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {137C8955}>)
5: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {137C8935}>)
6: (INVOKE-DEBUGGER #<SIMPLE-ERROR "Maximum error nesting depth exceeded" {137C8789}>)
7: ((LAMBDA NIL :IN SB-IMPL::ERROR-ERROR))
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::ERROR-ERROR) {1375011D}>)
9: (SB-IMPL::ERROR-ERROR "Help! " 11 " nested errors. " "SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.")
10: (SB-IMPL::INFINITE-ERROR-PROTECTOR)
11: (WARN "undefined ~(~A~): ~S" :VARIABLE THE)
12: (SB-C:COMPILER-WARN "undefined ~(~A~): ~S" :VARIABLE THE)
13: (SB-C::SUMMARIZE-COMPILATION-UNIT NIL)
14: ((FLET #:CLEANUP-FUN-101529 :IN SB-C::%WITH-COMPILATION-UNIT))[:CLEANUP]
15: ((FLET SB-THREAD::WITH-RECURSIVE-LOCK-THUNK :IN SB-C::%WITH-COMPILATION-UNIT))
16: ((FLET SB-C::WITH-IT :IN SB-C::%WITH-COMPILATION-UNIT))
17: (SB-C::ACTUALLY-COMPILE NIL (SB-INT:NAMED-LAMBDA (EVAL (LAMBDA #1=(#2=#:G10232))) NIL (DECLARE (MUFFLE-CONDITIONS COMPILER-NOTE)) (PROGN (FUNCTION (LAMBDA #1# (DECLARE (IGNORABLE #2#)) (SYMBOL-MACROLET ((SB-IMPL::ARGS (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>) #2#)) (SB-IMPL::CONTROL (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0 {11DA43C1}>) #2#)) (STREAM (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>) #2#))) THE))))) #<NULL-LEXENV> NIL NIL)
18: (SB-C:COMPILE-IN-LEXENV NIL (SB-INT:NAMED-LAMBDA (EVAL (LAMBDA #1=(#2=#:G10232))) NIL (DECLARE (MUFFLE-CONDITIONS COMPILER-NOTE)) (PROGN (FUNCTION (LAMBDA #1# (DECLARE (IGNORABLE #2#)) (SYMBOL-MACROLET ((SB-IMPL::ARGS (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>) #2#)) (SB-IMPL::CONTROL (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0 {11DA43C1}>) #2#)) (STREAM (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>) #2#))) THE))))) #<NULL-LEXENV> NIL NIL)
19: (SB-IMPL::%SIMPLE-EVAL (FUNCTION (LAMBDA (#1=#:G10232) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-IMPL::ARGS (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>) #1#)) (SB-IMPL::CONTROL (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0 {11DA43C1}>) #1#)) (STREAM (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>) #1#))) THE))) #<NULL-LEXENV>)
20: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FUNCTION (LAMBDA (#1=#:G10232) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-IMPL::ARGS (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>) #1#)) (SB-IMPL::CONTROL (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0 {11DA43C1}>) #1#)) (STREAM (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>) #1#))) THE))) #<NULL-LEXENV>)
21: (EVAL (FUNCTION (LAMBDA (#1=#:G10232) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-IMPL::ARGS (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>) #1#)) (SB-IMPL::CONTROL (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0 {11DA43C1}>) #1#)) (STREAM (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>) #1#))) THE))))
22: (COERCE (LAMBDA (#1=#:G10232) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-IMPL::ARGS (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>) #1#)) (SB-IMPL::CONTROL (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0 {11DA43C1}>) #1#)) (STREAM (SB-DI:DEBUG-VAR-VALUE (QUOTE #<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>) #1#))) THE)) FUNCTION)
23: (SB-DI:PREPROCESS-FOR-EVAL THE #<SB-DI::COMPILED-CODE-LOCATION (SB-C::VARARGS-ENTRY SB-INT:SIMPLE-READER-ERROR)>)
24: (SB-DI:EVAL-IN-FRAME #<SB-DI::COMPILED-FRAME (SB-C::VARARGS-ENTRY SB-INT:SIMPLE-READER-ERROR)> THE)
25: (INTERACTIVE-EVAL THE :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
26: (SB-DEBUG::DEBUG-EVAL-PRINT THE)
27: (SB-DEBUG::DEBUG-LOOP-FUN)
28: (INTERNAL-DEBUG)
29: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {13730099}>)
30: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
31: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1373066D}>)
32: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1373064D}>)
33: (INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {13730099}>)
34: (ERROR SB-INT:SIMPLE-READER-ERROR :STREAM #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> :FORMAT-CONTROL "illegal terminating character after a colon: ~S" :FORMAT-ARGUMENTS (#\ ))
35: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> "illegal terminating character after a colon: ~S" #\ )
36: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> #\1)
37: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> NIL (NIL) T)
38: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> NIL (NIL) NIL)
39: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}> NIL (NIL) NIL)
40: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {1358F129}>)
41: (SB-DEBUG::DEBUG-LOOP-FUN)
42: (INTERNAL-DEBUG)
43: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13725E01}>)
44: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
45: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {137260DD}>)
46: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {137260BD}>)
47: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13725E01}>)
48: (ERROR UNBOUND-VARIABLE :NAME MY)
49: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00630000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
50: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00630000) #<unavailable argument>)
51: ("foreign function: call_into_lisp")
52: ("foreign function: funcall2")
53: ("foreign function: interrupt_internal_error")
54: ("foreign function: handle_trap")
55: ("foreign function: sigtrap_handler")
56: ("foreign function: signal_emulation_wrapper")
57: ("foreign function: stack_allocation_recover")
58: ("foreign function: stack_allocation_recover")
59: ((LAMBDA (#:G10231)) #<unavailable argument>)
60: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
61: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
62: (SB-DEBUG::DEBUG-LOOP-FUN)
63: (INTERNAL-DEBUG)
64: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {136FBD71}>)
65: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
66: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136FC03D}>)
67: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136FC01D}>)
68: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {136FBD71}>)
69: (ERROR UNBOUND-VARIABLE :NAME DEBUGGER)
70: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0062E000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
71: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0062E000) #<unavailable argument>)
72: ("foreign function: call_into_lisp")
73: ("foreign function: funcall2")
74: ("foreign function: interrupt_internal_error")
75: ("foreign function: handle_trap")
76: ("foreign function: sigtrap_handler")
77: ("foreign function: signal_emulation_wrapper")
78: ("foreign function: stack_allocation_recover")
79: ("foreign function: stack_allocation_recover")
80: ((LAMBDA (#:G10230)) #<unavailable argument>)
81: (INTERACTIVE-EVAL DEBUGGER :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
82: (SB-DEBUG::DEBUG-EVAL-PRINT DEBUGGER)
83: (SB-DEBUG::DEBUG-LOOP-FUN)
84: (INTERNAL-DEBUG)
85: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13669C29}>)
86: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
87: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13669EE5}>)
88: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13669EC5}>)
89: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13669C29}>)
90: (ERROR UNBOUND-VARIABLE :NAME MY)
91: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0062C000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
92: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0062C000) #<unavailable argument>)
93: ("foreign function: call_into_lisp")
94: ("foreign function: funcall2")
95: ("foreign function: interrupt_internal_error")
96: ("foreign function: handle_trap")
97: ("foreign function: sigtrap_handler")
98: ("foreign function: signal_emulation_wrapper")
99: ("foreign function: stack_allocation_recover")
100: ("foreign function: stack_allocation_recover")
101: ((LAMBDA (#:G10223)) #<unavailable argument>)
102: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
103: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
104: (SB-DEBUG::DEBUG-LOOP-FUN)
105: (INTERNAL-DEBUG)
106: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13646909}>)
107: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
108: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13646BB5}>)
109: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {13646B95}>)
110: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13646909}>)
111: (ERROR UNBOUND-VARIABLE :NAME MY)
112: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0062A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
113: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0062A000) #<unavailable argument>)
114: ("foreign function: call_into_lisp")
115: ("foreign function: funcall2")
116: ("foreign function: interrupt_internal_error")
117: ("foreign function: handle_trap")
118: ("foreign function: sigtrap_handler")
119: ("foreign function: signal_emulation_wrapper")
120: ("foreign function: stack_allocation_recover")
121: ("foreign function: stack_allocation_recover")
122: ((LAMBDA (#:G10222)) #<unavailable argument>)
123: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
124: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
125: (SB-DEBUG::DEBUG-LOOP-FUN)
126: (INTERNAL-DEBUG)
127: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {13623661}>)
128: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
129: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136238ED}>)
130: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {136238CD}>)
131: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {13623661}>)
132: (ERROR UNBOUND-VARIABLE :NAME RESTARTS)
133: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00628000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
134: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00628000) #<unavailable argument>)
135: ("foreign function: call_into_lisp")
136: ("foreign function: funcall2")
137: ("foreign function: interrupt_internal_error")
138: ("foreign function: handle_trap")
139: ("foreign function: sigtrap_handler")
140: ("foreign function: signal_emulation_wrapper")
141: ("foreign function: stack_allocation_recover")
142: ("foreign function: stack_allocation_recover")
143: (SB-INT:SIMPLE-EVAL-IN-LEXENV RESTARTS #<NULL-LEXENV>)
144: (EVAL RESTARTS)
145: (INTERACTIVE-EVAL RESTARTS :EVAL NIL)
146: (SB-IMPL::REPL-FUN NIL)
147: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
148: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
149: (SB-IMPL::TOPLEVEL-REPL NIL)
150: (SB-IMPL::TOPLEVEL-INIT)
151: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
152: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 7).
  1:         Reduce debugger level (to debug level 6).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[8] 
NIL
0[8] * 
T
* 
T
* cool guy age:45 status:happy 
NIL
* 
debugger invoked on a UNBOUND-VARIABLE: The variable TIAN is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV TIAN #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10237)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10237))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10237)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10237)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10238)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {13931959}>
;                                             :FRAME #:G10238)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10238)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10239)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {1396B911}>
;                                             :FRAME #:G10239)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10239)) #<unavailable argument>)
0[4] 
NIL
0[4] 
"hot tian"
0[4] 
"hot tian"
0[4] 
#S(PERSON :NAME "hot tian" :AGE 35 :STATUS "happy")
0[4] 
#S(PERSON :NAME "hot tian" :AGE 35 :STATUS "happy")
0[4] 
my plus called 
; in: LAMBDA (#:G10245)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {1399A8F9}>
;                                             :FRAME #:G10245)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10245)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10246)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {148C4DC9}>
;                                             :FRAME #:G10246)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10245)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1398E6C9}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1398E995}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1398E975}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1398E6C9}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0063F000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0063F000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10239)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13961271}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1396152D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1396150D}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13961271}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0063D000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0063D000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10238)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1392A919}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1392ABC5}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1392ABA5}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1392A919}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0063B000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0063B000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10237)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE TIAN {138FFD59}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {138FFFE5}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {138FFFC5}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE TIAN {138FFD59}>)
73: (ERROR UNBOUND-VARIABLE :NAME TIAN)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00639000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00639000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV TIAN #<NULL-LEXENV>)
85: (EVAL TIAN)
86: (INTERACTIVE-EVAL TIAN :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10246)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10246)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {148BAE09}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {148BB0E5}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {148BB0C5}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {148BAE09}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00641000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00641000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10245)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1398E6C9}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1398E995}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1398E975}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1398E6C9}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0063F000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0063F000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10239)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13961271}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1396152D}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1396150D}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {13961271}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0063D000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0063D000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10238)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1392A919}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1392ABC5}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1392ABA5}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1392A919}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0063B000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0063B000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10237)) #<unavailable argument>)
85: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE TIAN {138FFD59}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {138FFFE5}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {138FFFC5}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE TIAN {138FFD59}>)
94: (ERROR UNBOUND-VARIABLE :NAME TIAN)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00639000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00639000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV TIAN #<NULL-LEXENV>)
106: (EVAL TIAN)
107: (INTERACTIVE-EVAL TIAN :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10249)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10249))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10249)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10249)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10250)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12063789}>
;                                             :FRAME #:G10250)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10250)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10251)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12086F19}>
;                                             :FRAME #:G10251)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10251)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10252)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {120ABDE9}>
;                                             :FRAME #:G10252)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10252)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10253)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {120D25A1}>
;                                             :FRAME #:G10253)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10252)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {120A3931}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {120A3BFD}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {120A3BDD}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {120A3931}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00648000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00648000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10251)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12080271}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1208052D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1208050D}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12080271}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00646000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00646000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10250)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1205E699}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1205E945}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1205E925}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1205E699}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00644000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00644000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10249)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1203BFC9}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1203C255}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1203C235}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1203BFC9}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00625000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00625000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
85: (EVAL MY)
86: (INTERACTIVE-EVAL MY :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10253)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10253)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {120C8E09}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {120C90E5}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {120C90C5}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {120C8E09}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0064A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0064A000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10252)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {120A3931}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {120A3BFD}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {120A3BDD}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {120A3931}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00648000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00648000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10251)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12080271}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1208052D}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1208050D}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12080271}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00646000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00646000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10250)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1205E699}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1205E945}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1205E925}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1205E699}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00644000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00644000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10249)) #<unavailable argument>)
85: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1203BFC9}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1203C255}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1203C235}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1203BFC9}>)
94: (ERROR UNBOUND-VARIABLE :NAME MY)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00625000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00625000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
106: (EVAL MY)
107: (INTERACTIVE-EVAL MY :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10256)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10256))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10256)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10256)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10257)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {122173C9}>
;                                             :FRAME #:G10257)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10257)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10258)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {1223B231}>
;                                             :FRAME #:G10258)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10258)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10259)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12260309}>
;                                             :FRAME #:G10259)))
;       MULTIPLE-VALUE-BIND)
; 
; caught WARNING:
;   undefined variable: MULTIPLE-VALUE-BIND
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MULTIPLE-VALUE-BIND
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE:
  The variable MULTIPLE-VALUE-BIND is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10259)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10260)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12287519}>
;                                             :FRAME #:G10260)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10259)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MULTIPLE-VALUE-BIND :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MULTIPLE-VALUE-BIND)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12257D71}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1225803D}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1225801D}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12257D71}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0065B000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0065B000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10258)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12233C29}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12233EE5}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12233EC5}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12233C29}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00659000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00659000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10257)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12211171}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1221141D}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {122113FD}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12211171}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00657000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00657000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10256)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {121EE211}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {121EE49D}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {121EE47D}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {121EE211}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00655000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00655000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
85: (EVAL MY)
86: (INTERACTIVE-EVAL MY :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10260)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10260)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MULTIPLE-VALUE-BIND {1227CE89}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1227D165}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1227D145}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MULTIPLE-VALUE-BIND {1227CE89}>)
10: (ERROR UNBOUND-VARIABLE :NAME MULTIPLE-VALUE-BIND)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0065D000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0065D000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10259)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MULTIPLE-VALUE-BIND :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MULTIPLE-VALUE-BIND)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12257D71}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1225803D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1225801D}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12257D71}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0065B000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0065B000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10258)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12233C29}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12233EE5}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12233EC5}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12233C29}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00659000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00659000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10257)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12211171}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1221141D}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {122113FD}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12211171}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00657000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00657000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10256)) #<unavailable argument>)
85: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {121EE211}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {121EE49D}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {121EE47D}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {121EE211}>)
94: (ERROR UNBOUND-VARIABLE :NAME MY)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00655000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00655000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
106: (EVAL MY)
107: (INTERACTIVE-EVAL MY :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
debugger invoked on a UNBOUND-VARIABLE: The variable TYPE is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV TYPE #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10263)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10263))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10263)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10263)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10264)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {123D6F41}>
;                                             :FRAME #:G10264)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10264)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10265)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {123FAE81}>
;                                             :FRAME #:G10265)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10265)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10266)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12420AA1}>
;                                             :FRAME #:G10266)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10266)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10267)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12447969}>
;                                             :FRAME #:G10267)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10266)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12417931}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12417BFD}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12417BDD}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12417931}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0066E000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0066E000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10265)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123F3CD1}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123F3F8D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123F3F6D}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123F3CD1}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0066C000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0066C000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10264)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123D1171}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123D141D}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123D13FD}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123D1171}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0066A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0066A000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10263)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE TYPE {123A9B99}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123A9E25}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123A9E05}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE TYPE {123A9B99}>)
73: (ERROR UNBOUND-VARIABLE :NAME TYPE)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00668000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00668000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV TYPE #<NULL-LEXENV>)
85: (EVAL TYPE)
86: (INTERACTIVE-EVAL TYPE :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10267)) #<unavailable argument>)
0[6] 
Your command, T, is ambiguous:
   TOPLEVEL
   TOP

0[6] 
#S(PERSON :NAME "hot tian" :AGE 35 :STATUS "happy")
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10267)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1243D7F9}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1243DAD5}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1243DAB5}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1243D7F9}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00670000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00670000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10266)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12417931}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12417BFD}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12417BDD}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12417931}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0066E000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0066E000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10265)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123F3CD1}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123F3F8D}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123F3F6D}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123F3CD1}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0066C000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0066C000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10264)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123D1171}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123D141D}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123D13FD}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {123D1171}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0066A000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0066A000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10263)) #<unavailable argument>)
85: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE TYPE {123A9B99}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123A9E25}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {123A9E05}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE TYPE {123A9B99}>)
94: (ERROR UNBOUND-VARIABLE :NAME TYPE)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00668000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00668000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV TYPE #<NULL-LEXENV>)
106: (EVAL TYPE)
107: (INTERACTIVE-EVAL TYPE :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10271)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10271))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10271)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10271)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10272)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {125A26D9}>
;                                             :FRAME #:G10272)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10272)) #<unavailable argument>)
0[3] 

debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  illegal terminating character after a colon: #\

    File-Position: 13711

    Stream: #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}>
 "illegal terminating character after a colon: ~S"
 #\ )
0[4] 
my plus called 
; in: LAMBDA (#:G10273)
;     (SYMBOL-MACROLET ((SB-IMPL::ARGS
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>
;                         #:G10273))
;                       (SB-IMPL::CONTROL
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0
;                            {11DA43C1}>
;                         #:G10273))
;                       (STREAM
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>
;                         #:G10273)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10273)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10274)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {125FB641}>
;                                             :FRAME #:G10274)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10274)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10274)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125F36C9}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125F39A5}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125F3985}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125F36C9}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FDDF0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00681000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00681000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10273)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {125CCE71}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125CD3B5}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125CD395}>)
30: (INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {125CCE71}>)
31: (ERROR SB-INT:SIMPLE-READER-ERROR :STREAM #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> :FORMAT-CONTROL "illegal terminating character after a colon: ~S" :FORMAT-ARGUMENTS (#\ ))
32: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> "illegal terminating character after a colon: ~S" #\ )
33: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> #\0)
34: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> NIL (NIL) T)
35: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> NIL (NIL) NIL)
36: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> NIL (NIL) NIL)
37: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}>)
38: (SB-DEBUG::DEBUG-LOOP-FUN)
39: (INTERNAL-DEBUG)
40: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125C4609}>)
41: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
42: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125C48C5}>)
43: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125C48A5}>)
44: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125C4609}>)
45: (ERROR UNBOUND-VARIABLE :NAME MY)
46: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0067F000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
47: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0067F000) #<unavailable argument>)
48: ("foreign function: call_into_lisp")
49: ("foreign function: funcall2")
50: ("foreign function: interrupt_internal_error")
51: ("foreign function: handle_trap")
52: ("foreign function: sigtrap_handler")
53: ("foreign function: signal_emulation_wrapper")
54: ("foreign function: stack_allocation_recover")
55: ("foreign function: stack_allocation_recover")
56: ((LAMBDA (#:G10272)) #<unavailable argument>)
57: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
58: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
59: (SB-DEBUG::DEBUG-LOOP-FUN)
60: (INTERNAL-DEBUG)
61: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1259D4D1}>)
62: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
63: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1259D77D}>)
64: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1259D75D}>)
65: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1259D4D1}>)
66: (ERROR UNBOUND-VARIABLE :NAME MY)
67: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0067D000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
68: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0067D000) #<unavailable argument>)
69: ("foreign function: call_into_lisp")
70: ("foreign function: funcall2")
71: ("foreign function: interrupt_internal_error")
72: ("foreign function: handle_trap")
73: ("foreign function: sigtrap_handler")
74: ("foreign function: signal_emulation_wrapper")
75: ("foreign function: stack_allocation_recover")
76: ("foreign function: stack_allocation_recover")
77: ((LAMBDA (#:G10271)) #<unavailable argument>)
78: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
79: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
80: (SB-DEBUG::DEBUG-LOOP-FUN)
81: (INTERNAL-DEBUG)
82: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1257A3E1}>)
83: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
84: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1257A66D}>)
85: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1257A64D}>)
86: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1257A3E1}>)
87: (ERROR UNBOUND-VARIABLE :NAME MY)
88: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0067B000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
89: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0067B000) #<unavailable argument>)
90: ("foreign function: call_into_lisp")
91: ("foreign function: funcall2")
92: ("foreign function: interrupt_internal_error")
93: ("foreign function: handle_trap")
94: ("foreign function: sigtrap_handler")
95: ("foreign function: signal_emulation_wrapper")
96: ("foreign function: stack_allocation_recover")
97: ("foreign function: stack_allocation_recover")
98: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
99: (EVAL MY)
100: (INTERACTIVE-EVAL MY :EVAL NIL)
101: (SB-IMPL::REPL-FUN NIL)
102: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
103: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
104: (SB-IMPL::TOPLEVEL-REPL NIL)
105: (SB-IMPL::TOPLEVEL-INIT)
106: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
107: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: (SB-DEBUG::DEBUG-LOOP-FUN)
1: (INTERNAL-DEBUG)
2: (SB-DEBUG::%INVOKE-DEBUGGER #<SIMPLE-ERROR "Maximum error nesting depth exceeded" {12695BD1}>)
3: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
4: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12695D9D}>)
5: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12695D7D}>)
6: (INVOKE-DEBUGGER #<SIMPLE-ERROR "Maximum error nesting depth exceeded" {12695BD1}>)
7: ((LAMBDA NIL :IN SB-IMPL::ERROR-ERROR))
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::ERROR-ERROR) {126363FD}>)
9: (SB-IMPL::ERROR-ERROR "Help! " 11 " nested errors. " "SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.")
10: (SB-IMPL::INFINITE-ERROR-PROTECTOR)
11: (WARN "undefined ~(~A~): ~S" :VARIABLE MY)
12: (SB-C:COMPILER-WARN "undefined ~(~A~): ~S" :VARIABLE MY)
13: (SB-C::SUMMARIZE-COMPILATION-UNIT NIL)
14: ((FLET #:CLEANUP-FUN-101529 :IN SB-C::%WITH-COMPILATION-UNIT))[:CLEANUP]
15: ((FLET SB-THREAD::WITH-RECURSIVE-LOCK-THUNK :IN SB-C::%WITH-COMPILATION-UNIT))
16: ((FLET SB-C::WITH-IT :IN SB-C::%WITH-COMPILATION-UNIT))
17: (SB-C::ACTUALLY-COMPILE NIL (SB-INT:NAMED-LAMBDA (EVAL (LAMBDA #1=(#2=#:G10275))) NIL (DECLARE (MUFFLE-CONDITIONS COMPILER-NOTE)) (PROGN (FUNCTION (LAMBDA #1# (DECLARE (IGNORABLE #2#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {126210E1}>) :FRAME #2#))) MY))))) #<NULL-LEXENV> NIL NIL)
18: (SB-C:COMPILE-IN-LEXENV NIL (SB-INT:NAMED-LAMBDA (EVAL (LAMBDA #1=(#2=#:G10275))) NIL (DECLARE (MUFFLE-CONDITIONS COMPILER-NOTE)) (PROGN (FUNCTION (LAMBDA #1# (DECLARE (IGNORABLE #2#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {126210E1}>) :FRAME #2#))) MY))))) #<NULL-LEXENV> NIL NIL)
19: (SB-IMPL::%SIMPLE-EVAL (FUNCTION (LAMBDA (#1=#:G10275) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {126210E1}>) :FRAME #1#))) MY))) #<NULL-LEXENV>)
20: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FUNCTION (LAMBDA (#1=#:G10275) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {126210E1}>) :FRAME #1#))) MY))) #<NULL-LEXENV>)
21: (EVAL (FUNCTION (LAMBDA (#1=#:G10275) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {126210E1}>) :FRAME #1#))) MY))))
22: (COERCE (LAMBDA (#1=#:G10275) (DECLARE (IGNORABLE #1#)) (SYMBOL-MACROLET ((SB-DEBUG::ARG-0 (SB-DI::DEBUG-SIGNAL (QUOTE SB-DI:INVALID-VALUE) :DEBUG-VAR (QUOTE #<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0 {126210E1}>) :FRAME #1#))) MY)) FUNCTION)
23: (SB-DI:PREPROCESS-FOR-EVAL MY #<SB-DI::COMPILED-CODE-LOCATION (LAMBDA (#:G10274))>)
24: (SB-DI:EVAL-IN-FRAME #<SB-DI::COMPILED-FRAME (LAMBDA (#:G10274)), interrupted> MY)
25: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
26: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
27: (SB-DEBUG::DEBUG-LOOP-FUN)
28: (INTERNAL-DEBUG)
29: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12618E09}>)
30: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
31: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {126190F5}>)
32: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {126190D5}>)
33: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12618E09}>)
34: (ERROR UNBOUND-VARIABLE :NAME MY)
35: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD5B0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00683000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
36: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00683000) #<unavailable argument>)
37: ("foreign function: call_into_lisp")
38: ("foreign function: funcall2")
39: ("foreign function: interrupt_internal_error")
40: ("foreign function: handle_trap")
41: ("foreign function: sigtrap_handler")
42: ("foreign function: signal_emulation_wrapper")
43: ("foreign function: stack_allocation_recover")
44: ("foreign function: stack_allocation_recover")
45: ((LAMBDA (#:G10274)) #<unavailable argument>)
46: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
47: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
48: (SB-DEBUG::DEBUG-LOOP-FUN)
49: (INTERNAL-DEBUG)
50: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125F36C9}>)
51: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
52: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125F39A5}>)
53: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125F3985}>)
54: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125F36C9}>)
55: (ERROR UNBOUND-VARIABLE :NAME MY)
56: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FDDF0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00681000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
57: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00681000) #<unavailable argument>)
58: ("foreign function: call_into_lisp")
59: ("foreign function: funcall2")
60: ("foreign function: interrupt_internal_error")
61: ("foreign function: handle_trap")
62: ("foreign function: sigtrap_handler")
63: ("foreign function: signal_emulation_wrapper")
64: ("foreign function: stack_allocation_recover")
65: ("foreign function: stack_allocation_recover")
66: ((LAMBDA (#:G10273)) #<unavailable argument>)
67: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
68: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
69: (SB-DEBUG::DEBUG-LOOP-FUN)
70: (INTERNAL-DEBUG)
71: (SB-DEBUG::%INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {125CCE71}>)
72: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
73: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125CD3B5}>)
74: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125CD395}>)
75: (INVOKE-DEBUGGER #<SB-INT:SIMPLE-READER-ERROR "illegal terminating character after a colon: ~S" {125CCE71}>)
76: (ERROR SB-INT:SIMPLE-READER-ERROR :STREAM #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> :FORMAT-CONTROL "illegal terminating character after a colon: ~S" :FORMAT-ARGUMENTS (#\ ))
77: (SB-INT:SIMPLE-READER-ERROR #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> "illegal terminating character after a colon: ~S" #\ )
78: (SB-IMPL::READ-TOKEN #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> #\0)
79: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> NIL (NIL) T)
80: (SB-IMPL::%READ-PRESERVING-WHITESPACE #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> NIL (NIL) NIL)
81: (READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}> NIL (NIL) NIL)
82: (SB-DEBUG::DEBUG-READ #<SYNONYM-STREAM :SYMBOL *TERMINAL-IO* {124EF619}>)
83: (SB-DEBUG::DEBUG-LOOP-FUN)
84: (INTERNAL-DEBUG)
85: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125C4609}>)
86: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
87: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125C48C5}>)
88: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {125C48A5}>)
89: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {125C4609}>)
90: (ERROR UNBOUND-VARIABLE :NAME MY)
91: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0067F000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
92: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0067F000) #<unavailable argument>)
93: ("foreign function: call_into_lisp")
94: ("foreign function: funcall2")
95: ("foreign function: interrupt_internal_error")
96: ("foreign function: handle_trap")
97: ("foreign function: sigtrap_handler")
98: ("foreign function: signal_emulation_wrapper")
99: ("foreign function: stack_allocation_recover")
100: ("foreign function: stack_allocation_recover")
101: ((LAMBDA (#:G10272)) #<unavailable argument>)
102: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
103: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
104: (SB-DEBUG::DEBUG-LOOP-FUN)
105: (INTERNAL-DEBUG)
106: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1259D4D1}>)
107: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
108: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1259D77D}>)
109: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1259D75D}>)
110: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1259D4D1}>)
111: (ERROR UNBOUND-VARIABLE :NAME MY)
112: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0067D000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
113: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0067D000) #<unavailable argument>)
114: ("foreign function: call_into_lisp")
115: ("foreign function: funcall2")
116: ("foreign function: interrupt_internal_error")
117: ("foreign function: handle_trap")
118: ("foreign function: sigtrap_handler")
119: ("foreign function: signal_emulation_wrapper")
120: ("foreign function: stack_allocation_recover")
121: ("foreign function: stack_allocation_recover")
122: ((LAMBDA (#:G10271)) #<unavailable argument>)
123: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
124: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
125: (SB-DEBUG::DEBUG-LOOP-FUN)
126: (INTERNAL-DEBUG)
127: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1257A3E1}>)
128: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
129: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1257A66D}>)
130: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1257A64D}>)
131: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1257A3E1}>)
132: (ERROR UNBOUND-VARIABLE :NAME MY)
133: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0067B000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
134: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0067B000) #<unavailable argument>)
135: ("foreign function: call_into_lisp")
136: ("foreign function: funcall2")
137: ("foreign function: interrupt_internal_error")
138: ("foreign function: handle_trap")
139: ("foreign function: sigtrap_handler")
140: ("foreign function: signal_emulation_wrapper")
141: ("foreign function: stack_allocation_recover")
142: ("foreign function: stack_allocation_recover")
143: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
144: (EVAL MY)
145: (INTERACTIVE-EVAL MY :EVAL NIL)
146: (SB-IMPL::REPL-FUN NIL)
147: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
148: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
149: (SB-IMPL::TOPLEVEL-REPL NIL)
150: (SB-IMPL::TOPLEVEL-INIT)
151: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
152: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 7).
  1:         Reduce debugger level (to debug level 6).
  2:         Reduce debugger level (to debug level 5).
  3:         Reduce debugger level (to debug level 4).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[8] * 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
Your command, T, is ambiguous:
   TOPLEVEL
   TOP

0] 
#S(PERSON :NAME "hot tian" :AGE 35 :STATUS "happy")
0] my plus called 
; in: LAMBDA (#:G10279)
;     (MULTIPLE-VALUE-BIND (IT #:G9243)
;         (VALUES 2 T)
;       (IF (OR #:G9243 IT)
;           (PROGN (FORMAT T "value ~a ~%" IT))))
my plus called 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   #'(LAMBDA (&OPTIONAL (IT) (#:G9243) &REST #:G5)
;       (DECLARE (IGNORE #:G5))
;       (IF (OR #:G9243 IT)
;           (PROGN (FORMAT T "value ~a ~%" IT))))
; 
; caught STYLE-WARNING:
;   The variable #:G9243 is defined but never used.

;     (MULTIPLE-VALUE-BIND (IT #:G9244)
;         (VALUES 3 T)
;       (IF (OR #:G9244 IT)
;           (PROGN (FORMAT T "value ~a ~%" IT))))
my plus called 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   #'(LAMBDA (&OPTIONAL (IT) (#:G9244) &REST #:G1)
;       (DECLARE (IGNORE #:G1))
;       (IF (OR #:G9244 IT)
;           (PROGN (FORMAT T "value ~a ~%" IT))))
; 
; caught STYLE-WARNING:
;   The variable #:G9244 is defined but never used.

my plus called 
; in: LAMBDA (#:G10279)
;     (OR #:G9243 IT)
; ==>
;   (LET ((#:G6 #:G9243))
;     (IF #:G6
;         #:G6
;         (OR IT)))
; 
; caught WARNING:
;   undefined variable: #:G9243

;     (OR #:G9244 IT)
; ==>
;   (LET ((#:G2 #:G9244))
;     (IF #:G2
;         #:G2
;         (OR IT)))
; 
; caught WARNING:
;   undefined variable: #:G9244
; 
; compilation unit finished
;   Undefined variables:
my plus called 
my plus called 
;     #:G9243 #:G9244
;   caught 2 WARNING conditions
;   caught 2 STYLE-WARNING conditions

debugger invoked on a UNBOUND-VARIABLE: The variable #:G9243 is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10279)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10280)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12807301}>
;                                             :FRAME #:G10280)))
;       COMPILE-TIME)
; 
; caught WARNING:
;   undefined variable: COMPILE-TIME
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COMPILE-TIME
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable COMPILE-TIME is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10280)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10281)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {1282B829}>
;                                             :FRAME #:G10281)))
;       0])
; 
; caught WARNING:
;   undefined variable: 0]
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     0]
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable 0] is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10281)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10282)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12851121}>
;                                             :FRAME #:G10282)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10282)) #<unavailable argument>)
0[5] my plus called 
; in: LAMBDA (#:G10283)
;     (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))
; 
; caught ERROR:
;   return for unknown block: #:G9350
; 
; caught ERROR:
;   return for unknown block: #:G9350

;     (MULTIPLE-VALUE-BIND (IT #:G9351)
;         (VALUES 2 T)
;       (IF (OR #:G9351 IT)
;           (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))
my plus called 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   #'(LAMBDA (&OPTIONAL (IT) (#:G9351) &REST #:G0)
;       (DECLARE (IGNORE #:G0))
;       (IF (OR #:G9351 IT)
;           (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))
; 
; caught STYLE-WARNING:
;   The variable #:G9351 is defined but never used.

;     (MULTIPLE-VALUE-BIND (IT #:G9352)
;         (VALUES 3 T)
;       (IF (OR #:G9352 IT)
;           (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))
my plus called 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   #'(LAMBDA (&OPTIONAL (IT) (#:G9352) &REST #:G4)
;       (DECLARE (IGNORE #:G4))
;       (IF (OR #:G9352 IT)
;           (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))
; 
; caught STYLE-WARNING:
;   The variable #:G9352 is defined but never used.

my plus called 
; in: LAMBDA (#:G10283)
;     (OR #:G9351 IT)
; ==>
;   (LET ((#:G1 #:G9351))
;     (IF #:G1
;         #:G1
;         (OR IT)))
; 
; caught WARNING:
;   undefined variable: #:G9351

;     (OR #:G9352 IT)
; ==>
;   (LET ((#:G5 #:G9352))
;     (IF #:G5
;         #:G5
;         (OR IT)))
; 
; caught WARNING:
;   undefined variable: #:G9352
; 
; compilation unit finished
;   Undefined variables:
my plus called 
my plus called 
;     #:G9351 #:G9352
;   caught 2 ERROR conditions
;   caught 2 WARNING conditions
;   caught 2 STYLE-WARNING conditions
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10282)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE 0] {128486C9}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12848995}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12848975}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE 0] {128486C9}>)
10: (ERROR UNBOUND-VARIABLE :NAME 0])
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00694000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00694000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10281)) #<unavailable argument>)
22: (INTERACTIVE-EVAL 0] :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT 0])
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE COMPILE-TIME {12824309}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {128245C5}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {128245A5}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE COMPILE-TIME {12824309}>)
31: (ERROR UNBOUND-VARIABLE :NAME COMPILE-TIME)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00692000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00692000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10280)) #<unavailable argument>)
43: (INTERACTIVE-EVAL COMPILE-TIME :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT COMPILE-TIME)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE G9243 {12800BF1}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12800E9D}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12800E7D}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE G9243 {12800BF1}>)
52: (ERROR UNBOUND-VARIABLE :NAME #:G9243)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00690000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (80))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00690000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10279)) #<unavailable argument>)
64: (INTERACTIVE-EVAL (OR (MULTIPLE-VALUE-BIND (IT #:G9243) (VALUES 2 T) (IF (OR #:G9243 IT) (PROGN (FORMAT T "value ~a ~%" IT)))) (MULTIPLE-VALUE-BIND (IT #:G9244) (VALUES 3 T) (IF (OR #:G9244 IT) (PROGN (FORMAT T "value ~a ~%" IT))))) :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT (OR (MULTIPLE-VALUE-BIND (IT #:G9243) (VALUES 2 T) (IF (OR #:G9243 IT) (PROGN (FORMAT T "value ~a ~%" IT)))) (MULTIPLE-VALUE-BIND (IT #:G9244) (VALUES 3 T) (IF (OR #:G9244 IT) (PROGN (FORMAT T "value ~a ~%" IT))))))
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1275F079}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1275F305}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1275F2E5}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1275F079}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0068E000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0068E000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
85: (EVAL MY)
86: (INTERACTIVE-EVAL MY :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10283)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10283)) #<unavailable argument>)
1: (INTERACTIVE-EVAL (BLOCK #:G9350 (PROGN (MULTIPLE-VALUE-BIND (IT #:G9351) (VALUES 2 T) (IF (OR #:G9351 IT) (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))) (PROGN (MULTIPLE-VALUE-BIND (IT #:G9352) (VALUES 3 T) (IF (OR #:G9352 IT) (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT))))))) :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT (BLOCK #:G9350 (PROGN (MULTIPLE-VALUE-BIND (IT #:G9351) (VALUES 2 T) (IF (OR #:G9351 IT) (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT)))))) (PROGN (MULTIPLE-VALUE-BIND (IT #:G9352) (VALUES 3 T) (IF (OR #:G9352 IT) (RETURN-FROM #:G9350 (PROGN (FORMAT T "value ~a ~%" IT))))))))
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1286DE09}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1286E0E5}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1286E0C5}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1286DE09}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00696000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00696000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10282)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE 0] {128486C9}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12848995}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12848975}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE 0] {128486C9}>)
31: (ERROR UNBOUND-VARIABLE :NAME 0])
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00694000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00694000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10281)) #<unavailable argument>)
43: (INTERACTIVE-EVAL 0] :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT 0])
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE COMPILE-TIME {12824309}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {128245C5}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {128245A5}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE COMPILE-TIME {12824309}>)
52: (ERROR UNBOUND-VARIABLE :NAME COMPILE-TIME)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00692000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00692000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10280)) #<unavailable argument>)
64: (INTERACTIVE-EVAL COMPILE-TIME :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT COMPILE-TIME)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE G9243 {12800BF1}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12800E9D}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12800E7D}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE G9243 {12800BF1}>)
73: (ERROR UNBOUND-VARIABLE :NAME #:G9243)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X00690000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (80))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X00690000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10279)) #<unavailable argument>)
85: (INTERACTIVE-EVAL (OR (MULTIPLE-VALUE-BIND (IT #:G9243) (VALUES 2 T) (IF (OR #:G9243 IT) (PROGN (FORMAT T "value ~a ~%" IT)))) (MULTIPLE-VALUE-BIND (IT #:G9244) (VALUES 3 T) (IF (OR #:G9244 IT) (PROGN (FORMAT T "value ~a ~%" IT))))) :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT (OR (MULTIPLE-VALUE-BIND (IT #:G9243) (VALUES 2 T) (IF (OR #:G9243 IT) (PROGN (FORMAT T "value ~a ~%" IT)))) (MULTIPLE-VALUE-BIND (IT #:G9244) (VALUES 3 T) (IF (OR #:G9244 IT) (PROGN (FORMAT T "value ~a ~%" IT))))))
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1275F079}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1275F305}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {1275F2E5}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {1275F079}>)
94: (ERROR UNBOUND-VARIABLE :NAME MY)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X0068E000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X0068E000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
106: (EVAL MY)
107: (INTERACTIVE-EVAL MY :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
my plus called 
; in: LAMBDA (#:G10286)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10286))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10286)))
;       RESTARTS)
; 
; caught WARNING:
;   undefined variable: RESTARTS
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     RESTARTS
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable RESTARTS is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10286)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10287)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {129F8301}>
;                                             :FRAME #:G10287)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10287)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10288)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12A1C971}>
;                                             :FRAME #:G10288)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10288)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10289)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12A428D1}>
;                                             :FRAME #:G10289)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10289)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10290)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12A696C1}>
;                                             :FRAME #:G10290)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10289)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A39371}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A3963D}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A3961D}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A39371}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A7000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A7000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10288)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A14C31}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A14EED}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A14ECD}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A14C31}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A5000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A5000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10287)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {129F1AA1}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129F1D4D}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129F1D2D}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {129F1AA1}>)
52: (ERROR UNBOUND-VARIABLE :NAME RESTARTS)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A3000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A3000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10286)) #<unavailable argument>)
64: (INTERACTIVE-EVAL RESTARTS :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT RESTARTS)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {129D0219}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129D04A5}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129D0485}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {129D0219}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A1000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A1000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
85: (EVAL MY)
86: (INTERACTIVE-EVAL MY :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10290)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10290)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A5FC91}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A5FF6D}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A5FF4D}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A5FC91}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A9000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A9000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10289)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A39371}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A3963D}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A3961D}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A39371}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A7000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A7000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10288)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A14C31}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A14EED}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12A14ECD}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12A14C31}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A5000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A5000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10287)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {129F1AA1}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129F1D4D}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129F1D2D}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE RESTARTS {129F1AA1}>)
73: (ERROR UNBOUND-VARIABLE :NAME RESTARTS)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A3000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A3000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10286)) #<unavailable argument>)
85: (INTERACTIVE-EVAL RESTARTS :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT RESTARTS)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {129D0219}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129D04A5}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {129D0485}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {129D0219}>)
94: (ERROR UNBOUND-VARIABLE :NAME MY)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006A1000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006A1000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
106: (EVAL MY)
107: (INTERACTIVE-EVAL MY :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

(SB-DEBUG::DEBUG-LOOP-FUN)
0[7] * 
debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
0] 
#S(PERSON :NAME "hot tian" :AGE 35 :STATUS "happy")
0] 
my plus called 
; in: LAMBDA (#:G10294)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10294))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10294)))
;       DEBUGGER)
; 
; caught WARNING:
;   undefined variable: DEBUGGER
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     DEBUGGER
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable DEBUGGER is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10294)) #<unavailable argument>)
0[2] 
my plus called 
; in: LAMBDA (#:G10295)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12BBBAC9}>
;                                             :FRAME #:G10295)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10295)) #<unavailable argument>)
0[3] 
my plus called 
; in: LAMBDA (#:G10296)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12BDF951}>
;                                             :FRAME #:G10296)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 3).
  1:         Reduce debugger level (to debug level 2).
  2:         Reduce debugger level (to debug level 1).
  3:         Exit debugger, returning to top level.

((LAMBDA (#:G10296)) #<unavailable argument>)
0[4] 
my plus called 
; in: LAMBDA (#:G10297)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12C05449}>
;                                             :FRAME #:G10297)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable MY is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 4).
  1:         Reduce debugger level (to debug level 3).
  2:         Reduce debugger level (to debug level 2).
  3:         Reduce debugger level (to debug level 1).
  4:         Exit debugger, returning to top level.

((LAMBDA (#:G10297)) #<unavailable argument>)
0[5] 
my plus called 
; in: LAMBDA (#:G10298)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12C2C291}>
;                                             :FRAME #:G10298)))
;       MY)
; 
; caught WARNING:
;   undefined variable: MY
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     MY
;   caught 1 WARNING condition
Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10297)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BFC369}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BFC635}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BFC615}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BFC369}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006BA000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006BA000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10296)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BD8609}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BD88C5}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BD88A5}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BD8609}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006B8000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006B8000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10295)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {12BB5989}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BB5C35}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BB5C15}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {12BB5989}>)
52: (ERROR UNBOUND-VARIABLE :NAME DEBUGGER)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006B6000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006B6000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10294)) #<unavailable argument>)
64: (INTERACTIVE-EVAL DEBUGGER :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT DEBUGGER)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12B81BA9}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12B81E35}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12B81E15}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12B81BA9}>)
73: (ERROR UNBOUND-VARIABLE :NAME MY)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006B4000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006B4000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
85: (EVAL MY)
86: (INTERACTIVE-EVAL MY :EVAL NIL)
87: (SB-IMPL::REPL-FUN NIL)
88: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
89: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
90: (SB-IMPL::TOPLEVEL-REPL NIL)
91: (SB-IMPL::TOPLEVEL-INIT)
92: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
93: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 5).
  1:         Reduce debugger level (to debug level 4).
  2:         Reduce debugger level (to debug level 3).
  3:         Reduce debugger level (to debug level 2).
  4:         Reduce debugger level (to debug level 1).
  5:         Exit debugger, returning to top level.

((LAMBDA (#:G10298)) #<unavailable argument>)
0[6] Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded.
0: ((LAMBDA (#:G10298)) #<unavailable argument>)
1: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
2: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
3: (SB-DEBUG::DEBUG-LOOP-FUN)
4: (INTERNAL-DEBUG)
5: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12C22579}>)
6: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
7: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12C22855}>)
8: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12C22835}>)
9: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12C22579}>)
10: (ERROR UNBOUND-VARIABLE :NAME MY)
11: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FD940) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006BC000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
12: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006BC000) #<unavailable argument>)
13: ("foreign function: call_into_lisp")
14: ("foreign function: funcall2")
15: ("foreign function: interrupt_internal_error")
16: ("foreign function: handle_trap")
17: ("foreign function: sigtrap_handler")
18: ("foreign function: signal_emulation_wrapper")
19: ("foreign function: stack_allocation_recover")
20: ("foreign function: stack_allocation_recover")
21: ((LAMBDA (#:G10297)) #<unavailable argument>)
22: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
23: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
24: (SB-DEBUG::DEBUG-LOOP-FUN)
25: (INTERNAL-DEBUG)
26: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BFC369}>)
27: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
28: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BFC635}>)
29: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BFC615}>)
30: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BFC369}>)
31: (ERROR UNBOUND-VARIABLE :NAME MY)
32: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE180) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006BA000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
33: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006BA000) #<unavailable argument>)
34: ("foreign function: call_into_lisp")
35: ("foreign function: funcall2")
36: ("foreign function: interrupt_internal_error")
37: ("foreign function: handle_trap")
38: ("foreign function: sigtrap_handler")
39: ("foreign function: signal_emulation_wrapper")
40: ("foreign function: stack_allocation_recover")
41: ("foreign function: stack_allocation_recover")
42: ((LAMBDA (#:G10296)) #<unavailable argument>)
43: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
44: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
45: (SB-DEBUG::DEBUG-LOOP-FUN)
46: (INTERNAL-DEBUG)
47: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BD8609}>)
48: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
49: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BD88C5}>)
50: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BD88A5}>)
51: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12BD8609}>)
52: (ERROR UNBOUND-VARIABLE :NAME MY)
53: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FE9C0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006B8000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
54: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006B8000) #<unavailable argument>)
55: ("foreign function: call_into_lisp")
56: ("foreign function: funcall2")
57: ("foreign function: interrupt_internal_error")
58: ("foreign function: handle_trap")
59: ("foreign function: sigtrap_handler")
60: ("foreign function: signal_emulation_wrapper")
61: ("foreign function: stack_allocation_recover")
62: ("foreign function: stack_allocation_recover")
63: ((LAMBDA (#:G10295)) #<unavailable argument>)
64: (INTERACTIVE-EVAL MY :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
65: (SB-DEBUG::DEBUG-EVAL-PRINT MY)
66: (SB-DEBUG::DEBUG-LOOP-FUN)
67: (INTERNAL-DEBUG)
68: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {12BB5989}>)
69: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
70: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BB5C35}>)
71: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12BB5C15}>)
72: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE DEBUGGER {12BB5989}>)
73: (ERROR UNBOUND-VARIABLE :NAME DEBUGGER)
74: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FF200) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006B6000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
75: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006B6000) #<unavailable argument>)
76: ("foreign function: call_into_lisp")
77: ("foreign function: funcall2")
78: ("foreign function: interrupt_internal_error")
79: ("foreign function: handle_trap")
80: ("foreign function: sigtrap_handler")
81: ("foreign function: signal_emulation_wrapper")
82: ("foreign function: stack_allocation_recover")
83: ("foreign function: stack_allocation_recover")
84: ((LAMBDA (#:G10294)) #<unavailable argument>)
85: (INTERACTIVE-EVAL DEBUGGER :EVAL #<FUNCTION SB-DEBUG::DEBUG-EVAL>)
86: (SB-DEBUG::DEBUG-EVAL-PRINT DEBUGGER)
87: (SB-DEBUG::DEBUG-LOOP-FUN)
88: (INTERNAL-DEBUG)
89: (SB-DEBUG::%INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12B81BA9}>)
90: ((LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX))
91: (SB-IMPL::CALL-WITH-SANE-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12B81E35}>)
92: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-DEBUG::FUNCALL-WITH-DEBUG-IO-SYNTAX) {12B81E15}>)
93: (INVOKE-DEBUGGER #<UNBOUND-VARIABLE MY {12B81BA9}>)
94: (ERROR UNBOUND-VARIABLE :NAME MY)
95: (SB-KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER #<unavailable argument> #.(SB-SYS:INT-SAP #X019FFAA0) #<SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #X006B4000 :TYPE (* (STRUCT SB-VM::OS-CONTEXT-T-STRUCT))> (16))
96: (SB-KERNEL:INTERNAL-ERROR #.(SB-SYS:INT-SAP #X006B4000) #<unavailable argument>)
97: ("foreign function: call_into_lisp")
98: ("foreign function: funcall2")
99: ("foreign function: interrupt_internal_error")
100: ("foreign function: handle_trap")
101: ("foreign function: sigtrap_handler")
102: ("foreign function: signal_emulation_wrapper")
103: ("foreign function: stack_allocation_recover")
104: ("foreign function: stack_allocation_recover")
105: (SB-INT:SIMPLE-EVAL-IN-LEXENV MY #<NULL-LEXENV>)
106: (EVAL MY)
107: (INTERACTIVE-EVAL MY :EVAL NIL)
108: (SB-IMPL::REPL-FUN NIL)
109: ((LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL))
110: (SB-IMPL::%WITH-REBOUND-IO-SYNTAX #<CLOSURE (LAMBDA NIL :IN SB-IMPL::TOPLEVEL-REPL) {12ED85D5}>)
111: (SB-IMPL::TOPLEVEL-REPL NIL)
112: (SB-IMPL::TOPLEVEL-INIT)
113: ((FLET #:WITHOUT-INTERRUPTS-BODY-222031 :IN SAVE-LISP-AND-DIE))
114: ((LABELS SB-IMPL::RESTART-LISP :IN SAVE-LISP-AND-DIE))

debugger invoked on a SIMPLE-ERROR: Maximum error nesting depth exceeded

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 6).
  1:         Reduce debugger level (to debug level 5).
  2:         Reduce debugger level (to debug level 4).
  3:         Reduce debugger level (to debug level 3).
  4:         Reduce debugger level (to debug level 2).
  5:         Reduce debugger level (to debug level 1).
  6:         Exit debugger, returning to top level.

((DEFMACRO PAT-MATCH) (PAT-MATCH (?X ?Y (?W _)) (1 2 (3 4)) (FORMAT T "x:~a,y:~a:w:~a ~%" ?X ?Y ?W)) #<unavailable argument>)
0[7] ; 
; compilation unit aborted
;   caught 1 fatal ERROR condition
* 
debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  illegal terminating character after a colon: #\

    File-Position: 282050

    Stream: #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {12CACDA1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {12CACDA1}>
 "illegal terminating character after a colon: ~S"
 #\ )
0] 
my plus called 
; in: LAMBDA (#:G10300)
;     (SYMBOL-MACROLET ((SB-IMPL::ARGS
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::ARGS 0 {11DA43F1}>
;                         #:G10300))
;                       (SB-IMPL::CONTROL
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-IMPL::CONTROL 0
;                            {11DA43C1}>
;                         #:G10300))
;                       (STREAM
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR STREAM 0 {11DA43A1}>
;                         #:G10300)))
;       DEBUGGER)
; 
; caught WARNING:
;   undefined variable: DEBUGGER
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     DEBUGGER
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable DEBUGGER is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10300)) #<unavailable argument>)
0[2] 

my plus called 
; in: LAMBDA (#:G10301)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI::DEBUG-SIGNAL 'SB-DI:INVALID-VALUE :DEBUG-VAR
;                                             '#<SB-DI::COMPILED-DEBUG-VAR
;                                                SB-DEBUG::ARG-0 0 {12D62FC1}>
;                                             :FRAME #:G10301)))
;       TYPE)
; 
; caught WARNING:
;   undefined variable: TYPE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     TYPE
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable TYPE is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 2).
  1:         Reduce debugger level (to debug level 1).
  2:         Exit debugger, returning to top level.

((LAMBDA (#:G10301)) #<unavailable argument>)
0[3] abort

0[2] abort

0] abort
* 
debugger invoked on a UNBOUND-VARIABLE: The variable [ABORT] is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV [ABORT] #<NULL-LEXENV>)
0] abort

* 
debugger invoked on a UNBOUND-VARIABLE: The variable EXIT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV EXIT #<NULL-LEXENV>)
0] abort

* 
debugger invoked on a UNBOUND-VARIABLE: The variable DEBUGGER is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV DEBUGGER #<NULL-LEXENV>)
0] abort

* 
debugger invoked on a SB-INT:SIMPLE-READER-ERROR:
  Comma not inside a backquote.

    File-Position: 282561

    Stream: #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {12CACDA1}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-READER-ERROR
 #<SYNONYM-STREAM :SYMBOL SB-SYS:*STDIN* {12CACDA1}>
 "Comma not inside a backquote.")
0] abort

* 
debugger invoked on a UNBOUND-VARIABLE: The variable RETURNING is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV RETURNING #<NULL-LEXENV>)
0] abort

* 
debugger invoked on a UNBOUND-VARIABLE: The variable TO is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV TO #<NULL-LEXENV>)
0] 




quit

my plus called 
; in: LAMBDA (#:G10302)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10302))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10302)))
;       QUIT)
; 
; caught WARNING:
;   undefined variable: QUIT
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     QUIT
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable QUIT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10302)) #<unavailable argument>)
0[2] abort

0] abort
* 
debugger invoked on a UNBOUND-VARIABLE: The variable TOP is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV TOP #<NULL-LEXENV>)
0] abort

* 
debugger invoked on a UNBOUND-VARIABLE: The variable LEVEL. is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV LEVEL. #<NULL-LEXENV>)
0] quit

my plus called 
; in: LAMBDA (#:G10303)
;     (SYMBOL-MACROLET ((SB-DEBUG::ARG-0
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-0 0
;                            {13AD1CC9}>
;                         #:G10303))
;                       (SB-DEBUG::ARG-1
;                        (SB-DI:DEBUG-VAR-VALUE
;                         '#<SB-DI::COMPILED-DEBUG-VAR SB-DEBUG::ARG-1 0
;                            {13AD1CE9}>
;                         #:G10303)))
;       QUIT)
; 
; caught WARNING:
;   undefined variable: QUIT
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     QUIT
;   caught 1 WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable QUIT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G10303)) #<unavailable argument>)
0[2] 0

0] 0
*      (mp (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z)                NIL))

debugger invoked on a UNBOUND-VARIABLE: The variable PATH is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MATCH1
 ((?Z (ELT #:G10304 2)))
 (FORMAT T "x:~a, y:~a, z:~a ~%" ?X ?Y ?Z)
 (#:G10305))
0] abort

* (load "embeded.lisp")
my plus called 

; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (DEFUN INTERPRET-NOT (CLAUSES BINDS)
;       (IF (INTERPRET-QUERY CLAUSE BINDS)
;           NIL
;           (LIST BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA INTERPRET-NOT
;         (CLAUSES BINDS)
;       (BLOCK INTERPRET-NOT
;         (IF (INTERPRET-QUERY CLAUSE BINDS)
;             NIL
;             (LIST BINDS))))
; 
; caught STYLE-WARNING:
;   The variable CLAUSES is defined but never used.


; file: /Users/apple/work_foot/lisp_field/embeded.lisp
my plus called 
; in: DEFUN INTERPRET-NOT
;     (INTERPRET-QUERY CLAUSE BINDS)
; 
; caught WARNING:
;   undefined variable: CLAUSE
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     CLAUSE
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-MATRIX
;     (SETQ COL -1)
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (macroexpand '(if-match (?x ?y ?z) (1 2 3) (format t "x:~a,y:~a,z:~a ~%" ?x ?y ?z)))
my plus called 
; in:
;      MACROEXPAND (IF-MATCH (?X ?Y ?Z) (1 2 3)
;                        (FORMAT T "x:~a,y:~a,z:~a ~%" ?X ?Y ?Z))
;     (1 2 3)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (1 2 3)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (if-match (?x ?y ?z) (1 2 3) (format t "x:~a,y:~a,z:~a ~%" ?x ?y ?z))

(LET ((?Z '#:G10435) (?Y '#:G10436) (?X '#:G10437))
  (PAT-MATCH (?X ?Y ?Z) (1 2 3) (FORMAT T "x:~a,y:~a,z:~a ~%" ?X ?Y ?Z) NIL))
T
* (if-match (?x ?y ?z) '(1 2 3) (format t "x:~a,y:~a,z:~a ~%" ?x ?y ?z))
my plus called 
; in: IF-MATCH (?X ?Y ?Z)
;     (1 2 3)
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (1 2 3)
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (if-match (?x ?y ?z ?z) '(1 2 3 4) (format t "x:~a,y:~a,z:~a ~%" ?x ?y ?z))
x:1,y:2,z:3 
NIL
* (if-match (?x ?y ?z ?z) '(1 2 3 4) (format t "x:~a,y:~a,z:~a ~%" ?x ?y ?z))

NIL
* (load "embeded.lisp")
my plus called 
; 
; caught WARNING:
;   undefined variable: COL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COL
;   caught 1 WARNING condition
T
* (load "embeded.lisp")
my plus called 
T
* (clear-db)

#<HASH-TABLE :TEST EQL :COUNT 0 {142BDDC9}>
* (fact painter tian xie chinese)

(TIAN XIE CHINESE)
* (fact painter cheyue xie chinese)

(CHEYUE XIE CHINESE)
* (fact painter xueteng hou chinese)

(XUETENG HOU CHINESE)
* (fact dates tian 1977 2072)

(TIAN 1977 2072)
* (fact dates cheyue 2007 2102)

(CHEYUE 2007 2102)
* (fact xueteng 1975 2072)

(1975 2072)
* (fact xueteng 1975 2072)

(1975 2072)
* (fact nobody 1975 2072)

(1975 2072)
* (with-answer (painter ?x xie ?y)
	       (princ (list ?x ?y)))
(XIE CHINESE)
NIL
* (mp (with-answer (painter ?x xie ?y)
	       (princ (list ?x ?y))))
(CHEYUE CHINESE)(TIAN CHINESE)
NIL
* (mp (with-answer (painter ?x xie ?y)
	       (princ (list ?x ?y))))

(DOLIST (#:G10705 (INTERPRET-QUERY '(PAINTER ?X XIE ?Y)))
  (LET ((?Y (BINDING '?Y #:G10705)) (?X (BINDING '?X #:G10705)))
    (PRINC (LIST ?X ?Y))))
T
* (mp (interpret-query '(painter ?x xie ?y)))

(((?Y . CHINESE) (?X . CHEYUE)) ((?Y . CHINESE) (?X . TIAN)))
* (mp (interpret-query '(painter ?x xie ?y)))

(INTERPRET-QUERY '(PAINTER ?X XIE ?Y))
NIL
* (load "embeded.lisp")
my plus called 

my plus called 
; in: DEFMACRO WITH-ANSWER-C
;     (COMPILE-QUERY QUERY `(PROGN @ ,BODY))
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-QUERY
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     COMPILE-QUERY
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN COMPILE-QUERY
;     (COMPILE-AND (CDR Q) BODY)
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-AND

;     (COMPILE-NOT (CDR Q) BODY)
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-NOT

;     (COMPILE-OR (CDR Q) BODY)
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-OR

;     (COMPILE-SIMPLE Q BODY)
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-SIMPLE
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
my plus called 
;     COMPILE-AND COMPILE-NOT COMPILE-OR COMPILE-SIMPLE
;   caught 4 STYLE-WARNING conditions

my plus called 
; in: DEFUN COMPILE-OR
;     (GENSYSM)
; 
; caught STYLE-WARNING:
;   undefined function: GENSYSM
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     GENSYSM
;   caught 1 STYLE-WARNING condition
T
*(load "embeded.lisp") (load "embeded.lisp")
my plus called 
T
* (with-answer-c (painter ?x ?y ?z)
	       (format t "x:~a, y:~a" ?x ?y))

NIL
* (with-answer-c (painter ?x ?y ?z)
	       (format t "x:~a, y:~a" ?x ?y))
my plus called 
; in: WITH-ANSWER-C (PAINTER ?X ?Y ?Z)
;     ((FORMAT T "x:~a, y:~a" ?X ?Y))
; 
; caught ERROR:
;   illegal function call

;     (PAT-MATCH (?X ?Y ?Z) #:G10968 (PROGN @ ((FORMAT T "x:~a, y:~a" ?X ?Y))) NIL)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> LABELS LET IF LET IF 
; ==>
;   (LET ((?X #:G7))
;     (LET ((#:G6 (ELT #:G3 1)))
;       (IF (OR (GENSYM? ?Y) (EQUAL ?Y #:G6))
;           (LET (#)
;             (LET #
;               #))
;           (#:G4))))
; 
; caught STYLE-WARNING:
;   The variable ?X is defined but never used.

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> LABELS LET IF LET IF LET LET IF 
; ==>
;   (LET ((?Y #:G6))
;     (LET ((#:G5 (ELT #:G3 2)))
;       (IF (OR (GENSYM? ?Z) (EQUAL ?Z #:G5))
;           (LET (#)
;             (PROGN @ #))
;           (#:G4))))
; 
; caught STYLE-WARNING:
;   The variable ?Y is defined but never used.

my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> LABELS LET IF LET IF LET LET IF LET LET IF 
; ==>
;   (LET ((?Z #:G5))
;     (PROGN @ ((FORMAT T "x:~a, y:~a" ?X ?Y))))
; 
; caught STYLE-WARNING:
;   The variable ?Z is defined but never used.

my plus called 
; in: WITH-ANSWER-C (PAINTER ?X ?Y ?Z)
;     (PROGN @ ((FORMAT T "x:~a, y:~a" ?X ?Y)))
; 
; caught WARNING:
;   undefined variable: @
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     @
;   caught 1 ERROR condition
;   caught 1 WARNING condition
;   caught 3 STYLE-WARNING conditions

debugger invoked on a UNBOUND-VARIABLE: The variable @ is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (load "embeded.lisp")
my plus called 
T
* (with-answer-c (painter ?x ?y 1975)
	       (format t "x:~a, y:~a" ?x ?y))
my plus called 
; in: WITH-ANSWER-C (PAINTER ?X ?Y ?Z)
;     (PAT-MATCH (?X ?Y ?Z) #:G11101 (PROGN (FORMAT T "x:~a, y:~a" ?X ?Y)) NIL)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> LABELS LET IF LET IF LET LET IF LET LET IF 
; ==>
;   (LET ((?Z #:G5))
;     (PROGN (FORMAT T "x:~a, y:~a" ?X ?Y)))
; 
; caught STYLE-WARNING:
;   The variable ?Z is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
x:XUETENG, y:HOUx:CHEYUE, y:XIEx:TIAN, y:XIE
NIL
* (with-answer-c (painter ?x xie ?z)
	       (format t "x:~a, y:~a" ?x ?y))

NIL
* (with-answer-c (painter ?x 'xie ?z)
	       (format t "x:~a, y:~a" ?x ?y))
my plus called 
; in: WITH-ANSWER-C (PAINTER ?X XIE ?Z)
;     (PAT-MATCH (?X XIE ?Z) #:G11108 (PROGN (FORMAT T "x:~a, y:~a" ?X ?Y)) NIL)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> LABELS LET IF LET IF LET IF LET IF 
; ==>
;   (LET ((?Z #:G5))
;     (PROGN (FORMAT T "x:~a, y:~a" ?X ?Y)))
; 
; caught STYLE-WARNING:
;   The variable ?Z is defined but never used.

my plus called 
; in: WITH-ANSWER-C (PAINTER ?X XIE ?Z)
;     (FORMAT T "x:~a, y:~a" ?X ?Y)
; 
; caught WARNING:
;   undefined variable: ?Y

;     (PAT-MATCH (?X XIE ?Z) #:G11108 (PROGN (FORMAT T "x:~a, y:~a" ?X ?Y)) NIL)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> LABELS LET IF LET IF LET IF 
; ==>
;   (EQUAL XIE (ELT #:G3 1))
; 
; caught WARNING:
;   undefined variable: XIE
; 
; compilation unit finished
;   Undefined variables:
my plus called 
my plus called 
;     ?Y XIE
;   caught 2 WARNING conditions
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable XIE is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (with-answer-c (painter ?x 'xie ?z)
	       (format t "x:~a, y:~a" ?x ?z))
my plus called 
; in: WITH-ANSWER-C (PAINTER ?X 'XIE ?Z)
;     (PAT-MATCH (?X 'XIE ?Z) #:G11111 (PROGN (FORMAT T "x:~a, y:~a" ?X ?Y)) NIL)
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
; --> LABELS LET IF LET IF LET IF LET IF 
; ==>
;   (LET ((?Z #:G5))
;     (PROGN (FORMAT T "x:~a, y:~a" ?X ?Y)))
; 
; caught STYLE-WARNING:
;   The variable ?Z is defined but never used.

my plus called 
; in: WITH-ANSWER-C (PAINTER ?X 'XIE ?Z)
;     (FORMAT T "x:~a, y:~a" ?X ?Y)
; 
; caught WARNING:
;   undefined variable: ?Y
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     ?Y
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable ?Y is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (with-answer-c (painter ?x ?z 1975)
	       (format t "x:~a, y:~a" ?x ?z))
x:CHEYUE, y:CHINESEx:TIAN, y:CHINESE
NIL
* (with-answer-c (painter ?x ?y ?z)
	       (format t "x:~a, y:~a, z:~a ~%" ?x ?y ?z))

NIL
* (with-answer-c (dates ?x ?y ?z)
	       (format t "x:~a, y:~a, z:~a ~%" ?x ?y ?z))
x:XUETENG, y:HOU, z:CHINESE 
x:CHEYUE, y:XIE, z:CHINESE 
x:TIAN, y:XIE, z:CHINESE 
NIL
* (with-answer-c (dates ?x 1975 ?z)
	       (format t "x:~a, z:~a ~%" ?x ?z))
x:CHEYUE, y:2007, z:2102 
x:TIAN, y:1977, z:2072 
NIL
*(mp (with-answer-c (dates ?x 1977 ?z)
	       (format t "x:~a, z:~a ~%" ?x ?z)))

NIL
* (with-answer-c (dates ?x 1977 ?z)
	       (format t "x:~a, z:~a ~%" ?x ?z))
x:TIAN, z:2072 
NIL
* (mp (with-answer-c (dates ?x 1977 ?z)
	       (format t "x:~a, z:~a ~%" ?x ?z)))

(WITH-GENSYMS (?Z ?X)
  (DOLIST (#:G11134 (DB-QUERY 'DATES))
    (PAT-MATCH (?X 1977 ?Z) #:G11134 (PROGN (FORMAT T "x:~a, z:~a ~%" ?X ?Z))
               NIL)))
T
* (load "clcont.lisp")


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition

my plus called 
; in: SETQ *SAVED*
;     (SETQ *SAVED* NIL)
; 
; caught WARNING:
;   undefined variable: *SAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN DFT-NODE
;     (PUSH #'(LAMBDA () (DFT-NODE (CDR TREE))) *SAVED*)
my plus called 
; --> LET* 
; ==>
;   (SETQ *SAVED* #:NEW0)
; 
; caught WARNING:
;   undefined variable: *SAVED*

;     (RESTART)
; 
; caught WARNING:
;   The function RESTART is undefined, and its name is reserved by ANSI CL so that
;   even if it were defined later, the code doing so would not be portable.
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     RESTART
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 2 WARNING conditions
;   caught 1 STYLE-WARNING condition
my plus called 

debugger invoked on a SYMBOL-PACKAGE-LOCKED-ERROR:
  Lock on package COMMON-LISP violated when defining RESTART as a macro while
  in package COMMON-LISP-USER.
See also:
  The SBCL Manual, Node "Package Locks"
  The ANSI Standard, Section 11.1.2.1.2

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE      ] Ignore the package lock.
  1: [IGNORE-ALL    ] Ignore all package locks in the context of this operation.
  2: [UNLOCK-PACKAGE] Unlock the package.
  3: [RETRY         ] Retry EVAL of current toplevel form.
  4:                  Ignore error and continue loading file "/Users/apple/work_foot/lisp_field/clcont.lisp".
  5: [ABORT         ] Abort loading file "/Users/apple/work_foot/lisp_field/clcont.lisp".
  6:                  Exit debugger, returning to top level.

(PACKAGE-LOCK-VIOLATION
 #<PACKAGE "COMMON-LISP">
 :SYMBOL
 RESTART
 :FORMAT-CONTROL
 "defining ~S as a macro"
 :FORMAT-ARGUMENTS
 (RESTART))
0] abort
T
* (load "clcont.lisp")

my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition

my plus called 
; in: SETQ *SAVED*
;     (SETQ *SAVED* NIL)
; 
; caught WARNING:
;   undefined variable: *SAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN DFT-NODE
;     (PUSH #'(LAMBDA () (DFT-NODE (CDR TREE))) *SAVED*)
my plus called 
; --> LET* 
; ==>
;   (SETQ *SAVED* #:NEW0)
; 
; caught WARNING:
;   undefined variable: *SAVED*

;     (RESTART-C)
; 
; caught STYLE-WARNING:
;   undefined function: RESTART-C
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     RESTART-C
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions
my plus called 
STYLE-WARNING:
   RESTART-C is being redefined as a macro when it was previously assumed to be a function.

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN RESTART-C
;     (IF *SAVED*
;         (FUNCALL (POP *SAVED*))
;         (=VALUES 'DONE))
; 
; caught WARNING:
;   undefined variable: *SAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN DFT2
;     (SETQ *SAVED* NIL)
; 
; caught WARNING:
;   undefined variable: *SAVED*

;     (RESTART)
; 
; caught WARNING:
;   The function RESTART is undefined, and its name is reserved by ANSI CL so that
;   even if it were defined later, the code doing so would not be portable.
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     RESTART
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 2 WARNING conditions
;   caught 2 STYLE-WARNING conditions
T
* (load "clcont.lisp")

my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition

my plus called 
; in: SETQ *SAVED*
;     (SETQ *SAVED* NIL)
; 
; caught WARNING:
;   undefined variable: *SAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN DFT-NODE
;     (PUSH #'(LAMBDA () (DFT-NODE (CDR TREE))) *SAVED*)
my plus called 
; --> LET* 
; ==>
;   (SETQ *SAVED* #:NEW0)
; 
; caught WARNING:
;   undefined variable: *SAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN RESTART-C
;     (IF *SAVED*
;         (FUNCALL (POP *SAVED*))
;         (=VALUES 'DONE))
; 
; caught WARNING:
;   undefined variable: *SAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN DFT2
;     (SETQ *SAVED* NIL)
; 
; caught WARNING:
;   undefined variable: *SAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *SAVED*
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions
T
* (defvar *tree*)

*TREE*
* (setf *tree* '(1 2 (3 4 (5 6) 7 8) 9 10))

(1 2 (3 4 (5 6) 7 8) 9 10)
* (my-dft *tree*)

1
* (progn (restart-c) (format t "Not suppose to show ~%"))
my plus called 
; in: (RESTART-C) (FORMAT T "Not suppose to show ~%")
;     ((RESTART-C) (FORMAT T "Not suppose to show ~%"))
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((RESTART-C) (FORMAT T Not suppose to show ~%))
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (progn (restart-c) (format t "Not suppose to show ~%"))
Not suppose to show 
NIL
* (defvar *saved*)

*SAVED*
* *saved*

(#<CLOSURE (LAMBDA # :IN =DFT-NODE) {136EB12D}>)
* (start-c)

my plus called 
; in: START-C
;     (START-C)
; 
; caught STYLE-WARNING:
;   undefined function: START-C
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     START-C
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::START-C is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (restart-c)

3
* (restart-c)

4
* (progn (restart-c) (format t "hide"))
hide
NIL
* (progn (princ (restart-c)) (format t "hide"))
6hide
NIL
* (load "clcont.lisp")


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

debugger invoked on a UNBOUND-VARIABLE: The variable *MY-SAVED* is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [RETRY   ] Retry EVAL of current toplevel form.
  1: [CONTINUE] Ignore error and continue loading file "/Users/apple/work_foot/lisp_field/clcont.lisp".
  2: [ABORT   ] Abort loading file "/Users/apple/work_foot/lisp_field/clcont.lisp".
  3:            Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV *MY-SAVED* #<NULL-LEXENV>)
0] abort
T
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

my plus called 
; in: DEFUN MY-DFT
;     (MY-RESTART)
; 
; caught STYLE-WARNING:
;   undefined function: MY-RESTART
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MY-RESTART
;   caught 1 STYLE-WARNING condition
T
* (my-dft *tree*)

debugger invoked on a UNBOUND-VARIABLE: The variable *MY-SAVED* is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MY-DFT (1 2 (3 4 (5 6) 7 8) 9 10))
0] (defvar *my-saved*)

*MY-SAVED*
0] abort

* (defvar *my-saved*)

*MY-SAVED*
* (my-dft *tree*)

debugger invoked on a UNBOUND-VARIABLE: The variable *MY-SAVED* is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(MY-DFT (1 2 (3 4 (5 6) 7 8) 9 10))
0] abort

* (setq *my-saved* nil)

my plus called 
; in: SETQ *MYSAVED*
;     (SETQ *MYSAVED* NIL)
; 
; caught WARNING:
;   undefined variable: *MYSAVED*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *MYSAVED*
;   caught 1 WARNING condition
NIL
* (setq *my-saved* nil)

NIL
* (my-dft *tree*)

1
* (my-restart)

2
* (my-restart)

3
* (my-restart)

4
* (my-restart)

5
* (my-restart)

6
* (my-restart)

7
* (my-restart)

8
* (my-restart)

9
* (my-restart)

10
* (my-restart)

DONE
* (my-restart)

DONE
* (setq p1 1)

my plus called 
; in: SETQ P1
;     (SETQ P1 1)
; 
; caught WARNING:
;   undefined variable: P1
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     P1
;   caught 1 WARNING condition
1
* (defun test-refer(x)
    (princ (list x p1)))

debugger invoked on a SIMPLE-ERROR: not legal as a function name: (X)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:FUN-NAME-BLOCK-NAME (X))
0] abort

* (defun test-refer(x)
    (princ (list x p1)))

my plus called 
; in: DEFUN TEST-REFER
;     (LIST X P1)
; 
; caught WARNING:
;   undefined variable: P1
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     P1
;   caught 1 WARNING condition
TEST-REFER
* (test-refer 1)
(1 1)
(1 1)
* (setq q1 2)

my plus called 
; in: SETQ Q1
;     (SETQ Q1 2)
; 
; caught WARNING:
;   undefined variable: Q1
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     Q1
;   caught 1 WARNING condition
2
* (test-refer 5)
(1 1)
(1 1)
* 5

5
* (test-refer 5)
(5 1)
(5 1)
* (setq q1 10)

;     (SETQ Q1 10)
; 
; caught WARNING:
;   undefined variable: Q1
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     Q1
;   caught 1 WARNING condition
10
* (defvar q1)

Q1
* (setq q1 10)

10
* (test-refer 1)
(1 1)
(1 1)
* (load "clcont.lisp")


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

my plus called 
; in: DEFUN REV
;     (FUNCALL FN ATOM)
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FN) ATOM)
; 
; caught WARNING:
;   undefined variable: ATOM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     ATOM
;   caught 1 WARNING condition
T
* (if (atom? nil) t)

my plus called 
; in: IF (ATOM? NIL)
;     (ATOM? NIL)
; 
; caught STYLE-WARNING:
;   undefined function: ATOM?
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ATOM?
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::ATOM? is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (if (atom nil) t)

T
* (load "clcont.lisp")


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
T
* (rev '(1 2 3 4 5))

(5 4 3 2 1)
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
T
* (rev '(1 2 3 4 5))
Value:NILValue:(5)Value:(5 4)Value:(5 4 3)Value:(5 4 3 2)
(5 4 3 2 1)
* (catch *tiange*)

NIL
* (mp (catch *tiange*))

(CATCH *TIANGE*)
NIL
* (mp (when t ))

(IF T
    (PROGN T)
    NIL)
T
* (block (throw *x*) (catch *x* (format t "catch something")))
my plus called 
; in: BLOCK (THROW 'HERE)
;     (BLOCK (THROW 'HERE) (CATCH 'HERE (FORMAT T "catch something")))
; 
; caught ERROR:
;   The block name (THROW 'HERE) is not a symbol.
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (BLOCK (THROW 'HERE) (CATCH 'HERE (FORMAT T catch something)))
Compile-time error:
  The block name (THROW 'HERE) is not a symbol.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (block nil (throw *x*) (catch *x* (format t "catch something")))
my plus called 
; in: BLOCK (THROW *X*)
;     (BLOCK (THROW *X*) (CATCH *X* (FORMAT T "catch something")))
; 
; caught ERROR:
;   The block name (THROW *X*) is not a symbol.
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (BLOCK (THROW *X*) (CATCH *X* (FORMAT T catch something)))
Compile-time error:
  The block name (THROW *X*) is not a symbol.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (block nil (throw *x*) (catch *x* (format t "catch something")))
my plus called 
; in: BLOCK ()
;     (THROW *X*)
; 
; caught ERROR:
;   error while parsing arguments to special form THROW:
;     invalid number of elements in
;       (*X*)
;     to satisfy lambda list
;       (SB-C::TAG SB-C::RESULT):
;     exactly 2 expected, but 1 found
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (THROW *X*)
Compile-time error:
  error while parsing arguments to special form THROW:
  invalid number of elements in
    (*X*)
  to satisfy lambda list
    (SB-C::TAG SB-C::RESULT):
  exactly 2 expected, but 1 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (progn (throw *throwtag* nil) (catch *throwtag* (format t "catched")))
my plus called 
; in: PROGN (THROW *X*)
;     (THROW *X*)
; 
; caught ERROR:
;   error while parsing arguments to special form THROW:
;     invalid number of elements in
;       (*X*)
;     to satisfy lambda list
;       (SB-C::TAG SB-C::RESULT):
;     exactly 2 expected, but 1 found
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (THROW *X*)
Compile-time error:
  error while parsing arguments to special form THROW:
  invalid number of elements in
    (*X*)
  to satisfy lambda list
    (SB-C::TAG SB-C::RESULT):
  exactly 2 expected, but 1 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (progn (throw *x* nil) (catch *x* (format t "catched")))

debugger invoked on a SB-INT:SIMPLE-CONTROL-ERROR:
  attempt to THROW to a tag that does not exist: (50 450 101 4)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("no debug information for frame")
0] abort

* (defvar *throwtag*)

*THROWTAG*
* (setf *throwtag* "cool")

"cool"
* (progn (throw *throwtag* nil) (catch *throwtag* (format t "catched")))

debugger invoked on a SB-INT:SIMPLE-CONTROL-ERROR:
  attempt to THROW to a tag that does not exist: "cool"

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("no debug information for frame")
0] 
abort

* (setf *throwtag* (gensym))

#:G11412
* (let ((stag (gensym))) (progn (throw stag nil) (catch stag (format t "catched"))))

debugger invoked on a SB-INT:SIMPLE-CONTROL-ERROR:
  attempt to THROW to a tag that does not exist: #:G11412

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("no debug information for frame")
0] abort

* (let ((stag (gensym))) (progn (throw stag nil) (catch stag (format t "catched"))))

debugger invoked on a SB-INT:SIMPLE-CONTROL-ERROR:
  attempt to THROW to a tag that does not exist: #:G11413

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("no debug information for frame")
0] abort

* (defparameter *coolparm* nil)

debugger invoked on a SB-KERNEL::ARG-COUNT-ERROR:
  error while parsing arguments to DEFMACRO DEFPARAMETER:
    invalid number of elements in
      (*COOLPARM*)
    to satisfy lambda list
      (VAR SB-IMPL::VAL &OPTIONAL (SB-IMPL::DOC NIL SB-IMPL::DOCP)):
    between 2 and 3 expected, but 1 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (#:WHOLE268553 #:ENVIRONMENT268554)
   :IN
   "/Users/jwise/proj/sbcl/clean/1.0.55/sbcl-1.0.55-x86-darwin/src/cold/compile-cold-sbcl.lisp")
 (DEFPARAMETER *COOLPARM*)
 #<unavailable argument>)
0] abort

* (defparameter *coolparm* nil)

*COOLPARM*
* *coolparm*

NIL
* (setf *coolparm* 23)

23
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: DEFVAR *DEFAULT-PROC*
;     #'(LAMBDA (X) (FORMAT T "~%>> ") (PRINC (EVAL (READ))) (PICK-PROCESS))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.

my plus called 
; in: DEFVAR *DEFAULT-PROC*
;     (PICK-PROCESS)
; 
; caught STYLE-WARNING:
;   undefined function: PICK-PROCESS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     PICK-PROCESS
;   caught 2 STYLE-WARNING conditions

my plus called 
; in: DEFUN PICK-PROCESS
;     (MOST-URGENT-PROCESS)
; 
; caught STYLE-WARNING:
;   undefined function: MOST-URGENT-PROCESS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MOST-URGENT-PROCESS
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 178, Column: 31, File-Position: 4687

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/clcont.lisp"
                {128FE591}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/clcont.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/clcont.lisp"
   {128FE591}>
 4626)
0] abort
T
* (load "clcont.lisp")

my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

my plus called 
; in: DEFUN CB
;     (PUSH #'(LAMBDA () (CB FN (CDR CHOICES))) *PATHS*)
my plus called 
; --> LET* 
; ==>
;   (SETQ *PATHS* #:NEW0)
; 
; caught WARNING:
;   undefined variable: *PATHS*

;     (FAIL)
; 
; caught STYLE-WARNING:
;   undefined function: FAIL
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     FAIL
;   Undefined variable:
my plus called 
;     *PATHS*
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN FAIL
;     (IF *PATHS*
;         (FUNCALL (POP *PATHS*))
;         FAILSYM)
; 
; caught WARNING:
;   undefined variable: *PATHS*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *PATHS*
;   caught 1 WARNING condition
T
* (choose-bind x '(xie tian hou) (format nil "name:~a ~%" x))

debugger invoked on a UNBOUND-VARIABLE: The variable *PATHS* is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(CB #<FUNCTION (LAMBDA #) {1334CD1D}> (XIE TIAN HOU))
0] abort

* (load "clcont.lisp")

my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
T
* (choose-bind x '(xie tian hou) (format nil "name:~a ~%" x))

"name:XIE 
"
* (fail)

"name:TIAN 
"
* (fail)

"name:HOU 
"
* (fail)

@
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TOW-NUMBERS
;     (=DEFUN TOW-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TOW-NUMBERS
;         (*CONT*)
;       (BLOCK =TOW-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.

my plus called 
; in: =DEFUN PARLOR-TRICK
;     (TWO-NUMBERS)
; 
; caught STYLE-WARNING:
;   undefined function: TWO-NUMBERS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     TWO-NUMBERS
;   caught 5 STYLE-WARNING conditions
T
* (parlor-trick 11)

my plus called 
; in: PALOR-TRICK 11
;     (PALOR-TRICK 11)
; 
; caught STYLE-WARNING:
;   undefined function: PALOR-TRICK
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     PALOR-TRICK
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::PALOR-TRICK is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] par
; No debug variables for current frame: using EVAL instead of EVAL-IN-FRAME.

debugger invoked on a UNBOUND-VARIABLE: The variable PAR is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV PAR #<NULL-LEXENV>)
0[2] abort

0] abort
* (parlor-trick 11)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::TWO-NUMBERS is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (parlor-trick 11)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::TWO-NUMBERS is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (load "clcont.lisp")


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TOW-NUMBERS
;     (=DEFUN TOW-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TOW-NUMBERS
;         (*CONT*)
;       (BLOCK =TOW-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.

my plus called 
; in: =DEFUN PARLOR-TRICK
;     (TWO-NUMBERS)
; 
; caught STYLE-WARNING:
;   undefined function: TWO-NUMBERS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     TWO-NUMBERS
;   caught 5 STYLE-WARNING conditions
T
* (parlor-trick 11)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::TWO-NUMBERS is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort

* (load "ctcont.lisp")

debugger invoked on a SB-INT:SIMPLE-FILE-ERROR:
  Couldn't load "ctcont.lisp": file does not exist.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(LOAD
 "ctcont.lisp"
 :VERBOSE
 NIL
 :PRINT
 NIL
 :IF-DOES-NOT-EXIST
 T
 :EXTERNAL-FORMAT
 :DEFAULT)
0] abort

* (load "clcont.lisp")

my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
STYLE-WARNING:
   TWO-NUMBERS is being redefined as a macro when it was previously assumed to be a function.

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
T
* (parlor-trick 11)

(THE SUM OF 5 6)
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (PROGN
;          (FORMAT T "n1: ~a, n2:~a ~%" N1 N1)
;          (IF (= # SUM)
;              `(THE SUM OF ,N1 ,N2)
;              (FAIL)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (PROGN
;            (FORMAT T "n1: ~a, n2:~a ~%" N1 N1)
;            (IF #
;                `#
;                #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (PROGN
;        (FORMAT T "n1: ~a, n2:~a ~%" N1 N1)
;        (IF (= (+ N1 N2) SUM)
;            `(THE SUM OF ,N1 ,N2)
;            (FAIL))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (N1 N2) (PROGN # #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (PROGN
;          (FORMAT T "n1: ~a, n2:~a ~%" N1 N1)
;          (IF (= # SUM)
;              `(THE SUM OF ,N1 ,N2)
;              (FAIL)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (PROGN
;            (FORMAT T "n1: ~a, n2:~a ~%" N1 N1)
;            (IF #
;                `#
;                #)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
T
* (palor-trick 11)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::PALOR-TRICK is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-FUNCTION PALOR-TRICK)
0] abort

* (parlor-trick 11)
n1: 0, n2:0 
n1: 0, n2:0 
n1: 0, n2:0 
n1: 0, n2:0 
n1: 0, n2:0 
n1: 0, n2:0 
n1: 0, n2:0 
n1: 1, n2:1 
n1: 1, n2:1 
n1: 1, n2:1 
n1: 1, n2:1 
n1: 1, n2:1 
n1: 1, n2:1 
n1: 1, n2:1 
n1: 2, n2:2 
n1: 2, n2:2 
n1: 2, n2:2 
n1: 2, n2:2 
n1: 2, n2:2 
n1: 2, n2:2 
n1: 2, n2:2 
n1: 3, n2:3 
n1: 3, n2:3 
n1: 3, n2:3 
n1: 3, n2:3 
n1: 3, n2:3 
n1: 3, n2:3 
n1: 3, n2:3 
n1: 4, n2:4 
n1: 4, n2:4 
n1: 4, n2:4 
n1: 4, n2:4 
n1: 4, n2:4 
n1: 4, n2:4 
n1: 4, n2:4 
n1: 5, n2:5 
n1: 5, n2:5 
n1: 5, n2:5 
n1: 5, n2:5 
n1: 5, n2:5 
n1: 5, n2:5 
n1: 5, n2:5 
(THE SUM OF 5 6)
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (PROGN
;          (FORMAT T "n1: ~a, n2:~a ~%" N1 N2)
;          (IF (= # SUM)
;              `(THE SUM OF ,N1 ,N2)
;              (FAIL)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (PROGN
;            (FORMAT T "n1: ~a, n2:~a ~%" N1 N2)
;            (IF #
;                `#
;                #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (PROGN
;        (FORMAT T "n1: ~a, n2:~a ~%" N1 N2)
;        (IF (= (+ N1 N2) SUM)
;            `(THE SUM OF ,N1 ,N2)
;            (FAIL))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (N1 N2) (PROGN # #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (PROGN
;          (FORMAT T "n1: ~a, n2:~a ~%" N1 N2)
;          (IF (= # SUM)
;              `(THE SUM OF ,N1 ,N2)
;              (FAIL)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (PROGN
;            (FORMAT T "n1: ~a, n2:~a ~%" N1 N2)
;            (IF #
;                `#
;                #)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
T
* (parlor-trick 11)
n1: 0, n2:0 
n1: 0, n2:1 
n1: 0, n2:2 
n1: 0, n2:3 
n1: 0, n2:4 
n1: 0, n2:5 
n1: 0, n2:6 
n1: 1, n2:0 
n1: 1, n2:1 
n1: 1, n2:2 
n1: 1, n2:3 
n1: 1, n2:4 
n1: 1, n2:5 
n1: 1, n2:6 
n1: 2, n2:0 
n1: 2, n2:1 
n1: 2, n2:2 
n1: 2, n2:3 
n1: 2, n2:4 
n1: 2, n2:5 
n1: 2, n2:6 
n1: 3, n2:0 
n1: 3, n2:1 
n1: 3, n2:2 
n1: 3, n2:3 
n1: 3, n2:4 
n1: 3, n2:5 
n1: 3, n2:6 
n1: 4, n2:0 
n1: 4, n2:1 
n1: 4, n2:2 
n1: 4, n2:3 
n1: 4, n2:4 
n1: 4, n2:5 
n1: 4, n2:6 
n1: 5, n2:0 
n1: 5, n2:1 
n1: 5, n2:2 
n1: 5, n2:3 
n1: 5, n2:4 
n1: 5, n2:5 
n1: 5, n2:6 
(THE SUM OF 5 6)
* (defnode s (cat noun s2))

my plus called 
; in: DEFNODE S
;     (CAT NOUN S2)
; 
; caught STYLE-WARNING:
;   undefined function: CAT

;     (DEFNODE S (CAT NOUN S2))
; 
; caught STYLE-WARNING:
;   undefined function: DEFNODE

;     (CAT NOUN S2)
; 
; caught WARNING:
;   undefined variable: NOUN

;     (DEFNODE S (CAT NOUN S2))
; 
; caught WARNING:
;   undefined variable: S

;     (CAT NOUN S2)
; 
; caught WARNING:
;   undefined variable: S2
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     CAT DEFNODE
;   Undefined variables:
my plus called 
my plus called 
my plus called 
;     NOUN S S2
;   caught 3 WARNING conditions
;   caught 2 STYLE-WARNING conditions

debugger invoked on a UNBOUND-VARIABLE: The variable S is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (defnode s)

debugger invoked on a UNBOUND-VARIABLE: The variable S is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:SIMPLE-EVAL-IN-LEXENV S #<NULL-LEXENV>)
0] abort

* (defnode (gensym))

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::DEFNODE is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-FUNCTION DEFNODE)
0] abort

* (defun trace-test(x y)
    (format t "first sentence ~%")
    (trace =mods)
    (format t "second sentence ~%")
    )
my plus called 
; in: DEFUN TRACE-TEST
;     (SB-INT:NAMED-LAMBDA TRACE-TEST
;         (X Y)
;       (BLOCK TRACE-TEST
;         (FORMAT T "first sentence ~%")
;         (TRACE)
;         (FORMAT T "second sentence ~%")))
; ==>
;   #'(SB-INT:NAMED-LAMBDA TRACE-TEST
;         (X Y)
;       (BLOCK TRACE-TEST
;         (FORMAT T "first sentence ~%")
;         (TRACE)
;         (FORMAT T "second sentence ~%")))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
TRACE-TEST
* (trace-test 10 20)
first sentence 
second sentence 
NIL
* (defun trace-test(x y)
    (format t "first sentence ~%")
    (trace =mods)
    (format t "second sentence ~%")
    )
my plus called 
; in: DEFUN TRACE-TEST
;     (SB-INT:NAMED-LAMBDA TRACE-TEST
;         (X Y)
;       (BLOCK TRACE-TEST
;         (FORMAT T "first sentence ~%")
;         (TRACE =MODS)
;         (FORMAT T "second sentence ~%")))
; ==>
;   #'(SB-INT:NAMED-LAMBDA TRACE-TEST
;         (X Y)
;       (BLOCK TRACE-TEST
;         (FORMAT T "first sentence ~%")
;         (TRACE =MODS)
;         (FORMAT T "second sentence ~%")))
; 
; caught STYLE-WARNING:
;   The variable X is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable Y is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
STYLE-WARNING: redefining COMMON-LISP-USER::TRACE-TEST in DEFUN
TRACE-TEST
* (trace-test)

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  invalid number of arguments: 0

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(TRACE-TEST)[:EXTERNAL]
0] abort

* (trace-test 10 20)
first sentence 
WARNING: COMMON-LISP-USER::=MODS is undefined, not tracing.
second sentence 
NIL
* (defvar *test-arr* '(1 2 3 4 5))

*TEST-ARR*
* (setf *test-arr* (cons (cons 'cool (car *test-arr*)) (cdr *test-arr*)))

((COOL . 1) 2 3 4 5)
* (binding 'x '((x y) ((y) z) (z g)))

(Y)
(X Y)
* (binding 'x '((x y) ((y) z) (z g)))

(Y)
(X Y)
* (binding '?x '((?x (?z . ?y) (?y boo)))

(?Y)
(?X ?Y)
* '((?x (?z . ?y) (?y boo)))

((?X (?Z . ?Y) (?Y BOO)))
* '((?x (?z . ?y) (?y boo)))

((?X (?Z . ?Y) (?Y BOO)))
* (intern "cool")

|cool|
NIL
* (symbolp (intern "cool"))

T
* (symbolp "cool")

NIL
* (symbolp (intern "anything))
"))

T
* (setq cool 10)

my plus called 
; in: SETQ COOL
;     (SETQ COOL 10)
; 
; caught WARNING:
;   undefined variable: COOL
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     COOL
;   caught 1 WARNING condition
10
* (load "clcont.lisp")


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    unmatched close parenthesis

      Line: 247, Column: 15, File-Position: 6669

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/clcont.lisp"
                {12320B81}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/clcont.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/clcont.lisp"
   {12320B81}>
 6669)
0] abort
T
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
STYLE-WARNING:
   DEFNODE is being redefined as a macro when it was previously assumed to be a function.

my plus called 
; in: DEFMACRO DOWN
;     (COMPILE-CMDS CMDS)
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-CMDS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     COMPILE-CMDS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO CAT
;     (COMPILE-CMDS CMDS)
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-CMDS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     COMPILE-CMDS
;   caught 1 STYLE-WARNING condition
STYLE-WARNING:
   CAT is being redefined as a macro when it was previously assumed to be a function.

my plus called 
; in: DEFMACRO JUMP
;     (COMPILE-CMDS CMDS)
; 
; caught STYLE-WARNING:
;   undefined function: COMPILE-CMDS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     COMPILE-CMDS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO WITH-INFERENCE
;     (REP_ QUERY)
; 
; caught STYLE-WARNING:
;   undefined function: REP_
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     REP_
;   caught 1 STYLE-WARNING condition
STYLE-WARNING: redefining COMMON-LISP-USER::VARSYM? in DEFUN
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-QUERY
;     (=DEFUN PROVE-QUERY
;         (EXPR BINDS)
;       (CASE (CAR EXPR)
;         (AND (PROVE-AND (CDR EXPR) BINDS))
;         (OR (PROVE-OR (CDR EXPR) BINDS))
;         (NOT (PROVE-NOT (CDR EXPR) BINDS))
;         (T (PROVE-SIMPLE EXPR BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-QUERY
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-QUERY
;         (CASE (CAR EXPR)
;           (AND (PROVE-AND # BINDS))
;           (OR (PROVE-OR # BINDS))
;           (NOT (PROVE-NOT # BINDS))
;           (T (PROVE-SIMPLE EXPR BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.

my plus called 
; in: =DEFUN PROVE-QUERY
;     (PROVE-AND (CDR EXPR) BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: PROVE-AND

;     (PROVE-NOT (CDR EXPR) BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: PROVE-NOT

;     (PROVE-OR (CDR EXPR) BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: PROVE-OR

;     (PROVE-SIMPLE EXPR BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: PROVE-SIMPLE
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
my plus called 
;     PROVE-AND PROVE-NOT PROVE-OR PROVE-SIMPLE
;   caught 6 STYLE-WARNING conditions
my plus called 
STYLE-WARNING:
   PROVE-AND is being redefined as a macro when it was previously assumed to be a function.

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-AND
;     (=DEFUN PROVE-AND
;         (CLAUSES BINDS)
;       (IF (NULL CLAUSES)
;           (=VALUES BINDS)
;           (=BIND (BINDS)
;               (PROVE-QUERY (CAR CLAUSES) BINDS)
;             (PROVE-AND (CDR CLAUSES) BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-AND
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-AND
;         (IF (NULL CLAUSES)
;             (=VALUES BINDS)
;             (=BIND (BINDS)
;                 (PROVE-QUERY # BINDS)
;               (PROVE-AND # BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (BINDS)
;         (PROVE-QUERY (CAR CLAUSES) BINDS)
;       (PROVE-AND (CDR CLAUSES) BINDS))
; ==>
;   (LET ((*CONT* #'(LAMBDA (BINDS) (PROVE-AND # BINDS))))
;     (PROVE-QUERY (CAR CLAUSES) BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
STYLE-WARNING:
   PROVE-OR is being redefined as a macro when it was previously assumed to be a function.

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-OR
;     (=DEFUN PROVE-OR
;         (CLAUSES BINDS)
;       (CHOOSE-BIND C
;           CLAUSES
;         (PROVE-QUERY C BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-OR
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-OR
;         (CHOOSE-BIND C
;             CLAUSES
;           (PROVE-QUERY C BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 
STYLE-WARNING:
   PROVE-NOT is being redefined as a macro when it was previously assumed to be a function.

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-NOT
;     (=DEFUN PROVE-NOT
;         (EXPR BINDS)
;       (LET ((SAVE-PATHS *PATHS*))
;         (SETQ *PATHS* NIL)
;         (CHOOSE
;          (=BIND (B)
;              (PROVE-QUERY EXPR BINDS)
;            (SETQ #)
;            (FAIL))
;          (PROGN (SETQ #) (=VALUES BINDS)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-NOT
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-NOT
;         (LET ((SAVE-PATHS *PATHS*))
;           (SETQ *PATHS* NIL)
;           (CHOOSE
;            (=BIND #
;                #
;              #
;              #)
;            (PROGN # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (B)
;         (PROVE-QUERY EXPR BINDS)
;       (SETQ *PATHS* SAVE-PATHS)
;       (FAIL))
; ==>
;   (LET ((*CONT* #'(LAMBDA (B) (SETQ #) (FAIL))))
;     (PROVE-QUERY EXPR BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; --> LET 
; ==>
;   #'(LAMBDA (B) (SETQ *PATHS* SAVE-PATHS) (FAIL))
; 
; caught STYLE-WARNING:
;   The variable B is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
my plus called 
STYLE-WARNING:
   PROVE-SIMPLE is being redefined as a macro when it was previously assumed to be a function.

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-SIMPLE
;     (=DEFUN PROVE-SIMPLE
;         (QUERY BINDS)
;       (CHOOSE-BIND R
;           *RLIST*
;         (IMPLIES R QUERY BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-SIMPLE
;         (*CONT* QUERY BINDS)
;       (BLOCK =PROVE-SIMPLE
;         (CHOOSE-BIND R
;             *RLIST*
;           (IMPLIES R QUERY BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.

my plus called 
; in: =DEFUN PROVE-SIMPLE
;     (CHOOSE-BIND R
;         *RLIST*
;       (IMPLIES R QUERY BINDS))
; ==>
;   (CB #'(LAMBDA (R) (IMPLIES R QUERY BINDS)) *RLIST*)
; 
; caught WARNING:
;   undefined variable: *RLIST*

;     (IMPLIES R QUERY BINDS)
; 
; caught STYLE-WARNING:
;   undefined function: IMPLIES
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     IMPLIES
;   Undefined variable:
my plus called 
;     *RLIST*
;   caught 1 WARNING condition
;   caught 3 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
STYLE-WARNING:
   IMPLIES is being redefined as a macro when it was previously assumed to be a function.

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN IMPLIES
;     (=DEFUN IMPLIES
;         (R QUERY BINDS)
;       (LET ((R2 (CHANGE-VARS R)))
;         (AIF2 (MATCH QUERY (CDR R2) BINDS) (PROVE-QUERY (CAR R2) IT) (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =IMPLIES
;         (*CONT* R QUERY BINDS)
;       (BLOCK =IMPLIES
;         (LET ((R2 #))
;           (AIF2 (MATCH QUERY # BINDS) (PROVE-QUERY # IT) (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; in: =DEFUN IMPLIES
;     (CHANGE-VARS R)
; 
; caught STYLE-WARNING:
;   undefined function: CHANGE-VARS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     CHANGE-VARS
;   caught 2 STYLE-WARNING conditions
T
* (<- (painter ?x) (hungry ?x) (smells-of ?x turpentine))

1
* (mp (<- (painter ?x) (hungry ?x) (smells-of ?x turpentine)))

(LENGTH
 (CONC1F *RLIST*
         (REP_
          (CONS '(AND (HUNGRY ?X) (SMELLS-OF ?X TURPENTINE)) '(PAINTER ?X)))))
T
* (defvar *listtest* nil)

*LISTTEST*
* (conc1f *listtest* '(love you (really)))

((LOVE YOU (REALLY)))
* *listtest*

((LOVE YOU (REALLY)))
* (<- (hungry ?x) (or (gaunt ?x) (eats-ravenously ?x)))

2
* (<- (gaunt raoul))

3
* (<- (smells-of raoul turpentine))

4
* (mp (<- (painter rubens)))

5
* (mp (<- (painter rubens)))

(LENGTH (CONC1F *RLIST* (REP_ (CONS '(AND) '(PAINTER RUBENS)))))
T
*(with-inference (painter ?x) (painter ?x)

my plus called 
; in: PAINTER ?X
;     (PAINTER ?X)
; 
; caught WARNING:
;   undefined variable: ?X
; 
; caught STYLE-WARNING:
;   undefined function: PAINTER
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     PAINTER
;   Undefined variable:
my plus called 
;     ?X
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable ?X is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (with-inference (painter ?x) (print ?x))
my plus called 
; in: WITH-INFERENCE (PAINTER ?X)
;     (LET ((*CONT*
;            #'(LAMBDA (BINDS)
;                (LET #
;                  #
;                  #))))
;       (PROVE-QUERY '(PAINTER ?X) NIL))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::PROVE-SIMPLE is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (&REST SB-C::ARGS) :IN MACRO-FUNCTION))
0] abort
* (load "clcont.lisp")


; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: SETQ *CONT*
;     (SETQ *CONT* #'IDENTITY)
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-QUERY
;     (=DEFUN PROVE-QUERY
;         (EXPR BINDS)
;       (CASE (CAR EXPR)
;         (AND (PROVE-AND (CDR EXPR) BINDS))
;         (OR (PROVE-OR (CDR EXPR) BINDS))
;         (NOT (PROVE-NOT (CDR EXPR) BINDS))
;         (T (PROVE-SIMPLE EXPR BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-QUERY
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-QUERY
;         (CASE (CAR EXPR)
;           (AND (PROVE-AND # BINDS))
;           (OR (PROVE-OR # BINDS))
;           (NOT (PROVE-NOT # BINDS))
;           (T (PROVE-SIMPLE EXPR BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-AND
;     (=DEFUN PROVE-AND
;         (CLAUSES BINDS)
;       (IF (NULL CLAUSES)
;           (=VALUES BINDS)
;           (=BIND (BINDS)
;               (PROVE-QUERY (CAR CLAUSES) BINDS)
;             (PROVE-AND (CDR CLAUSES) BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-AND
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-AND
;         (IF (NULL CLAUSES)
;             (=VALUES BINDS)
;             (=BIND (BINDS)
;                 (PROVE-QUERY # BINDS)
;               (PROVE-AND # BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (BINDS)
;         (PROVE-QUERY (CAR CLAUSES) BINDS)
;       (PROVE-AND (CDR CLAUSES) BINDS))
; ==>
;   (LET ((*CONT* #'(LAMBDA (BINDS) (PROVE-AND # BINDS))))
;     (PROVE-QUERY (CAR CLAUSES) BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-OR
;     (=DEFUN PROVE-OR
;         (CLAUSES BINDS)
;       (CHOOSE-BIND C
;           CLAUSES
;         (PROVE-QUERY C BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-OR
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-OR
;         (CHOOSE-BIND C
;             CLAUSES
;           (PROVE-QUERY C BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-NOT
;     (=DEFUN PROVE-NOT
;         (EXPR BINDS)
;       (LET ((SAVE-PATHS *PATHS*))
;         (SETQ *PATHS* NIL)
;         (CHOOSE
;          (=BIND (B)
;              (PROVE-QUERY EXPR BINDS)
;            (SETQ #)
;            (FAIL))
;          (PROGN (SETQ #) (=VALUES BINDS)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-NOT
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-NOT
;         (LET ((SAVE-PATHS *PATHS*))
;           (SETQ *PATHS* NIL)
;           (CHOOSE
;            (=BIND #
;                #
;              #
;              #)
;            (PROGN # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (B)
;         (PROVE-QUERY EXPR BINDS)
;       (SETQ *PATHS* SAVE-PATHS)
;       (FAIL))
; ==>
;   (LET ((*CONT* #'(LAMBDA (B) (SETQ #) (FAIL))))
;     (PROVE-QUERY EXPR BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; --> LET 
; ==>
;   #'(LAMBDA (B) (SETQ *PATHS* SAVE-PATHS) (FAIL))
; 
; caught STYLE-WARNING:
;   The variable B is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-SIMPLE
;     (=DEFUN PROVE-SIMPLE
;         (QUERY BINDS)
;       (CHOOSE-BIND R
;           *RLIST*
;         (IMPLIES R QUERY BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-SIMPLE
;         (*CONT* QUERY BINDS)
;       (BLOCK =PROVE-SIMPLE
;         (CHOOSE-BIND R
;             *RLIST*
;           (IMPLIES R QUERY BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN IMPLIES
;     (=DEFUN IMPLIES
;         (R QUERY BINDS)
;       (LET ((R2 (CHANGE-VARS R)))
;         (AIF2 (MATCH QUERY (CDR R2) BINDS) (PROVE-QUERY (CAR R2) IT) (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =IMPLIES
;         (*CONT* R QUERY BINDS)
;       (BLOCK =IMPLIES
;         (LET ((R2 #))
;           (AIF2 (MATCH QUERY # BINDS) (PROVE-QUERY # IT) (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (mp ((with-inference (painter ?x) (print ?x))))
my plus called 
; in: WITH-INFERENCE (PAINTER ?X)
;     (LET ((*CONT*
;            #'(LAMBDA (BINDS)
;                (LET #
;                  #
;                  #))))
;       (PROVE-QUERY '(PAINTER ?X) NIL))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

RAOUL 
RUBENS 
@
* (mp (with-inference (painter ?x) (print ?x)))

((WITH-INFERENCE (PAINTER ?X)
   (PRINT ?X)))
NIL
* (mp (with-inference (painter ?x) (print ?x)))

(PROGN
 (SETQ *PATHS* NIL)
 (=BIND (BINDS)
     (PROVE-QUERY '(PAINTER ?X) NIL)
   (LET ((?X (FULLBIND '?X BINDS)))
     (PRINT ?X)
     (FAIL))))
T
* (<- (append nil ?xs ?xs))

6
*(mp  (<- (append (?x . ?xs) ?ys (?x . ?zs))
      (append ?xs ?ys ?zs)))

7
* (with-inference (append ?x (c d) (a b c d))
		  (format t "left: ~a ~%" ?x))
my plus called 
; in: WITH-INFERENCE (APPEND ?X (C D) (A B C D))
;     (LET ((*CONT*
;            #'(LAMBDA (BINDS)
;                (LET #
;                  #
;                  #))))
;       (PROVE-QUERY '(APPEND ?X (C D) (A B C D)) NIL))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
left: (A B) 
@
* (mp  (<- (append (?x . ?xs) ?ys (?x . ?zs))
      (append ?xs ?ys ?zs)))

(LENGTH
 (CONC1F *RLIST*
         (REP_
          (CONS '(APPEND ?XS ?YS ?ZS) '(APPEND (?X . ?XS) ?YS (?X . ?ZS))))))
T
* (sublis '(1 2) '(a b))

debugger invoked on a TYPE-ERROR: The value 1 is not of type LIST.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-KERNEL:%ASSOC-TEST
 #<unavailable argument>
 #<unavailable argument>
 #<unavailable argument>)
0] (mp (sublis '((1 2) (3 4)) '(a b)))

(A B)
0] abort

* (sublis '((2 3) (4 5)) '(a b c d e f))

(SUBLIS '((1 2) (3 4)) '(A B))
NIL
* (sublis '((2 3) (4 5)) '(a b c d e f))

(A B C D E F)
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-QUERY
;     (=DEFUN PROVE-QUERY
;         (EXPR BINDS)
;       (CASE (CAR EXPR)
;         (AND (PROVE-AND (CDR EXPR) BINDS))
;         (OR (PROVE-OR (CDR EXPR) BINDS))
;         (NOT (PROVE-NOT (CDR EXPR) BINDS))
;         (T (PROVE-SIMPLE EXPR BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-QUERY
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-QUERY
;         (CASE (CAR EXPR)
;           (AND (PROVE-AND # BINDS))
;           (OR (PROVE-OR # BINDS))
;           (NOT (PROVE-NOT # BINDS))
;           (T (PROVE-SIMPLE EXPR BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-AND
;     (=DEFUN PROVE-AND
;         (CLAUSES BINDS)
;       (IF (NULL CLAUSES)
;           (=VALUES BINDS)
;           (=BIND (BINDS)
;               (PROVE-QUERY (CAR CLAUSES) BINDS)
;             (PROVE-AND (CDR CLAUSES) BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-AND
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-AND
;         (IF (NULL CLAUSES)
;             (=VALUES BINDS)
;             (=BIND (BINDS)
;                 (PROVE-QUERY # BINDS)
;               (PROVE-AND # BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (BINDS)
;         (PROVE-QUERY (CAR CLAUSES) BINDS)
;       (PROVE-AND (CDR CLAUSES) BINDS))
; ==>
;   (LET ((*CONT* #'(LAMBDA (BINDS) (PROVE-AND # BINDS))))
;     (PROVE-QUERY (CAR CLAUSES) BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-OR
;     (=DEFUN PROVE-OR
;         (CLAUSES BINDS)
;       (CHOOSE-BIND C
;           CLAUSES
;         (PROVE-QUERY C BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-OR
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-OR
;         (CHOOSE-BIND C
;             CLAUSES
;           (PROVE-QUERY C BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-NOT
;     (=DEFUN PROVE-NOT
;         (EXPR BINDS)
;       (LET ((SAVE-PATHS *PATHS*))
;         (SETQ *PATHS* NIL)
;         (CHOOSE
;          (=BIND (B)
;              (PROVE-QUERY EXPR BINDS)
;            (SETQ #)
;            (FAIL))
;          (PROGN (SETQ #) (=VALUES BINDS)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-NOT
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-NOT
;         (LET ((SAVE-PATHS *PATHS*))
;           (SETQ *PATHS* NIL)
;           (CHOOSE
;            (=BIND #
;                #
;              #
;              #)
;            (PROGN # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (B)
;         (PROVE-QUERY EXPR BINDS)
;       (SETQ *PATHS* SAVE-PATHS)
;       (FAIL))
; ==>
;   (LET ((*CONT* #'(LAMBDA (B) (SETQ #) (FAIL))))
;     (PROVE-QUERY EXPR BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; --> LET 
; ==>
;   #'(LAMBDA (B) (SETQ *PATHS* SAVE-PATHS) (FAIL))
; 
; caught STYLE-WARNING:
;   The variable B is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-SIMPLE
;     (=DEFUN PROVE-SIMPLE
;         (QUERY BINDS)
;       (PRINC QUERY)
;       (PRINC BINDS)
;       (CHOOSE-BIND R
;           *RLIST*
;         (IMPLIES R QUERY BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-SIMPLE
;         (*CONT* QUERY BINDS)
;       (BLOCK =PROVE-SIMPLE
;         (PRINC QUERY)
;         (PRINC BINDS)
;         (CHOOSE-BIND R
;             *RLIST*
;           (IMPLIES R QUERY BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN IMPLIES
;     (=DEFUN IMPLIES
;         (R QUERY BINDS)
;       (LET ((R2 (CHANGE-VARS R)))
;         (AIF2 (MATCH QUERY (CDR R2) BINDS) (PROVE-QUERY (CAR R2) IT) (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =IMPLIES
;         (*CONT* R QUERY BINDS)
;       (BLOCK =IMPLIES
;         (LET ((R2 #))
;           (AIF2 (MATCH QUERY # BINDS) (PROVE-QUERY # IT) (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (with-inference (append ?x (c d) (a b c d))
		  (format t "left: ~a ~%" ?x))
my plus called 
; in: WITH-INFERENCE (APPEND ?X (C D) (A B C D))
;     (LET ((*CONT*
;            #'(LAMBDA (BINDS)
;                (LET #
;                  #
;                  #))))
;       (PROVE-QUERY '(APPEND ?X (C D) (A B C D)) NIL))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
(APPEND ?X (C D) (A B C D))NIL(APPEND ?G12523 ?G12524 ?G12525)((?G12525 B C D)
                                                               (?G12522 . A)
                                                               (?G12524 C D)
                                                               (?X ?G12522
                                                                . ?G12523))(APPEND
                                                                            ?G12530
                                                                            ?G12531
                                                                            ?G12532)((?G12532
                                                                                      C
                                                                                      D)
                                                                                     (?G12529
                                                                                      . B)
                                                                                     (?G12531
                                                                                      C
                                                                                      D)
                                                                                     (?G12523
                                                                                      ?G12529
                                                                                      . ?G12530)
                                                                                     (?G12525
                                                                                      B
                                                                                      C
                                                                                      D)
                                                                                     (?G12522
                                                                                      . A)
                                                                                     (?G12524
                                                                                      C
                                                                                      D)
                                                                                     (?X
                                                                                      ?G12522
                                                                                      . ?G12523))left: (A
                                                                                                        B) 
(APPEND ?G12537 ?G12538 ?G12539)((?G12539 D) (?G12536 . C) (?G12538 C D)
                                 (?G12530 ?G12536 . ?G12537) (?G12532 C D)
                                 (?G12529 . B) (?G12531 C D)
                                 (?G12523 ?G12529 . ?G12530) (?G12525 B C D)
                                 (?G12522 . A) (?G12524 C D)
                                 (?X ?G12522 . ?G12523))(APPEND ?G12544 ?G12545
                                                                ?G12546)((?G12546)
                                                                         (?G12543
                                                                          . D)
                                                                         (?G12545
                                                                          C D)
                                                                         (?G12537
                                                                          ?G12543
                                                                          . ?G12544)
                                                                         (?G12539
                                                                          D)
                                                                         (?G12536
                                                                          . C)
                                                                         (?G12538
                                                                          C D)
                                                                         (?G12530
                                                                          ?G12536
                                                                          . ?G12537)
                                                                         (?G12532
                                                                          C D)
                                                                         (?G12529
                                                                          . B)
                                                                         (?G12531
                                                                          C D)
                                                                         (?G12523
                                                                          ?G12529
                                                                          . ?G12530)
                                                                         (?G12525
                                                                          B C
                                                                          D)
                                                                         (?G12522
                                                                          . A)
                                                                         (?G12524
                                                                          C D)
                                                                         (?X
                                                                          ?G12522
                                                                          . ?G12523))
@
* (load "clcont.lisp")
; 
; caught WARNING:
;   undefined variable: *CONT*
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     *CONT*
;   caught 1 WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT-NODE
;     (=DEFUN DFT-NODE
;         (TREE)
;       (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;             (T (PUSH #'(LAMBDA # #) *SAVED*) (DFT-NODE (CAR TREE)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT-NODE
;         (*CONT* TREE)
;       (BLOCK =DFT-NODE
;         (COND ((NULL TREE) (RESTART-C)) ((ATOM TREE) (=VALUES TREE))
;               (T (PUSH #'# *SAVED*) (DFT-NODE #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN RESTART-C
;     (=DEFUN RESTART-C
;         NIL
;       (IF *SAVED*
;           (FUNCALL (POP *SAVED*))
;           (=VALUES 'DONE)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =RESTART-C
;         (*CONT*)
;       (BLOCK =RESTART-C
;         (IF *SAVED*
;             (FUNCALL (POP *SAVED*))
;             (=VALUES 'DONE))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN DFT2
;     (=DEFUN DFT2
;         (TREE)
;       (SETQ *SAVED* NIL)
;       (=BIND (NODE)
;           (DFT-NODE TREE)
;         (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =DFT2
;         (*CONT* TREE)
;       (BLOCK =DFT2
;         (SETQ *SAVED* NIL)
;         (=BIND (NODE)
;             (DFT-NODE TREE)
;           (COND (# #) (T # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (NODE)
;         (DFT-NODE TREE)
;       (COND ((EQ NODE 'DONE) (=VALUES NIL)) (T (PRINC NODE) (RESTART-C))))
; ==>
;   (LET ((*CONT* #'(LAMBDA (NODE) (COND # #))))
;     (DFT-NODE TREE))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN TWO-NUMBERS
;     (=DEFUN TWO-NUMBERS
;         NIL
;       (CHOOSE-BIND N1
;           '(0 1 2 3 4 5 6)
;         (CHOOSE-BIND N2
;             '(0 1 2 3 4 5 6)
;           (=VALUES N1 N2))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =TWO-NUMBERS
;         (*CONT*)
;       (BLOCK =TWO-NUMBERS
;         (CHOOSE-BIND N1
;             '(0 1 2 3 4 5 6)
;           (CHOOSE-BIND N2
;               '(0 1 2 3 4 5 6)
;             (=VALUES N1 N2)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PARLOR-TRICK
;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (N1 N2)
;         (TWO-NUMBERS)
;       (IF (= (+ N1 N2) SUM)
;           `(THE SUM OF ,N1 ,N2)
;           (FAIL)))
; ==>
;   (LET ((*CONT*
;          #'(LAMBDA (N1 N2)
;              (IF #
;                  `#
;                  #))))
;     (TWO-NUMBERS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=DEFUN PARLOR-TRICK
;         (SUM)
;       (=BIND (N1 N2)
;           (TWO-NUMBERS)
;         (IF (= (+ N1 N2) SUM)
;             `(THE SUM OF ,N1 ,N2)
;             (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PARLOR-TRICK
;         (*CONT* SUM)
;       (BLOCK =PARLOR-TRICK
;         (=BIND (N1 N2)
;             (TWO-NUMBERS)
;           (IF (= # SUM)
;               `(THE SUM OF ,N1 ,N2)
;               (FAIL)))))
; 
; caught STYLE-WARNING:
;   The variable *CONT* is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-QUERY
;     (=DEFUN PROVE-QUERY
;         (EXPR BINDS)
;       (CASE (CAR EXPR)
;         (AND (PROVE-AND (CDR EXPR) BINDS))
;         (OR (PROVE-OR (CDR EXPR) BINDS))
;         (NOT (PROVE-NOT (CDR EXPR) BINDS))
;         (T (PROVE-SIMPLE EXPR BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-QUERY
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-QUERY
;         (CASE (CAR EXPR)
;           (AND (PROVE-AND # BINDS))
;           (OR (PROVE-OR # BINDS))
;           (NOT (PROVE-NOT # BINDS))
;           (T (PROVE-SIMPLE EXPR BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-AND
;     (=DEFUN PROVE-AND
;         (CLAUSES BINDS)
;       (IF (NULL CLAUSES)
;           (=VALUES BINDS)
;           (=BIND (BINDS)
;               (PROVE-QUERY (CAR CLAUSES) BINDS)
;             (PROVE-AND (CDR CLAUSES) BINDS))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-AND
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-AND
;         (IF (NULL CLAUSES)
;             (=VALUES BINDS)
;             (=BIND (BINDS)
;                 (PROVE-QUERY # BINDS)
;               (PROVE-AND # BINDS)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (BINDS)
;         (PROVE-QUERY (CAR CLAUSES) BINDS)
;       (PROVE-AND (CDR CLAUSES) BINDS))
; ==>
;   (LET ((*CONT* #'(LAMBDA (BINDS) (PROVE-AND # BINDS))))
;     (PROVE-QUERY (CAR CLAUSES) BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-OR
;     (=DEFUN PROVE-OR
;         (CLAUSES BINDS)
;       (CHOOSE-BIND C
;           CLAUSES
;         (PROVE-QUERY C BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-OR
;         (*CONT* CLAUSES BINDS)
;       (BLOCK =PROVE-OR
;         (CHOOSE-BIND C
;             CLAUSES
;           (PROVE-QUERY C BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-NOT
;     (=DEFUN PROVE-NOT
;         (EXPR BINDS)
;       (LET ((SAVE-PATHS *PATHS*))
;         (SETQ *PATHS* NIL)
;         (CHOOSE
;          (=BIND (B)
;              (PROVE-QUERY EXPR BINDS)
;            (SETQ #)
;            (FAIL))
;          (PROGN (SETQ #) (=VALUES BINDS)))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-NOT
;         (*CONT* EXPR BINDS)
;       (BLOCK =PROVE-NOT
;         (LET ((SAVE-PATHS *PATHS*))
;           (SETQ *PATHS* NIL)
;           (CHOOSE
;            (=BIND #
;                #
;              #
;              #)
;            (PROGN # #)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

;     (=BIND (B)
;         (PROVE-QUERY EXPR BINDS)
;       (SETQ *PATHS* SAVE-PATHS)
;       (FAIL))
; ==>
;   (LET ((*CONT* #'(LAMBDA (B) (SETQ #) (FAIL))))
;     (PROVE-QUERY EXPR BINDS))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables

my plus called 
; --> LET 
; ==>
;   #'(LAMBDA (B) (SETQ *PATHS* SAVE-PATHS) (FAIL))
; 
; caught STYLE-WARNING:
;   The variable B is defined but never used.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN PROVE-SIMPLE
;     (=DEFUN PROVE-SIMPLE
;         (QUERY BINDS)
;       (FORMAT T "query:~a ~%" QUERY)
;       (FORMAT T "query:~a ~%" BINDS)
;       (CHOOSE-BIND R
;           *RLIST*
;         (IMPLIES R QUERY BINDS)))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =PROVE-SIMPLE
;         (*CONT* QUERY BINDS)
;       (BLOCK =PROVE-SIMPLE
;         (FORMAT T "query:~a ~%" QUERY)
;         (FORMAT T "query:~a ~%" BINDS)
;         (CHOOSE-BIND R
;             *RLIST*
;           (IMPLIES R QUERY BINDS))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
my plus called 
my plus called 
my plus called 

; file: /Users/apple/work_foot/lisp_field/clcont.lisp
my plus called 
; in: =DEFUN IMPLIES
;     (=DEFUN IMPLIES
;         (R QUERY BINDS)
;       (LET ((R2 (CHANGE-VARS R)))
;         (AIF2 (MATCH QUERY (CDR R2) BINDS) (PROVE-QUERY (CAR R2) IT) (FAIL))))
my plus called 
my plus called 
; --> PROGN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA =IMPLIES
;         (*CONT* R QUERY BINDS)
;       (BLOCK =IMPLIES
;         (LET ((R2 #))
;           (AIF2 (MATCH QUERY # BINDS) (PROVE-QUERY # IT) (FAIL)))))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
T
* (with-inference (append ?x (c d) (a b c d))
		  (format t "left: ~a ~%" ?x))
my plus called 
; in: WITH-INFERENCE (APPEND ?X (C D) (A B C D))
;     (LET ((*CONT*
;            #'(LAMBDA (BINDS)
;                (LET #
;                  #
;                  #))))
;       (PROVE-QUERY '(APPEND ?X (C D) (A B C D)) NIL))
; 
; caught STYLE-WARNING:
;   using the lexical binding of the symbol (COMMON-LISP-USER::*CONT*), not the
;   dynamic binding, even though the name follows
;   the usual naming convention (names like *FOO*) for special variables
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
query:(APPEND ?X (C D) (A B C D)) 
query:NIL 
query:(APPEND ?G12700 ?G12701 ?G12702) 
query:((?G12702 B C D) (?G12699 . A) (?G12701 C D) (?X ?G12699 . ?G12700)) 
query:(APPEND ?G12707 ?G12708 ?G12709) 
query:((?G12709 C D) (?G12706 . B) (?G12708 C D) (?G12700 ?G12706 . ?G12707)
       (?G12702 B C D) (?G12699 . A) (?G12701 C D) (?X ?G12699 . ?G12700)) 
left: (A B) 
query:(APPEND ?G12714 ?G12715 ?G12716) 
query:((?G12716 D) (?G12713 . C) (?G12715 C D) (?G12707 ?G12713 . ?G12714)
       (?G12709 C D) (?G12706 . B) (?G12708 C D) (?G12700 ?G12706 . ?G12707)
       (?G12702 B C D) (?G12699 . A) (?G12701 C D) (?X ?G12699 . ?G12700)) 
query:(APPEND ?G12721 ?G12722 ?G12723) 
query:((?G12723) (?G12720 . D) (?G12722 C D) (?G12714 ?G12720 . ?G12721)
       (?G12716 D) (?G12713 . C) (?G12715 C D) (?G12707 ?G12713 . ?G12714)
       (?G12709 C D) (?G12706 . B) (?G12708 C D) (?G12700 ?G12706 . ?G12707)
       (?G12702 B C D) (?G12699 . A) (?G12701 C D) (?X ?G12699 . ?G12700)) 
@
* (defprop cool t)

my plus called 
; in: DEFPROP COOL
;     (DEFPROP COOL T)
; 
; caught WARNING:
;   undefined variable: COOL
; 
; caught STYLE-WARNING:
;   undefined function: DEFPROP
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     DEFPROP
;   Undefined variable:
my plus called 
;     COOL
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::DEFPROP is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (load "clos.lisp")


; file: /Users/apple/work_foot/lisp_field/clos.lisp
my plus called 
; in: DEFUN RGETOLD
;     (GET-ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: GET-ANCESTORS

;     (SOME2 #'(LAMBDA (A) (GETHASH PROP A)) (GET-ANCESTORS OBJ))
; 
; caught STYLE-WARNING:
;   undefined function: SOME2
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     GET-ANCESTORS SOME2
;   caught 2 STYLE-WARNING conditions
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

my plus called 
; in: DEFUN RUN-METHODS
;     (RGET OBJ NAME :AROUND)
; 
; caught STYLE-WARNING:
;   undefined function: RGET

;     (RUN-CORE-METHODS OBJ NAME ARGS PRI)
; 
; caught STYLE-WARNING:
;   undefined function: RUN-CORE-METHODS
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
;     RGET RUN-CORE-METHODS
;   caught 2 STYLE-WARNING conditions

my plus called 
; in: DEFUN RUN-CORE-METHODS
;     (RGET OBJ NAME :PRIMARY)
; 
; caught STYLE-WARNING:
;   undefined function: RGET

;     (RUN-AFTERS OBJ NAME ARGS)
; 
; caught STYLE-WARNING:
;   undefined function: RUN-AFTERS

;     (RUN-BEFORES OBJ NAME ARGS)
; 
; caught STYLE-WARNING:
;   undefined function: RUN-BEFORES
; 
; compilation unit finished
;   Undefined functions:
my plus called 
my plus called 
my plus called 
;     RGET RUN-AFTERS RUN-BEFORES
;   caught 3 STYLE-WARNING conditions

my plus called 
; in: DEFUN RGET
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-BEFORES
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN MY-RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    illegal terminating character after a colon: #\

      Line: 104, Column: 41, File-Position: 3318

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/clos.lisp"
                {120C6371}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/clos.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/clos.lisp"
   {120C6371}>
 3221)
0] abort
T
* (load "clos.lisp")
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

my plus called 
; in: DEFUN RGET
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-BEFORES
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN MY-RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFMACRO DEFMETH
;     (BUILD-METH NAME TYPE GOBJ PARMS BODY)
; 
; caught STYLE-WARNING:
;   undefined function: BUILD-METH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     BUILD-METH
;   caught 1 STYLE-WARNING condition
T
* (load "clos.lisp")
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

my plus called 
; in: DEFUN RGET
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-BEFORES
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN MY-RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition
T
* (setq filesystem (obj))

my plus called 
; in: SETQ FILESYSTEM
;     (SETQ FILESYSTEM (OBJ))
; 
; caught WARNING:
;   undefined variable: FILESYSTEM

;     (OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: OBJ
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     OBJ
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::OBJ is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (defvar filesystem (make-hash))

my plus called 
; in: DEFVAR FILESYSTEM
;     (MAKE-HASH)
; 
; caught STYLE-WARNING:
;   undefined function: MAKE-HASH
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     MAKE-HASH
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::MAKE-HASH is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (defvar *myobj* (make-hash-table))

*MYOBJ*
* (defmeth (backup :before) *myobj* (inobj)
    (format t "I am before ~%"))
my plus called 
; in: DEFMETH (BACKUP :BEFORE)
;     #'(LAMBDA (INOBJ) (FORMAT T "I am before ~%"))
; 
; caught STYLE-WARNING:
;   The variable INOBJ is defined but never used.

my plus called 
; in: DEFPROP BACKUP
;     (DEFPROP BACKUP T)
; 
; caught WARNING:
;   undefined variable: BACKUP
; 
; caught STYLE-WARNING:
;   undefined function: DEFPROP
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     DEFPROP
;   Undefined variable:
my plus called 
;     BACKUP
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions

debugger invoked on a UNBOUND-VARIABLE: The variable BACKUP is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (symbol-function 'cool)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::COOL is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-FUNCTION COOL)
0] abort

* (my-defun cool (x y) (format t "x:~a, y :~a ~%" x y))

COOL
* (cool 10 20)
x:10, y :20 
NIL
* (setf (symbol-function 'any-fun) #'(lambda (x) (format t "x:~a ~%" x)))

#<FUNCTION (LAMBDA (X)) {12D56DDD}>
* (any-fun 1)
x:1 
NIL
* (symbol-function 'some-fun)

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::SOME-FUN is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-FUNCTION SOME-FUN)
0] abort

* (symbolp 'any-fun)

T
* (symbolp 'some-fun)

T
* (load "clos.lisp")
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 


; file: /Users/apple/work_foot/lisp_field/clos.lisp
my plus called 
; in: DEFUN RGET
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-BEFORES
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN MY-RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN OBJ
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

debugger invoked on a SB-C::INPUT-ERROR-IN-COMPILE-FILE:
  READ failure in COMPILE-FILE:
    Comma not inside a backquote.

      Line: 164, Column: 16, File-Position: 5241

      Stream: #<SB-SYS:FD-STREAM
                for "file /Users/apple/work_foot/lisp_field/clos.lisp"
                {12D69061}>

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Abort loading file "/Users/apple/work_foot/lisp_field/clos.lisp".
  1:         Exit debugger, returning to top level.

(SB-C::READ-FOR-COMPILE-FILE
 #<SB-SYS:FD-STREAM for "file /Users/apple/work_foot/lisp_field/clos.lisp"
   {12D69061}>
 5162)
0] abort
T
* (load "clos.lisp")
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 

my plus called 
; in: DEFUN RGET
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-BEFORES
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN MY-RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN RUN-AFTERS
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN OBJ
;     (ANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: ANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     ANCESTORS
;   caught 1 STYLE-WARNING condition

my plus called 
; in: DEFUN ANCESTORS
;     (GETANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: GETANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     GETANCESTORS
;   caught 1 STYLE-WARNING condition
STYLE-WARNING:
   DEFPROP is being redefined as a macro when it was previously assumed to be a function.
T
* (setq filesystem (obj))

my plus called 
; in: SETQ FILESYSTEM
;     (SETQ FILESYSTEM (OBJ))
; 
; caught WARNING:
;   undefined variable: FILESYSTEM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::GETANCESTORS is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abor
* (load "clos.lisp")
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 


; file: /Users/apple/work_foot/lisp_field/clos.lisp
my plus called 
; in: DEFUN ANCESTORS
;     (GETANCESTORS OBJ)
; 
; caught STYLE-WARNING:
;   undefined function: GETANCESTORS
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     GETANCESTORS
;   caught 1 STYLE-WARNING condition
T
* (setq filesystem (obj))

my plus called 
; in: SETQ FILESYSTEM
;     (SETQ FILESYSTEM (OBJ))
; 
; caught WARNING:
;   undefined variable: FILESYSTEM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition

debugger invoked on a UNDEFINED-FUNCTION:
  The function COMMON-LISP-USER::GETANCESTORS is undefined.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

("undefined function")
0] abort
* (load "clos.lisp")
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
my plus called 
T
* (setq filesystem (obj))
; 
; caught WARNING:
;   undefined variable: FILESYSTEM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition
#<HASH-TABLE :TEST EQL :COUNT 2 {124BCE51}>
* (defmeth (backup :before) filesystem (fs)
    (format t "before backup ~%"))
my plus called 
; in: DEFMETH (BACKUP :BEFORE)
;     #'(LAMBDA (FS) (FORMAT T "before backup ~%"))
; 
; caught STYLE-WARNING:
;   The variable FS is defined but never used.

my plus called 
; in: DEFMETH (BACKUP :BEFORE)
;     (LET ((#:G12946 FILESYSTEM))
;       (DEFPROP BACKUP T)
;       (UNLESS (METH-P (GETHASH 'BACKUP #:G12946))
;         (SETF (GETHASH 'BACKUP #:G12946) (MAKE-METH)))
;       (SETF (METH-BEFORE (GETHASH 'BACKUP #:G12946))
;               #'(LAMBDA (&REST #:G12947)
;                   (LABELS #
;                     #))))
; 
; caught WARNING:
;   undefined variable: FILESYSTEM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
#<FUNCTION (LAMBDA (&REST #:G12947)) {1257A9A5}>
* (defmeth (backup) filesystem (fs)
    (format t "backup ~%"))
my plus called 
; in: DEFMETH (BACKUP)
;     #'(LAMBDA (FS) (FORMAT T "backup ~%"))
; 
; caught STYLE-WARNING:
;   The variable FS is defined but never used.

my plus called 
(; in: DEFMETH (BACKUP)
;     (LET ((#:G12948 FILESYSTEM))
;       (DEFPROP BACKUP T)
;       (UNLESS (METH-P (GETHASH 'BACKUP #:G12948))
;         (SETF (GETHASH 'BACKUP #:G12948) (MAKE-METH)))
;       (SETF (METH-PRIMARY (GETHASH 'BACKUP #:G12948))
;               #'(LAMBDA (&REST #:G12949)
;                   (LABELS #
;                     #))))
; 
; caught WARNING:
;   undefined variable: FILESYSTEM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
STYLE-WARNING: redefining COMMON-LISP-USER::BACKUP in DEFUN
#<FUNCTION (LAMBDA (&REST #:G12949)) {126398CD}>
* (backup (obj filesystem))
before backup 
backup 
NIL
* (backup filesystem)
before backup 
backup 
NIL
* (defmeth (backup :around) filesystem (fs)
    (time (call-next)))
my plus called 
; in: DEFMETH (BACKUP :AROUND)
;     #'(LAMBDA (FS) (TIME (CALL-NEXT)))
; 
; caught STYLE-WARNING:
;   The variable FS is defined but never used.

my plus called 
; in: DEFMETH (BACKUP :AROUND)
;     (LET ((#:G12950 FILESYSTEM))
;       (DEFPROP BACKUP T)
;       (UNLESS (METH-P (GETHASH 'BACKUP #:G12950))
;         (SETF (GETHASH 'BACKUP #:G12950) (MAKE-METH)))
;       (SETF (METH-AROUND (GETHASH 'BACKUP #:G12950))
;               #'(LAMBDA (&REST #:G12951)
;                   (LABELS #
;                     #))))
; 
; caught WARNING:
;   undefined variable: FILESYSTEM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition
STYLE-WARNING: redefining COMMON-LISP-USER::BACKUP in DEFUN
#<CLOSURE (LAMBDA (&REST #:G12951)) {126F51F5}>
* (backup filesystem)
before backup 
backup 
Evaluation took:
  0.001 seconds of real time
  0.000245 seconds of total run time (0.000055 user, 0.000190 system)
  0.00% CPU
  79,800 processor cycles
  0 bytes consed
  
NIL
* (undefmeth (backup :around) filesystem)

my plus called 
; in: UNDEFMETH (BACKUP :AROUND)
;     (GETHASH 'BACKUP FILESYSTEM)
; ==>
;   (SB-IMPL::GETHASH3 'BACKUP FILESYSTEM NIL)
; 
; caught WARNING:
;   undefined variable: FILESYSTEM
; 
; compilation unit finished
;   Undefined variable:
my plus called 
;     FILESYSTEM
;   caught 1 WARNING condition
NIL
* (backup filesystem)
before backup 
backup 
NIL
* (defclass person () ((name :accessor name) (age :accessor age)))

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  Slot initarg name "Anonymous" for slot NAME in DEFCLASS PERSON is not a symbol.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-PCL::CANONIZE-DEFCLASS-SLOTS
 PERSON
 ((NAME :ACCESSOR NAME :INITARG "Anonymous") (AGE :ACCESSOR AGE :INITARG 1))
 #<NULL-LEXENV>)
0] abort

* (defclass human () ((name :accessor name) (age :accessor age)))

debugger invoked on a SB-PCL::METAOBJECT-INITIALIZATION-VIOLATION:
  Cannot CHANGE-CLASS objects into CLASS metaobjects.
See also:
  AMOP, Initialization of Class Metaobjects

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((FLET SB-THREAD::WITH-RECURSIVE-LOCK-THUNK :IN CHANGE-CLASS))
0] abort

* (defclass animal () ((name :accessor name :initarg :name) (age :accessor age :initarg :age)))
my plus called 
my plus called 
#<STANDARD-CLASS HUMAN>
* (mp (defmethod create ((man human) why) (format t "Give me a why:~a ~%" why)
(format t "Give me a why:~a ~%" why)
'wonderful))    
STYLE-WARNING: Implicitly creating new generic function CREATE.

#<STANDARD-METHOD CREATE (HUMAN T) {127D14C9}>
* (mp (defmethod create ((man human) why) (format t "Give me a why:~a ~%" why)
(format t "Give me a why:~a ~%" why)
'wonderful))

(PROGN
 (EVAL-WHEN (:LOAD-TOPLEVEL)
   (SB-PCL::%DEFMETHOD-EXPANDER CREATE NIL ((MAN HUMAN) WHY)
                                ((FORMAT T "Give me a why:~a ~%" WHY)
                                 (FORMAT T "Give me a why:~a ~%" WHY)
                                 'WONDERFUL)))
 (EVAL-WHEN (:EXECUTE)
   (SB-PCL::%DEFMETHOD-EXPANDER CREATE NIL ((MAN HUMAN) WHY)
                                ((FORMAT T "Give me a why:~a ~%" WHY)
                                 (FORMAT T "Give me a why:~a ~%" WHY)
                                 'WONDERFUL))))
T
* (create (make-instance 'human) 'freedom)

debugger invoked on a SB-PCL::INITARG-ERROR:
  Invalid initialization argument:
    :NAME
  in call for class #<STANDARD-CLASS HUMAN>.
See also:
  The ANSI Standard, Section 7.1.2

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-PCL::CHECK-MI-INITARGS #<STANDARD-CLASS HUMAN> (:NAME TIAN))
0] abort

* (create (make-instance 'human) 'freedom)
Give me a why:FREEDOM 
Give me a why:FREEDOM 
WONDERFUL
* (defclass animal () ((name :accessor name :initarg :name) (age :accessor age :initarg :age)))

#<STANDARD-CLASS ANIMAL>
* (make-instance 'animal :name "Monkey" :age 37)

#<ANIMAL {12802AA1}>
* (defmethod train ((anim animal) reason) (format t "The reason:~a I train monkey is I love animal ~%" reason) reason)
; 
; caught WARNING:
;   Too few arguments (0) to FORMAT "The reason:~a I train monkey is I love animal ~%": requires at least 1.
;   See also:
;     The ANSI Standard, Section 22.3.10.2
; 
; compilation unit finished
;   caught 1 WARNING condition
STYLE-WARNING: Implicitly creating new generic function TRAIN.

#<STANDARD-METHOD TRAIN (ANIMAL T) {12856441}>
* (mp (defmethod train ((anim animal) reason) (format t "The reason:~a I train monkey is I love animal ~%" reason) reason))
STYLE-WARNING:
   redefining TRAIN (#<STANDARD-CLASS ANIMAL> #<BUILT-IN-CLASS T>) in DEFMETHOD

#<STANDARD-METHOD TRAIN (ANIMAL T) {1288F4A1}>
* (train nil 'hobby)

debugger invoked on a SIMPLE-ERROR:
  There is no applicable method for the generic function
    #<STANDARD-GENERIC-FUNCTION TRAIN (1)>
  when called with arguments
    (NIL HOBBY).

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [RETRY] Retry calling the generic function.
  1: [ABORT] Exit debugger, returning to top level.

((SB-PCL::FAST-METHOD NO-APPLICABLE-METHOD (T))
 #<unused argument>
 #<unused argument>
 #<STANDARD-GENERIC-FUNCTION TRAIN (1)>
 NIL
 HOBBY)
0] abort

* (mp (train (make-instance  'animal :name 'monster :age 250) "interesting"))
The reason:interesting I train monkey is I love animal 
"interesting"
* (mp (train (make-instance  'animal :name 'monster :age 250) "interesting"))

(TRAIN (MAKE-INSTANCE 'ANIMAL :NAME 'MONSTER :AGE 250) "interesting")
NIL
* (mp (defmethod train ((anim animal) reason) (format t "The reason:~a I train monkey is I love animal ~%" reason) reason))

(PROGN
 (EVAL-WHEN (:LOAD-TOPLEVEL)
   (SB-PCL::%DEFMETHOD-EXPANDER TRAIN NIL ((ANIM ANIMAL) REASON)
                                ((FORMAT T
                                         "The reason:~a I train monkey is I love animal ~%"
                                         REASON)
                                 REASON)))
 (EVAL-WHEN (:EXECUTE)
   (SB-PCL::%DEFMETHOD-EXPANDER TRAIN NIL ((ANIM ANIMAL) REASON)
                                ((FORMAT T
                                         "The reason:~a I train monkey is I love animal ~%"
                                         REASON)
                                 REASON))))
T
* (%primitive print "Argh! error in cold init, halting")

my plus called 
; in: %PRIMITIVE PRINT
;     (%PRIMITIVE PRINT "Argh! error in cold init, halting")
; 
; caught STYLE-WARNING:
;   undefined function: %PRIMITIVE
; 
; caught WARNING:
;   undefined variable: PRINT
; 
; compilation unit finished
;   Undefined function:
my plus called 
;     %PRIMITIVE
;   Undefined variable:
my plus called 
;     PRINT
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

debugger invoked on a UNBOUND-VARIABLE: The variable PRINT is unbound.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (symbol-function +)

debugger invoked on a TYPE-ERROR:
  The value (%PRIMITIVE PRINT "Argh! error in cold init, halting")
  is not of type
    SYMBOL.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-FUNCTION (%PRIMITIVE PRINT "Argh! error in cold init, halting"))[:EXTERNAL]
0] abort

* (symbol-function '+)

#<FUNCTION MY-PLUS>
* (symbol-function 'create)

#<STANDARD-GENERIC-FUNCTION CREATE (1)>
* (defgeneric createplus (create) (:method-combination +))
STYLE-WARNING: redefining COMMON-LISP-USER::CREATE in DEFGENERIC

debugger invoked on a SIMPLE-ERROR:
  The lambda-list (X) is incompatible with existing methods of #<STANDARD-GENERIC-FUNCTION
                                                                 CREATE (1)>.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-PCL::SET-ARG-INFO
 #<STANDARD-GENERIC-FUNCTION CREATE (1)>
 :NEW-METHOD
 NIL
 :LAMBDA-LIST
 (X)
 :ARGUMENT-PRECEDENCE-ORDER
 NIL)
0] abort

* (mp (defgeneric createplus (create) (:method-combination +)))

#<STANDARD-GENERIC-FUNCTION CREATEPLUS (0)>
* (mp (defgeneric createplus (create) (:method-combination +)))

(PROGN
 (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
   (SB-PCL::COMPILE-OR-LOAD-DEFGENERIC 'CREATEPLUS))
 (SB-PCL::LOAD-DEFGENERIC 'CREATEPLUS '(CREATE) (SB-C:SOURCE-LOCATION)
                          :METHOD-COMBINATION '(+))
 (FDEFINITION 'CREATEPLUS))
T
* (package-name *package*)

"COMMON-LISP-USER"
* (symbol-package *tiange*)

debugger invoked on a TYPE-ERROR:
  The value #S(PERSON :NAME "cool guy" :AGE 45 :STATUS "happy")
  is not of type
    SYMBOL.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SYMBOL-PACKAGE #S(PERSON :NAME "cool guy" :AGE 45 :STATUS "happy"))[:EXTERNAL]
0] abort

* (symbol-package 'cool)

#<PACKAGE "COMMON-LISP-USER">
* (symbol-package 'hot
)

#<PACKAGE "COMMON-LISP-USER">
* (in-package 'mine :use 'common-lisp)

debugger invoked on a SIMPLE-TYPE-ERROR: 'HAHA cannot be coerced to a string.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(STRING 'HAHA)
0](mp  (in-package 'mine :use 'common-lisp))
my plus called 
; in: LAMBDA (#:G12964)
;     (IN-PACKAGE 'MINE :USE 'COMMON-LISP)
; 
; caught ERROR:
;   during macroexpansion of (IN-PACKAGE 'MINE :USE ...). Use *BREAK-ON-SIGNALS* to
;   intercept:
;   
;    error while parsing arguments to DEFMACRO IN-PACKAGE:
;      invalid number of elements in
;        ('MINE :USE 'COMMON-LISP)
;      to satisfy lambda list
;        (SB-KERNEL:STRING-DESIGNATOR):
;      exactly 1 expected, but 3 found
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  (IN-PACKAGE 'MINE USE 'COMMON-LISP)
Compile-time error:
  during macroexpansion of (IN-PACKAGE 'MINE :USE ...). Use *BREAK-ON-SIGNALS* to
intercept:

 error while parsing arguments to DEFMACRO IN-PACKAGE:
   invalid number of elements in
     ('MINE :USE 'COMMON-LISP)
   to satisfy lambda list
     (SB-KERNEL:STRING-DESIGNATOR):
   exactly 1 expected, but 3 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Reduce debugger level (to debug level 1).
  1:         Exit debugger, returning to top level.

((LAMBDA (#:G12964)) #<unavailable argument>)
0[2] abort

0] abort
* (mp  (in-package 'mine :use 'common-lisp))

debugger invoked on a SB-KERNEL::ARG-COUNT-ERROR:
  error while parsing arguments to DEFMACRO IN-PACKAGE:
    invalid number of elements in
      ('MINE :USE 'COMMON-LISP)
    to satisfy lambda list
      (SB-KERNEL:STRING-DESIGNATOR):
    exactly 1 expected, but 3 found

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (#:WHOLE268373 #:ENVIRONMENT268374)
   :IN
   "/Users/jwise/proj/sbcl/clean/1.0.55/sbcl-1.0.55-x86-darwin/src/cold/compile-cold-sbcl.lisp")
 (IN-PACKAGE 'MINE :USE 'COMMON-LISP)
 #<unavailable argument>)
0] abort

* (in-package "mine")

debugger invoked on a SIMPLE-TYPE-ERROR: 'MINE cannot be coerced to a string.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(STRING 'MINE)
0] abort

* (mp (in-package "mine"))

(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (SETQ *PACKAGE* (SB-INT:FIND-UNDELETED-PACKAGE-OR-LOSE "mine")))
T
* (in-package "mine")

debugger invoked on a SB-KERNEL:SIMPLE-PACKAGE-ERROR:
  The name "mine" does not designate any package.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(SB-INT:%FIND-PACKAGE-OR-LOSE "mine")
0] abort

* (defpackage my-app (:use common-lisp)
    (:export happiness))

debugger invoked on a SB-INT:SIMPLE-PROGRAM-ERROR:
  bogus DEFPACKAGE option: (:NICKNAME APP)

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA (#:WHOLE46686 #:ENVIRONMENT46687)
   :IN
   "/Users/jwise/proj/sbcl/clean/1.0.55/sbcl-1.0.55-x86-darwin/src/cold/compile-cold-sbcl.lisp")
 (DEFPACKAGE MY-APP
   (:USE COMMON-LISP)
   (:NICKNAME APP)
   (:EXPORT HAPPINESS))
 #<unavailable argument>)
0] abort

* (mp (defpackage my-app (:use common-lisp)
    (:export happiness)))

#<PACKAGE "MY-APP">
* (mp (defpackage my-app (:use common-lisp)
    (:export happiness)))

(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (SB-IMPL::%DEFPACKAGE "MY-APP" 'NIL 'NIL 'NIL 'NIL '("COMMON-LISP") 'NIL 'NIL
                        '("HAPPINESS") '("MY-APP") 'NIL 'NIL
                        (SB-C:SOURCE-LOCATION)))
T
* (ldb (byte 8 0) #xabcdef)

205
* (ldb (byte 8 0) #xabcdef)

239
* (let ((in (open "clos.lisp")))
	    (format t "first line:~a ~%" (read-line in))
	    (close in))


(let ((in (open "clos.lisp")))
	    (format t "first line:~a ~%" (read-line in))
  ^C ^C
debugger invoked on a SB-SYS:INTERACTIVE-INTERRUPT:
  Interactive interrupt at #x9C51FB5E.

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] Return from SB-UNIX:SIGINT.
  1: [ABORT   ] Exit debugger, returning to top level.

("bogus stack frame")
0] abort

* (let ((in (open "test.txt"))) (when in
    (format t "first line:~a ~%" (read-line in))
    (close in)))
first line:haha 
T
* ((in (open "test.txt")))
my plus called 
; in: (IN (OPEN "test.txt"))
;     ((IN (OPEN "test.txt")))
; 
; caught ERROR:
;   illegal function call
; 
; compilation unit finished
;   caught 1 ERROR condition

debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR:
  Execution of a form compiled with errors.
Form:
  ((IN (OPEN test.txt)))
Compile-time error:
  illegal function call

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

(#:EVAL-THUNK)
0] abort
* (let ((in (open "test.txt"))) (when in
    (format t "first line:~a ~%" (read-line in))
    (close in)))
first line:haha 
T
* (let ((in (open "test.txt"))) (when in (loop for line = (read-line in nil)
    while line do (format t "~a ~%" line))
    (close in)))
first line:haha 
T
* 