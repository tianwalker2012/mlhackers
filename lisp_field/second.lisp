(defun compose (&rest fns)
  (let ((fn1 (car (reverse fns))) (rest (cdr (reverse fns))))
      #'(lambda (&rest args)
	  (reduce #'(lambda (v f) (funcall f v) )
			    rest
			    :initial-value (apply fn1 args)))))

(defun compose2 (&rest fns)
  (destructuring-bind (fn1 . rest) (reverse fns)
    #'(lambda (&rest args)
	(reduce #'(lambda (v f) (funcall f v))
		rest
		:initial-value (apply fn1 args)))))


(defun disjoin (fn &rest fns)
  (if (null fns)
      fn
      (let ((disj (apply #'disjoin fns)))
	#'(lambda (&rest args)
	    (or (apply fn args)
		(apply disj args))))))

(defun conjoin (fn &rest fns)
  (if (null fns)
      fn
      (let ((conj (apply #'conjoin fns)))
	#'(lambda (&rest args)
	    (and (apply fn args)
		 (apply conj args))))))

(defun curry (fn &rest args)
  #'(lambda (&rest args2)
      (apply fn (append args args2))))

(defun rcurry (fn &rest args)
  #'(lambda (&rest args2)
      (apply fn (append args2 args))))

(defun my-cat (file)
  (with-open-file (instream file :direction :input)
    (do ((line (read-line instream nil 'eof)
	       (read-line instream nil 'eof)))
	 ((eql line 'eof))
	 (format t "~A ~%" line))))

(defmacro ntimes (n &rest body)
  (let ((g (gensym)) (c (gensym)))
    `(let ((,c ,n))
      (do ((,g 0 (+ ,g 1)))
	 ((>= ,g ,c))
       ,@body))))

(defmacro ntimes-recur (n &rest body)
    `(let ((run-it  #'(lambda (count &rest bd)
	   (if (not (equal count 0))
	   (progn (format t "run-it get called ~%") bd (run-it (- count 1) bd))
	 ))))
     (funcall run-it ,n ,@body)) 
)

(defmacro ntimes-recur-ex (n &rest body)
  (if (not (equal n 0))
      `(progn ,@body (ntimes-recur-ex ,(- n 1) ,@body))))

(defmacro random-choice (&rest exprs)
  `(case (random ,(length exprs))
     ,@(let ((key 1))
	    (mapcar #'(lambda (expr) `(,(incf key) ,expr)) exprs))))

(defmacro random-elm (lst)
  `(random-choice ,@(mapcar #'(lambda (expr) expr) lst)))

(defmacro with-gensyms (syms &body body)
  `(let ,(mapcar #'(lambda (s) `(,s (gensym))) syms) ,@body))

(defmacro my-add-m (n &rest rest)
  `(+ ,n ,@rest))


(defmacro my-defun (name parameters &body body)
  `(defun ,name (,@parameters) ,@body)
)

(defmacro my-defun-limit (name parameters body)
  `(defun ,name (,@parameters) ,@body)
)

(defmacro eval-nth-en (n &rest rest)
  (let ((cur rest))
    (progn
    (do ((ct 0 (+ ct 1)))
	((>= ct n))
      (setf cur (cdr cur)))
    `,(car cur)))
)

(defun my-reverse (lst)
  (labels ((reverse-in (org rst)
	     (if (consp org)
		 (reverse-in (cdr org) (cons (car org) rst))
		 rst)))
    (reverse-in lst ()))
)

(defun my-multiple-add (x y)
  (values (+ x y) x y)
)


(defun create-counter (n)
  #'(lambda (opts &optional v)
      (cond ((equal opts 'inc) (setq n (+ n 1)))
	    (t (setq n v)))))

(defun count-instances (obj lsts)
  (labels ((instances-in (lst total)
	     (if (consp lst)
		 (instances-in (cdr lst) (+ total (if (equal (car lst) obj) 1 0)))
		 total)))
    (mapcar #'(lambda (sl) (instances-in sl 0)
			    ) lsts)))

(defun list+ (lst n)
  (mapcar #'(lambda (x) (+ x n)) lst))

;;why quoted list is not safe. Following example will illustrate it
(defun appendquote (lst)
  (append lst '(oh my))
)

(defun flatten(lsts)
  (labels ((flatten-in (lst acc)
	     (let ((elm (car lst)) (remains (cdr lst)))
	       (cond ((consp elm) (flatten-in remains (flatten-in elm acc)))
		     (elm (flatten-in remains (cons elm acc)))
		     (t  (progn (format t "quit for nil ~%") acc))))))
      (reverse (flatten-in lsts ()))) 
)

(defun prune(fn lsts)
  (labels ((prune-in (lst acc)
	     (let ((elm (car lst)) (remains (cdr lst)))
	       (cond ((consp elm) (prune-in remains (cons (reverse (prune-in elm nil)) acc)))
		     (elm (prune-in remains (if (funcall fn elm) (cons elm acc) acc)))
;;It is possible to have a nil as element, so can't assume have nil value mean the end of the list. I assume user don'r want to process nil. I will remove nil. 
;;Is this a valid assumption, I should treat nil as a valid value too.
		     (remains (prune-in remains (if (funcall fn elm) (cons elm acc) acc)))
		     (t acc)))))
    (reverse (prune-in lsts ())))
)

;;The purpose of the function is to iterate the value by the funtion,
;;The fun will return 2 values, the first value tell wether to quit this iteration or not.
;;We only care about the first value but we will relay the second value to outside world.
;;our return value will return 2 values too,
;;The first value was the value generated by the fn
;;The second value used to indicate if it is because the list was over or break in the middle.
(defun my-iterate(fn lsts)
  (let ((elm (car lsts)) (remains (cdr lsts)))
    (cond ((or elm remains) (multiple-value-bind (conti ret) (funcall fn elm lsts) (if conti (my-iterate fn remains) (values ret t))))
	  (t (values nil nil)))))

;;What's the expectation of the caller of before?
;;We want to
;;If a is before b, I will return the lst from which we found a. 
(defun my-before(a b lsts &key (test #'equal))
  (my-iterate 
   #'(lambda (elm curlst) (
			   cond ((funcall test elm a) (values nil curlst))
				((funcall test elm b) (values nil nil))
				(t (values t nil))
			   )) lsts)
)
;;I build a general purpose iteration mechanism. 
;;I love this game. 
(defun my-member(a lsts &key (test #'equal))
  (my-iterate
   #'(lambda (elm curlst) (cond ((funcall test elm a) (values nil curlst))
				(t (values t nil))))
   lsts))

(defun my-after(a b lsts &key (test #'equal))
  (and (my-before b a lsts :test test)
       (my-member a lsts :test test)))


(defun my-treemap (trees fn) 
  (labels ((treemap-in (trs fni acc)
	     (let ((elm (car trs)) (remains (cdr trs)))
	       (cond ((consp elm) (treemap-in remains fni (cons (reverse (treemap-in elm fni nil)) acc)))
		     ((or elm remains) (multiple-value-bind (insert ret) (funcall fni elm) (treemap-in remains fni (if insert (cons ret acc) acc))))
		     (t acc)))))
		 
    (reverse (treemap-in trees fn nil))
	   )
)

(defun my-prune (x trees)
  (my-treemap trees #'(lambda (elm) 
			  (values (not (equal elm x)) elm) 
			  ))
)

;;The fn are just accept the element and return true if find. 
;;I will encapsulate it in my lambda. 
(defun my-findif (fn lsts)
  (my-iterate #'(lambda (elm &optional curlst) (let ((ret (funcall fn elm))) (values (not ret) ret))) lsts)
)

(defun my-splitif (fn lsts)
  (let ((first nil) (second nil))
    (if (my-iterate #'(lambda (elm curlst)
		    (let ((ret (funcall fn elm)))
		      (progn 
			(push elm first)
			(if ret (setf second (cdr curlst)))
			     (values (not ret) ret)))) lsts)
	(values (reverse first) second)
	(values nil nil)))
)

(defun duplicate(elm lsts)
  (let ((ret (member elm lsts)))
    (and ret (member elm (cdr ret)))))

(defmacro my-for (idx beginvar endvar &rest exebody)
   (let ((bv (gensym)) (ev (gensym)))
     `(let ((,bv ,beginvar) (,ev ,endvar))
	(do ((,idx ,bv (+ ,idx 1)))
	    ((>= ,idx ,ev))
	  ,@exebody))))

(defmacro my-dolist(pivot lsts &body body)
  (let ((remain (gensym)))
;;I assume the first cycle enclosed block like let. 
;;but not sure. do a simple test to confirm it
    `(let ((,remain ,lsts))
       (do ((,pivot (car ,remain) (car (setf ,remain (cdr ,remain)))))
	   ((not (or ,pivot ,remain)))
	    ,@body))
    )
)

(defun mkstr (&rest args)
  (with-output-to-string (s)
    (dolist (a args) (princ a s))))



;;Finally get the point how this function are working.
;;It return a function, this function will call rec first
;;and passing 2 parameters, the first parameter is the element,
;;the second parameter is the recursive body, once you call it, 
;;start the same procedure on the second element. 
;;What's so good about lrec?
;;It ease the recognition power. 
;;It just tell what it have done. so you could release your recognition power on
;;other more important things. 
;;other wise you have to define a recursive inner function for your task each time.
;;In this sense, this function is great. 
;;But hold on a little bit, what do we need the "version" for?
;;for turning the recursive into tail recursive.
;;This didn't solve that issue, right?
;;Cool, I identified the issue. 
;;I am glad that I have a shape eyes for this. 
(defun lrec (rec &optional base)
  (labels ((self (lst)
	     (if (null lst)
		 (if (functionp base)
		     (funcall base)
		     base)
		 (funcall rec (car lst)
			  #'(lambda ()
			      (self (cdr lst)))))))
    #'self))

(defun trev (rec &optional base)
  (labels ((self (tr)
	     (if (atom tr)
		   (if (functionp base)
		       (funcall base tr)
		       tr)
		   (funcall rec #'(lambda() (self (car tr))) #'(lambda() (if (cdr tr) (self (cdr tr))))))))
    #'self))

(defun trev-all (tr fn)
  (funcall (trev #'(lambda (left right) (funcall left) (funcall right)) fn) tr)
)

(defun tr-if (tr fn)
  (funcall (trev #'(lambda (left right) (or (funcall left) (funcall right))) fn) tr
 )
)

(defun fun-ret()
  20
)

(defmacro fun-test(x)
 (if (equal (fun-ret) 10)
      `(+ ,x ,(fun-ret))
      `(- ,x ,(fun-ret))
      )
)

(defmacro mp (&body body)
  `(macroexpand-1 ',@body)
)

(defmacro my-destructing-bind (binds parameters &body body)
  `(let (,@(walk-both binds (car parameters) #'(lambda (x y) `(,x ,y))))
     ,@body)
)

(defun walk-both (fst scd fn)
  (labels ((walk-in (first second acc)
   (let ((elm (car first)) (remains (cdr first)))
    (if (atom elm)
	(if remains
	    (walk-in remains (cdr second) (push (funcall fn elm (car second)) acc))
	    (push (funcall fn elm (car second)) acc))
	(if remains ;;element is a tree and have right branch
	    (walk-in remains (cdr second) (walk-in elm (car second) acc))
	    (walk-in elm (car second) acc)))	
	)))
    (walk-in fst scd nil))
)


(defmacro our-expander (name) `(get ,name 'expander))

(defmacro our-defmacro (name parms &body body)
  (let ((g (gensym)))
    `(progn 
       (setf (our-expander ',name)
	     #'(lambda (,g)
		 (block ,name
		   (destructuring-bind ,parms (cdr ,g)
		     ,@body))))
       ',name))
)

(defun our-macroexpand-1 (expr)
  (if (and (consp expr) (our-expander (car expr)))
      (funcall (our-expander (car expr)) expr)
      expr))

(defmacro my-when (initform test &rest body)
  `(do ,initform
       ((not ,test))
     ,@body)
)

(defmacro my-defun (name parms &body body)
  `(progn 
     (setf (symbol-function ',name)
	   #'(lambda ,parms (block ,name ,@body)))
     ',name)
)

(defmacro string-call (opstring &rest args)
  `(,(intern opstring) ,@args))

(defmacro n-list (n expr)
  (let ((ev (gensym)) (lst (gensym)))
    `(let ((,ev ,expr) (,lst ()))
       (progn (ntimes ,n (setf ,lst (cons ,ev ,lst)))
	      ,lst)
       )
    )
)

(defmacro eval-nth (n &rest rest)
  `(if (equal ,n 0)
      ,(car rest)
      (eval-nth (- ,n 1) (cdr ,rest))))


(defmacro call-fun (fn &rest args)
  `(funcall ,fn ,@args)
)
;;what's my intention in this function?
;;I will override the orginal function, will pass control to my block first
;;In current iteration I am not bind the parameter yet. 
;;So what should we do?
;;allow people to choose bind it or not.
(defmacro override-fun (src src-fun-wrapper &body body)
  (let ((old-fun-pointer (gensym)))
    `(let ((,old-fun-pointer (symbol-function ',src))) 
       (setf (symbol-function ',src) 
	     #'(lambda (&rest args) 
		 (let ((,src-fun-wrapper
			#'(lambda () (apply ,old-fun-pointer args)))) 
		   (progn ,@body)
       )))))
)

(defmacro wrap-fun (fun)
  `#'(lambda (&rest args)
       (funcall #'(lambda () (apply ,fun args)))
      )
)


;;(defmacro eval-nth-ite (n &rest rest)
;;  (let ((cur rest))
;;    (progn
;;    (do ((ct 0 (+ ct 1)))
;;	((>= ct n))
;;      (setf cur (cdr cur)))
;;    `,(car cur)))
;;)

(defmacro eval-nth-ite (n &rest rest)
  `(case ,n
     ,@(let ((idx 0)) (mapcar #'(lambda (elm) (incf idx) `(,(- idx 1) ,elm)) rest))) 
)

(defmacro nthe (n lst)
  `(labels ((nth-in (pos lsts)
	      (if (= pos 0)
		  (car lsts)
		  (nth-in (- pos 1) (cdr lsts)))))
     (nth-in ,n ,lst)))

;;why do we need a macro?
;;why not just (or xxoo ooxx oxox)?
;;
(defmacro orexp (&rest args)
  (if (null args)
      nil
      (let ((curval (gensym)))
	`(let ((,curval ,(car args)))
	   (if ,curval
	       ,curval
	       (orexp ,@(cdr args)))))))

(defmacro our-let(binds &body body)
  `(funcall 
#'(lambda (,@(mapcar #'(lambda (bd) (if (consp bd) (car bd) bd)) binds)) ,@body) ,@(mapcar #'(lambda (bd) (if (consp bd) (cadr bd) nil)) binds))
)

;;Following is the more precise simulation of the let
;;No so called real let, but it is good, I have the fluid mindset to quickly 
;;Reach the solution of things
(defmacro real-let(parm)
  `(funcall 
    #'(lambda (,@(mapcar #'(lambda (bd) (if (consp bd) (car bd) bd)) (car parm))) ,@(cdr parm))
    ,@(mapcar #'(lambda (bd) (if (consp bd) (cadr bd) nil)) (car parm)))
)

(defun condlet-clause (vars cl bodfn)
  `(,(car cl) (let ,(mapcar #'cdr vars)
		(let ,(condlet-binds vars cl)
		  (,bodfn ,@(mapcar #'cdr vars))))))

(defun condlet-binds (vars cl)
  (mapcar #'(lambda (bindform)
	      (if (consp bindform)
		  (cons (cdr (assoc (car bindform) vars))
			(cdr bindform))))
	      (cdr cl)))
;;Can you see what he is doing in the function call?
;;How great hacker get the information well sorted and reduce the recognition power?
;;So far I need a actual example to fully understand what's going on. 
;;What problem condlet try to address. 
(defmacro condlet (clauses &body body)
  (let ((bodfn (gensym))
	(vars (mapcar #'(lambda (v) (cons v (gensym))) (remove-duplicates (mapcar #'car (mapend #'cdr clauses))))))
    `(labels ((,bodfn ,(mapcar #'car vars) ,@body))
       (cond ,@(mapcar #'(lambda (cl)
			   (condlet-clause vars cl bodfn)) clauses)))))



(defmacro in (expr &rest args)
  (let ((val (gensym)))
    `(let ((,val ,expr))
       (or ,@(mapcar #'(lambda (elm) `(eql ,val ,elm)) args))
       )))

(defmacro inq (obj &rest args)
  `(in ,obj ,@(mapcar #'(lambda (a) `',a) args))
)

(defmacro in-if (fn &rest args)
  (let ((pred (gensym)))
    `(let ((,pred ,fn))
       (or ,@(mapcar #'(lambda (elm) `(funcall ,pred ,elm)) args))
       )))

(defmacro >case (expr &rest clauses)
  (let ((g (gensym)))
    `(let ((,g ,expr))
       (cond ,@(mapcar #'(lambda (elm) (>casex g cl)) clauses))))
)

(defun >casex (g cl)
  (let ((key (car cl)) (rest (cdr cl)))
    (cond ((consp key) `((in ,g ,@key) ,@rest))
	  ((inq key t otherwise) `(t ,@rest))
	  (t (error "bad >case clause")))))

;;you can use strange name for your macro's name.
;;Flavor of hacker was there. 
(defmacro do-tuples/o (parms source &body body)
  (if parms
      (let ((src (gensym)))
	`(prog ((,src ,source))
	    (mapc #'(lambda ,parms ,@body)
		  ,@(map0-n #'(lambda (n) `(nthcdr ,n ,src))
			    (1- (length parms))))))))

;;Cool, immerse yourself into the beauty of lisp.
;;Why it is beautiful?
;;
(defmacro most-of (&rest args)
  (let ((bar (/ (length args) 2))
	(count (gensym)))
    `(let ((,count 0))
       (or ,@(mapcar #'(lambda (elm) `(and ,elm (> (incf ,count) ,bar))) args)))))

;;What's my expectation to this function?
;;What's my assumption?
;;A list have n element already there.
;;If a element is nil mean not exist. just replace it. 
;;If elm larger than the element all replace the current value and then carry the smaller value to later. until len is zero or encounter nil.
(defun toplist (lst elm  &key (test #'>))
  (labels ((toplist-in (lst elm test)
	     (if (consp lst)
		 (cond ((null (car lst))
			(setf (car lst) elm))
		       ((funcall test elm (car lst))
			(let ((replaced (car lst)))
			  (setf (car lst) elm)
			  (toplist-in (cdr lst) replaced test)))
		       (t (toplist-in (cdr lst) elm test))))))
    (progn (toplist-in lst elm test)
	   lst))
)

(defun genlist(n)
  (labels ((genlist-in (n lst)
	     (if (> n 0)
		 (genlist-in (- n 1) (cons nil lst))
		 lst)))
    (genlist-in n nil))
)
;;what's the purpose of this macro?
;;To return the top N biggest value?
(defmacro nth-most (n &rest args)
  (let ((lh (gensym)))
    `(let ((,lh (genlist ,n)))
       ,@(progn  (dolist (elm args) (toplist lh elm))
		 (toplist)
		 )))
)


(defmacro with-gensym (parms &body body)
  `(let (,@(mapcar #'(lambda (elm) `(,elm (gensym))) parms))
     ,@body)
)

(defun mapx-n (fn start n)
   (let ((lst nil))
    (progn 
    (do ((idx start (+ 1 idx)))
	((> idx n))
      (cons (funcall fn idx) lst)
      )
    (nreverse lst))
    )
)

(defun map0-n(fn n)
  (mapx-n fn 0 (- n 1))
)

(defun map1-n(fn n)
  (mapx-n fn 1 n)
)


(defconstant *segs* 20)
(defconstant *du* (/ 1.0 *segs*))
(defconstant *pts* (make-array (list (+ 1 *segs*) 2)))

;;What's my expectation for this macro?
;;generate bezier curve drawing code
;;Why not afraid of varible capture during the last stage of the code?
;;All the varibles passed in have assigned to internal variables. 
;;the only place will have capture is x2 y2, why not have them 
;;replaced with gensyms,
;;The only possibility that capture could happen is 
;;At x2 and px and y2 and py. 
;;Confusing. Honestly, don't understand why only do half the job.
;;Let;s move ahead. 
(defmacro genbez (x0 y0 x1 y1 x2 y2 x3 y3)
  (with-gensyms (gx0 gx1 gy0 gy1 gx3 gy3)
    `(let ((,gx0 ,x0) (,gy0 ,y0) 
	   (,gx1 ,x1) (,gy1 ,y1)
	   (,gx3 ,x3) (,gy3 ,y3))
       (let ((cx (* (- ,gx1 ,gx0) 3))
	     (cy (* (- ,gy1 ,gy0) 3))
	     (px (* (- ,x2 ,gx1) 3))
	     (py (* (- ,y2 ,gy1) 3)))
	 (let ((bx (- px cx))
	       (by (- py cy))
	       (ax (- ,gx3 px ,gx0))
	       (ay (= ,gy3 py ,gy0)))
	   (setf (aref *pts* 0 0) ,gx0 
		 (aref *pts* 0 1) ,gy0)
	   ,@(map1-n #'(lambda (n)
			 (let* ((u (* n *du*))
				(u^2 (* u u))
				(u^3 (expt u 3)))
			   `(setf (aref *pts* ,n 0)
				  (+ (* ax ,u^3)
				     (* bx ,u^2)
				     (* cx ,u)
				     ,gx0)
				  (aref *pts* ,n 1)
				  (+ (* ay ,u^3)
				     (* by ,u^2)
				     (* cy ,u)
				     ,gy0))))
		     (- 1 *segs*))
	   (setf (aref *pts* *segs* 0) ,gx3
		 (aref *pts* *segs* 1) ,gy3)))))))

(defmacro fn (expr) 
  `#',(rbuild expr))

(defun rbuild (expr)
  (if (or (atom expr) (eql (car expr) 'lambda))
      expr
      (if (eq (car expr) 'compose)
	  (build-compose (cdr expr))
	  (build-call (car expr) (cdr expr)))))

(defun build-call (op fns)
  (let ((g (gensym)))
    '(lambda (,g)
      (,op ,@(mapcar #'(lambda (f)
			 `(,(rbuild f) ,g))
		     fns)))))

(defun build-compose (op fns)
  (let ((g (gensym)))
    `(lambda (,g)
       ,(labels ((rec (fns)
		      (if fns
			  `(,(rbuild (car fns))
			     ,(rec (cdr fns)))
			  g)))
		(rec fns)))))


